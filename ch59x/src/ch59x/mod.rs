//!Peripheral access API for CH592SFR microcontrollers (generated using svd2rust v0.29.0 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.29.0/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
///Number available in the NVIC for configuring priority
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIOA();
    fn GPIOB();
    fn SPI0();
    fn BLEB();
    fn BLEL();
    fn USB();
    fn TMR1();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn I2C();
    fn PWMX();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 36] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIOA },
    Vector { _handler: GPIOB },
    Vector { _handler: SPI0 },
    Vector { _handler: BLEB },
    Vector { _handler: BLEL },
    Vector { _handler: USB },
    Vector { _reserved: 0 },
    Vector { _handler: TMR1 },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: I2C },
    Vector { _handler: PWMX },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: WDOG_BAT },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - TMR0_IRQHandler
        TMR0 = 16,
        ///17 - GPIOA_IRQHandler
        GPIOA = 17,
        ///18 - GPIOB_IRQHandler
        GPIOB = 18,
        ///19 - SPI0_IRQHandler
        SPI0 = 19,
        ///20 - BB_IRQHandler
        BLEB = 20,
        ///21 - LLE_IRQHandler
        BLEL = 21,
        ///22 - USB_IRQHandler
        USB = 22,
        ///24 - TMR1_IRQHandler
        TMR1 = 24,
        ///25 - TMR2_IRQHandler
        TMR2 = 25,
        ///26 - UART0_IRQHandler
        UART0 = 26,
        ///27 - UART1_IRQHandler
        UART1 = 27,
        ///28 - RTC_IRQHandler
        RTC = 28,
        ///29 - ADC_IRQHandler
        ADC = 29,
        ///30 - I2C_IRQHandler
        I2C = 30,
        ///31 - PPWMX_SPI1_IRQHandler
        PWMX = 31,
        ///32 - TMR3_IRQHandler
        TMR3 = 32,
        ///33 - UART2_IRQHandler
        UART2 = 33,
        ///34 - UART3_IRQHandler
        UART3 = 34,
        ///35 - WDOG_BAT_IRQHandler
        WDOG_BAT = 35,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::TMR0),
                17 => Ok(Interrupt::GPIOA),
                18 => Ok(Interrupt::GPIOB),
                19 => Ok(Interrupt::SPI0),
                20 => Ok(Interrupt::BLEB),
                21 => Ok(Interrupt::BLEL),
                22 => Ok(Interrupt::USB),
                24 => Ok(Interrupt::TMR1),
                25 => Ok(Interrupt::TMR2),
                26 => Ok(Interrupt::UART0),
                27 => Ok(Interrupt::UART1),
                28 => Ok(Interrupt::RTC),
                29 => Ok(Interrupt::ADC),
                30 => Ok(Interrupt::I2C),
                31 => Ok(Interrupt::PWMX),
                32 => Ok(Interrupt::TMR3),
                33 => Ok(Interrupt::UART2),
                34 => Ok(Interrupt::UART3),
                35 => Ok(Interrupt::WDOG_BAT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///System Control Register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///System Control Register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x08],
        ///0x08 - RWA, system clock configuration, SAM
        pub clk_sys_cfg: CLK_SYS_CFG,
        ///0x0c - RWA, sleep clock off control byte 0, SAM
        pub slp_clk_off0: SLP_CLK_OFF0,
        ///0x0d - RWA, sleep clock off control byte 1, SAM
        pub slp_clk_off1: SLP_CLK_OFF1,
        ///0x0e - RWA, wake control, SAM
        pub slp_wake_ctrl: SLP_WAKE_CTRL,
        ///0x0f - RWA, peripherals power down control, SAM
        pub slp_power_ctrl: SLP_POWER_CTRL,
        ///0x10 - RWA, Sleep control register, SAM
        pub sleep_ctrl2: SLEEP_CTRL2,
        _reserved6: [u8; 0x04],
        ///0x18 - RW, function pin alternate configuration
        pub pin_alternate: PIN_ALTERNATE,
        ///0x1a - RW, Analog pin enable and digital input disable
        pub pin_analog_ie: PIN_ANALOG_IE,
        ///0x1c - RW, Pin configuration register 2
        pub pin_config2: PIN_CONFIG2,
        ///0x20 - RWA, power plan before sleep instruction, SAM
        pub power_plan: POWER_PLAN,
        ///0x22 - RWA, aux power adjust control, SAM
        pub aux_power_adj: AUX_POWER_ADJ,
        ///0x24 - RWA, battery voltage detector control, SAM
        pub bat_det_ctrl: BAT_DET_CTRL,
        ///0x25 - RWA, battery voltage detector configuration, SAM
        pub bat_det_cfg: BAT_DET_CFG,
        ///0x26 - RO, battery status
        pub bat_status: BAT_STATUS,
        _reserved14: [u8; 0x05],
        ///0x2c - RWA, internal 32KHz oscillator tune control, SAM
        pub int32k_tune: INT32K_TUNE,
        ///0x2e - RWA, External 32KHz oscillator tune control, SAM
        pub xt32k_tune: XT32K_TUNE,
        ///0x2f - RWA, 32KHz oscillator configure
        pub ck32k_config: CK32K_CONFIG,
    }
    ///CLK_SYS_CFG (rw) register accessor: an alias for `Reg<CLK_SYS_CFG_SPEC>`
    pub type CLK_SYS_CFG = crate::Reg<clk_sys_cfg::CLK_SYS_CFG_SPEC>;
    ///RWA, system clock configuration, SAM
    pub mod clk_sys_cfg {
        ///Register `CLK_SYS_CFG` reader
        pub struct R(crate::R<CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CLK_SYS_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CLK_SYS_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CLK_SYS_CFG` writer
        pub struct W(crate::W<CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CLK_SYS_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CLK_SYS_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_R = crate::FieldReader;
        ///Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_W<'a, const O: u8> = crate::FieldWriter<'a, CLK_SYS_CFG_SPEC, 5, O>;
        ///Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz
        pub type CLK_SYS_MOD_R = crate::FieldReader;
        ///Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz
        pub type CLK_SYS_MOD_W<'a, const O: u8> = crate::FieldWriter<'a, CLK_SYS_CFG_SPEC, 2, O>;
        ///Field `XT_32M_PWR_EN` reader - RWA, External 32MHz oscillator HSE power supply control 1: Power on, 0: Power off
        pub type XT_32M_PWR_EN_R = crate::BitReader;
        ///Field `XT_32M_PWR_EN` writer - RWA, External 32MHz oscillator HSE power supply control 1: Power on, 0: Power off
        pub type XT_32M_PWR_EN_W<'a, const O: u8> = crate::BitWriter<'a, CLK_SYS_CFG_SPEC, O>;
        ///Field `XT_FORCE_EN` reader - RWA, Used to control the stop of the clock system in pause mode
        pub type XT_FORCE_EN_R = crate::BitReader;
        ///Field `XT_FORCE_EN` writer - RWA, Used to control the stop of the clock system in pause mode
        pub type XT_FORCE_EN_W<'a, const O: u8> = crate::BitWriter<'a, CLK_SYS_CFG_SPEC, O>;
        ///Field `PLL_PWR_EN` reader - RWA, PLL power control position
        pub type PLL_PWR_EN_R = crate::BitReader;
        ///Field `PLL_PWR_EN` writer - RWA, PLL power control position
        pub type PLL_PWR_EN_W<'a, const O: u8> = crate::BitWriter<'a, CLK_SYS_CFG_SPEC, O>;
        impl R {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            pub fn clk_pll_div(&self) -> CLK_PLL_DIV_R {
                CLK_PLL_DIV_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz
            #[inline(always)]
            pub fn clk_sys_mod(&self) -> CLK_SYS_MOD_R {
                CLK_SYS_MOD_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bit 18 - RWA, External 32MHz oscillator HSE power supply control 1: Power on, 0: Power off
            #[inline(always)]
            pub fn xt_32m_pwr_en(&self) -> XT_32M_PWR_EN_R {
                XT_32M_PWR_EN_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - RWA, Used to control the stop of the clock system in pause mode
            #[inline(always)]
            pub fn xt_force_en(&self) -> XT_FORCE_EN_R {
                XT_FORCE_EN_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - RWA, PLL power control position
            #[inline(always)]
            pub fn pll_pwr_en(&self) -> PLL_PWR_EN_R {
                PLL_PWR_EN_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_div(&mut self) -> CLK_PLL_DIV_W<0> {
                CLK_PLL_DIV_W::new(self)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz
            #[inline(always)]
            #[must_use]
            pub fn clk_sys_mod(&mut self) -> CLK_SYS_MOD_W<6> {
                CLK_SYS_MOD_W::new(self)
            }
            ///Bit 18 - RWA, External 32MHz oscillator HSE power supply control 1: Power on, 0: Power off
            #[inline(always)]
            #[must_use]
            pub fn xt_32m_pwr_en(&mut self) -> XT_32M_PWR_EN_W<18> {
                XT_32M_PWR_EN_W::new(self)
            }
            ///Bit 19 - RWA, Used to control the stop of the clock system in pause mode
            #[inline(always)]
            #[must_use]
            pub fn xt_force_en(&mut self) -> XT_FORCE_EN_W<19> {
                XT_FORCE_EN_W::new(self)
            }
            ///Bit 20 - RWA, PLL power control position
            #[inline(always)]
            #[must_use]
            pub fn pll_pwr_en(&mut self) -> PLL_PWR_EN_W<20> {
                PLL_PWR_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, system clock configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [clk_sys_cfg](index.html) module
        pub struct CLK_SYS_CFG_SPEC;
        impl crate::RegisterSpec for CLK_SYS_CFG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [clk_sys_cfg::R](R) reader structure
        impl crate::Readable for CLK_SYS_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [clk_sys_cfg::W](W) writer structure
        impl crate::Writable for CLK_SYS_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CLK_SYS_CFG to value 0x0014_0005
        impl crate::Resettable for CLK_SYS_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x0014_0005;
        }
    }
    ///SLP_CLK_OFF0 (rw) register accessor: an alias for `Reg<SLP_CLK_OFF0_SPEC>`
    pub type SLP_CLK_OFF0 = crate::Reg<slp_clk_off0::SLP_CLK_OFF0_SPEC>;
    ///RWA, sleep clock off control byte 0, SAM
    pub mod slp_clk_off0 {
        ///Register `SLP_CLK_OFF0` reader
        pub struct R(crate::R<SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_CLK_OFF0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_CLK_OFF0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_CLK_OFF0` writer
        pub struct W(crate::W<SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_CLK_OFF0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_CLK_OFF0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_CLK_TMR0` reader - RWA, Timer 0 clock source
        pub type SLP_CLK_TMR0_R = crate::BitReader;
        ///Field `SLP_CLK_TMR0` writer - RWA, Timer 0 clock source
        pub type SLP_CLK_TMR0_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_TMR1` reader - RWA, Timer 1 clock source
        pub type SLP_CLK_TMR1_R = crate::BitReader;
        ///Field `SLP_CLK_TMR1` writer - RWA, Timer 1 clock source
        pub type SLP_CLK_TMR1_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_TMR2` reader - RWA, Timer 2 clock source
        pub type SLP_CLK_TMR2_R = crate::BitReader;
        ///Field `SLP_CLK_TMR2` writer - RWA, Timer 2 clock source
        pub type SLP_CLK_TMR2_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_TMR3` reader - RWA, Timer 3 clock source
        pub type SLP_CLK_TMR3_R = crate::BitReader;
        ///Field `SLP_CLK_TMR3` writer - RWA, Timer 3 clock source
        pub type SLP_CLK_TMR3_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_UART0` reader - RWA, UART0 clock source
        pub type SLP_CLK_UART0_R = crate::BitReader;
        ///Field `SLP_CLK_UART0` writer - RWA, UART0 clock source
        pub type SLP_CLK_UART0_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_UART1` reader - RWA, UART1 clock source
        pub type SLP_CLK_UART1_R = crate::BitReader;
        ///Field `SLP_CLK_UART1` writer - RWA, UART1 clock source
        pub type SLP_CLK_UART1_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_UART2` reader - RWA, UART2 clock source
        pub type SLP_CLK_UART2_R = crate::BitReader;
        ///Field `SLP_CLK_UART2` writer - RWA, UART2 clock source
        pub type SLP_CLK_UART2_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        ///Field `SLP_CLK_UART3` reader - RWA, UART3 clock source
        pub type SLP_CLK_UART3_R = crate::BitReader;
        ///Field `SLP_CLK_UART3` writer - RWA, UART3 clock source
        pub type SLP_CLK_UART3_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF0_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, Timer 0 clock source
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SLP_CLK_TMR0_R {
                SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, Timer 1 clock source
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SLP_CLK_TMR1_R {
                SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, Timer 2 clock source
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SLP_CLK_TMR2_R {
                SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, Timer 3 clock source
            #[inline(always)]
            pub fn slp_clk_tmr3(&self) -> SLP_CLK_TMR3_R {
                SLP_CLK_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, UART0 clock source
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SLP_CLK_UART0_R {
                SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, UART1 clock source
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SLP_CLK_UART1_R {
                SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, UART2 clock source
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SLP_CLK_UART2_R {
                SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, UART3 clock source
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SLP_CLK_UART3_R {
                SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, Timer 0 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr0(&mut self) -> SLP_CLK_TMR0_W<0> {
                SLP_CLK_TMR0_W::new(self)
            }
            ///Bit 1 - RWA, Timer 1 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr1(&mut self) -> SLP_CLK_TMR1_W<1> {
                SLP_CLK_TMR1_W::new(self)
            }
            ///Bit 2 - RWA, Timer 2 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr2(&mut self) -> SLP_CLK_TMR2_W<2> {
                SLP_CLK_TMR2_W::new(self)
            }
            ///Bit 3 - RWA, Timer 3 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr3(&mut self) -> SLP_CLK_TMR3_W<3> {
                SLP_CLK_TMR3_W::new(self)
            }
            ///Bit 4 - RWA, UART0 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart0(&mut self) -> SLP_CLK_UART0_W<4> {
                SLP_CLK_UART0_W::new(self)
            }
            ///Bit 5 - RWA, UART1 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart1(&mut self) -> SLP_CLK_UART1_W<5> {
                SLP_CLK_UART1_W::new(self)
            }
            ///Bit 6 - RWA, UART2 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart2(&mut self) -> SLP_CLK_UART2_W<6> {
                SLP_CLK_UART2_W::new(self)
            }
            ///Bit 7 - RWA, UART3 clock source
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart3(&mut self) -> SLP_CLK_UART3_W<7> {
                SLP_CLK_UART3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 0, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_clk_off0](index.html) module
        pub struct SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_clk_off0::R](R) reader structure
        impl crate::Readable for SLP_CLK_OFF0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_clk_off0::W](W) writer structure
        impl crate::Writable for SLP_CLK_OFF0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF0 to value 0
        impl crate::Resettable for SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SLP_CLK_OFF1 (rw) register accessor: an alias for `Reg<SLP_CLK_OFF1_SPEC>`
    pub type SLP_CLK_OFF1 = crate::Reg<slp_clk_off1::SLP_CLK_OFF1_SPEC>;
    ///RWA, sleep clock off control byte 1, SAM
    pub mod slp_clk_off1 {
        ///Register `SLP_CLK_OFF1` reader
        pub struct R(crate::R<SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_CLK_OFF1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_CLK_OFF1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_CLK_OFF1` writer
        pub struct W(crate::W<SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_CLK_OFF1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_CLK_OFF1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_R = crate::BitReader;
        ///Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        ///Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_R = crate::BitReader;
        ///Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        ///Field `SLP_CLK_I2C` reader - RWA, close I2C clock
        pub type SLP_CLK_I2C_R = crate::BitReader;
        ///Field `SLP_CLK_I2C` writer - RWA, close I2C clock
        pub type SLP_CLK_I2C_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        ///Field `SLP_CLK_USB` reader - RWA, close USB clock
        pub type SLP_CLK_USB_R = crate::BitReader;
        ///Field `SLP_CLK_USB` writer - RWA, close USB clock
        pub type SLP_CLK_USB_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        ///Field `SLP_CLK_LCD` reader - RWA, close LCD clock
        pub type SLP_CLK_LCD_R = crate::BitReader;
        ///Field `SLP_CLK_LCD` writer - RWA, close LCD clock
        pub type SLP_CLK_LCD_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        ///Field `SLP_CLK_BLE` reader - RWA, close BLE clock
        pub type SLP_CLK_BLE_R = crate::BitReader;
        ///Field `SLP_CLK_BLE` writer - RWA, close BLE clock
        pub type SLP_CLK_BLE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_CLK_OFF1_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SLP_CLK_SPI0_R {
                SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SLP_CLK_PWMX_R {
                SLP_CLK_PWMX_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            pub fn slp_clk_i2c(&self) -> SLP_CLK_I2C_R {
                SLP_CLK_I2C_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            pub fn slp_clk_usb(&self) -> SLP_CLK_USB_R {
                SLP_CLK_USB_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RWA, close LCD clock
            #[inline(always)]
            pub fn slp_clk_lcd(&self) -> SLP_CLK_LCD_R {
                SLP_CLK_LCD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            pub fn slp_clk_ble(&self) -> SLP_CLK_BLE_R {
                SLP_CLK_BLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi0(&mut self) -> SLP_CLK_SPI0_W<0> {
                SLP_CLK_SPI0_W::new(self)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_pwmx(&mut self) -> SLP_CLK_PWMX_W<2> {
                SLP_CLK_PWMX_W::new(self)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_i2c(&mut self) -> SLP_CLK_I2C_W<3> {
                SLP_CLK_I2C_W::new(self)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usb(&mut self) -> SLP_CLK_USB_W<4> {
                SLP_CLK_USB_W::new(self)
            }
            ///Bit 6 - RWA, close LCD clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_lcd(&mut self) -> SLP_CLK_LCD_W<6> {
                SLP_CLK_LCD_W::new(self)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ble(&mut self) -> SLP_CLK_BLE_W<7> {
                SLP_CLK_BLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 1, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_clk_off1](index.html) module
        pub struct SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_clk_off1::R](R) reader structure
        impl crate::Readable for SLP_CLK_OFF1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_clk_off1::W](W) writer structure
        impl crate::Writable for SLP_CLK_OFF1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF1 to value 0
        impl crate::Resettable for SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SLP_WAKE_CTRL (rw) register accessor: an alias for `Reg<SLP_WAKE_CTRL_SPEC>`
    pub type SLP_WAKE_CTRL = crate::Reg<slp_wake_ctrl::SLP_WAKE_CTRL_SPEC>;
    ///RWA, wake control, SAM
    pub mod slp_wake_ctrl {
        ///Register `SLP_WAKE_CTRL` reader
        pub struct R(crate::R<SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_WAKE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_WAKE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_WAKE_CTRL` writer
        pub struct W(crate::W<SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_WAKE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_WAKE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_USB_WAKE` reader - RWA, enable USB waking
        pub type SLP_USB_WAKE_R = crate::BitReader;
        ///Field `SLP_USB_WAKE` writer - RWA, enable USB waking
        pub type SLP_USB_WAKE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        ///Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_R = crate::BitReader;
        ///Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        ///Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_R = crate::BitReader;
        ///Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        ///Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_R = crate::BitReader;
        ///Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        ///Field `WAKE_EV_MODE` reader - RWA, event wakeup mode
        pub type WAKE_EV_MODE_R = crate::BitReader;
        ///Field `WAKE_EV_MODE` writer - RWA, event wakeup mode
        pub type WAKE_EV_MODE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        ///Field `GPIO_WAKE_MODE` reader - RWA, enable GPIO wake-up mode
        pub type GPIO_WAKE_MODE_R = crate::BitReader;
        ///Field `GPIO_WAKE_MODE` writer - RWA, enable GPIO wake-up mode
        pub type GPIO_WAKE_MODE_W<'a, const O: u8> = crate::BitWriter<'a, SLP_WAKE_CTRL_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            pub fn slp_usb_wake(&self) -> SLP_USB_WAKE_R {
                SLP_USB_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            pub fn slp_rtc_wake(&self) -> SLP_RTC_WAKE_R {
                SLP_RTC_WAKE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SLP_GPIO_WAKE_R {
                SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            pub fn slp_bat_wake(&self) -> SLP_BAT_WAKE_R {
                SLP_BAT_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            pub fn wake_ev_mode(&self) -> WAKE_EV_MODE_R {
                WAKE_EV_MODE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable GPIO wake-up mode
            #[inline(always)]
            pub fn gpio_wake_mode(&self) -> GPIO_WAKE_MODE_R {
                GPIO_WAKE_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb_wake(&mut self) -> SLP_USB_WAKE_W<0> {
                SLP_USB_WAKE_W::new(self)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            #[must_use]
            pub fn slp_rtc_wake(&mut self) -> SLP_RTC_WAKE_W<3> {
                SLP_RTC_WAKE_W::new(self)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn slp_gpio_wake(&mut self) -> SLP_GPIO_WAKE_W<4> {
                SLP_GPIO_WAKE_W::new(self)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            #[must_use]
            pub fn slp_bat_wake(&mut self) -> SLP_BAT_WAKE_W<5> {
                SLP_BAT_WAKE_W::new(self)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn wake_ev_mode(&mut self) -> WAKE_EV_MODE_W<6> {
                WAKE_EV_MODE_W::new(self)
            }
            ///Bit 7 - RWA, enable GPIO wake-up mode
            #[inline(always)]
            #[must_use]
            pub fn gpio_wake_mode(&mut self) -> GPIO_WAKE_MODE_W<7> {
                GPIO_WAKE_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, wake control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_wake_ctrl](index.html) module
        pub struct SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_wake_ctrl::R](R) reader structure
        impl crate::Readable for SLP_WAKE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_wake_ctrl::W](W) writer structure
        impl crate::Writable for SLP_WAKE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_WAKE_CTRL to value 0x20
        impl crate::Resettable for SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///SLP_POWER_CTRL (rw) register accessor: an alias for `Reg<SLP_POWER_CTRL_SPEC>`
    pub type SLP_POWER_CTRL = crate::Reg<slp_power_ctrl::SLP_POWER_CTRL_SPEC>;
    ///RWA, peripherals power down control, SAM
    pub mod slp_power_ctrl {
        ///Register `SLP_POWER_CTRL` reader
        pub struct R(crate::R<SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_POWER_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_POWER_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_POWER_CTRL` writer
        pub struct W(crate::W<SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_POWER_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_POWER_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WAKE_DLY_MOD` reader - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_R = crate::FieldReader;
        ///Field `WAKE_DLY_MOD` writer - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, SLP_POWER_CTRL_SPEC, 2, O>;
        ///Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_R = crate::BitReader;
        ///Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_W<'a, const O: u8> = crate::BitWriter<'a, SLP_POWER_CTRL_SPEC, O>;
        ///Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_R = crate::BitReader;
        ///Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_W<'a, const O: u8> = crate::BitWriter<'a, SLP_POWER_CTRL_SPEC, O>;
        ///Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_R = crate::BitReader;
        ///Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_W<'a, const O: u8> = crate::BitWriter<'a, SLP_POWER_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            pub fn wake_dly_mod(&self) -> WAKE_DLY_MOD_R {
                WAKE_DLY_MOD_R::new(self.bits & 3)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            pub fn slp_clk_ramx(&self) -> SLP_CLK_RAMX_R {
                SLP_CLK_RAMX_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            pub fn slp_clk_ram2k(&self) -> SLP_CLK_RAM2K_R {
                SLP_CLK_RAM2K_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            pub fn ram_ret_lv(&self) -> RAM_RET_LV_R {
                RAM_RET_LV_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            #[must_use]
            pub fn wake_dly_mod(&mut self) -> WAKE_DLY_MOD_W<0> {
                WAKE_DLY_MOD_W::new(self)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ramx(&mut self) -> SLP_CLK_RAMX_W<4> {
                SLP_CLK_RAMX_W::new(self)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ram2k(&mut self) -> SLP_CLK_RAM2K_W<5> {
                SLP_CLK_RAM2K_W::new(self)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            #[must_use]
            pub fn ram_ret_lv(&mut self) -> RAM_RET_LV_W<6> {
                RAM_RET_LV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, peripherals power down control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_power_ctrl](index.html) module
        pub struct SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_power_ctrl::R](R) reader structure
        impl crate::Readable for SLP_POWER_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_power_ctrl::W](W) writer structure
        impl crate::Writable for SLP_POWER_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_POWER_CTRL to value 0
        impl crate::Resettable for SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SLEEP_CTRL2 (rw) register accessor: an alias for `Reg<SLEEP_CTRL2_SPEC>`
    pub type SLEEP_CTRL2 = crate::Reg<sleep_ctrl2::SLEEP_CTRL2_SPEC>;
    ///RWA, Sleep control register, SAM
    pub mod sleep_ctrl2 {
        ///Register `SLEEP_CTRL2` reader
        pub struct R(crate::R<SLEEP_CTRL2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLEEP_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLEEP_CTRL2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLEEP_CTRL2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLEEP_CTRL2` writer
        pub struct W(crate::W<SLEEP_CTRL2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLEEP_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLEEP_CTRL2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLEEP_CTRL2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_WAKE_EN_5_0` reader - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button.
        pub type TKEY_WAKE_EN_5_0_R = crate::FieldReader;
        ///Field `TKEY_WAKE_EN_5_0` writer - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button.
        pub type TKEY_WAKE_EN_5_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, SLEEP_CTRL2_SPEC, 6, O>;
        ///Field `TKEY_WAKE_EN_13_8` reader - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button
        pub type TKEY_WAKE_EN_13_8_R = crate::FieldReader;
        ///Field `TKEY_WAKE_EN_13_8` writer - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button
        pub type TKEY_WAKE_EN_13_8_W<'a, const O: u8> =
            crate::FieldWriter<'a, SLEEP_CTRL2_SPEC, 6, O>;
        impl R {
            ///Bits 0:5 - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button.
            #[inline(always)]
            pub fn tkey_wake_en_5_0(&self) -> TKEY_WAKE_EN_5_0_R {
                TKEY_WAKE_EN_5_0_R::new((self.bits & 0x3f) as u8)
            }
            ///Bits 8:13 - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button
            #[inline(always)]
            pub fn tkey_wake_en_13_8(&self) -> TKEY_WAKE_EN_13_8_R {
                TKEY_WAKE_EN_13_8_R::new(((self.bits >> 8) & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button.
            #[inline(always)]
            #[must_use]
            pub fn tkey_wake_en_5_0(&mut self) -> TKEY_WAKE_EN_5_0_W<0> {
                TKEY_WAKE_EN_5_0_W::new(self)
            }
            ///Bits 8:13 - RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit corresponds to a button
            #[inline(always)]
            #[must_use]
            pub fn tkey_wake_en_13_8(&mut self) -> TKEY_WAKE_EN_13_8_W<8> {
                TKEY_WAKE_EN_13_8_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, Sleep control register, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sleep_ctrl2](index.html) module
        pub struct SLEEP_CTRL2_SPEC;
        impl crate::RegisterSpec for SLEEP_CTRL2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sleep_ctrl2::R](R) reader structure
        impl crate::Readable for SLEEP_CTRL2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sleep_ctrl2::W](W) writer structure
        impl crate::Writable for SLEEP_CTRL2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLEEP_CTRL2 to value 0
        impl crate::Resettable for SLEEP_CTRL2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: an alias for `Reg<PIN_ALTERNATE_SPEC>`
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///RW, function pin alternate configuration
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub struct R(crate::R<PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PIN_ALTERNATE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PIN_ALTERNATE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PIN_ALTERNATE` writer
        pub struct W(crate::W<PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PIN_ALTERNATE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PIN_ALTERNATE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_R = crate::BitReader;
        ///Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_R = crate::BitReader;
        ///Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_R = crate::BitReader;
        ///Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_TMR3` reader - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_R = crate::BitReader;
        ///Field `PIN_TMR3` writer - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_R = crate::BitReader;
        ///Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_R = crate::BitReader;
        ///Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_R = crate::BitReader;
        ///Field `PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_R = crate::BitReader;
        ///Field `PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_R = crate::BitReader;
        ///Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_R = crate::BitReader;
        ///Field `PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_I2C` reader - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_R = crate::BitReader;
        ///Field `PIN_I2C` writer - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `PIN_MODEM` reader - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_R = crate::BitReader;
        ///Field `PIN_MODEM` writer - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        ///Field `RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_R = crate::BitReader;
        ///Field `RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ALTERNATE_SPEC, O>;
        impl R {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr0(&self) -> PIN_TMR0_R {
                PIN_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr1(&self) -> PIN_TMR1_R {
                PIN_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr2(&self) -> PIN_TMR2_R {
                PIN_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr3(&self) -> PIN_TMR3_R {
                PIN_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            pub fn pin_uart0(&self) -> PIN_UART0_R {
                PIN_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            pub fn pin_uart1(&self) -> PIN_UART1_R {
                PIN_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            pub fn pin_uart2(&self) -> PIN_UART2_R {
                PIN_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            pub fn pin_uart3(&self) -> PIN_UART3_R {
                PIN_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            pub fn pin_spi0(&self) -> PIN_SPI0_R {
                PIN_SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            pub fn pin_pwmx(&self) -> PIN_PWMX_R {
                PIN_PWMX_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            pub fn pin_i2c(&self) -> PIN_I2C_R {
                PIN_I2C_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            pub fn pin_modem(&self) -> PIN_MODEM_R {
                PIN_MODEM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            pub fn rf_ant_sw_en(&self) -> RF_ANT_SW_EN_R {
                RF_ANT_SW_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr0(&mut self) -> PIN_TMR0_W<0> {
                PIN_TMR0_W::new(self)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr1(&mut self) -> PIN_TMR1_W<1> {
                PIN_TMR1_W::new(self)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr2(&mut self) -> PIN_TMR2_W<2> {
                PIN_TMR2_W::new(self)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr3(&mut self) -> PIN_TMR3_W<3> {
                PIN_TMR3_W::new(self)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart0(&mut self) -> PIN_UART0_W<4> {
                PIN_UART0_W::new(self)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart1(&mut self) -> PIN_UART1_W<5> {
                PIN_UART1_W::new(self)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart2(&mut self) -> PIN_UART2_W<6> {
                PIN_UART2_W::new(self)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart3(&mut self) -> PIN_UART3_W<7> {
                PIN_UART3_W::new(self)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_spi0(&mut self) -> PIN_SPI0_W<8> {
                PIN_SPI0_W::new(self)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pwmx(&mut self) -> PIN_PWMX_W<10> {
                PIN_PWMX_W::new(self)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_i2c(&mut self) -> PIN_I2C_W<11> {
                PIN_I2C_W::new(self)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_modem(&mut self) -> PIN_MODEM_W<12> {
                PIN_MODEM_W::new(self)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            #[must_use]
            pub fn rf_ant_sw_en(&mut self) -> RF_ANT_SW_EN_W<15> {
                RF_ANT_SW_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, function pin alternate configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pin_alternate](index.html) module
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pin_alternate::R](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pin_alternate::W](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PIN_ANALOG_IE (rw) register accessor: an alias for `Reg<PIN_ANALOG_IE_SPEC>`
    pub type PIN_ANALOG_IE = crate::Reg<pin_analog_ie::PIN_ANALOG_IE_SPEC>;
    ///RW, Analog pin enable and digital input disable
    pub mod pin_analog_ie {
        ///Register `PIN_ANALOG_IE` reader
        pub struct R(crate::R<PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PIN_ANALOG_IE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PIN_ANALOG_IE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PIN_ANALOG_IE` writer
        pub struct W(crate::W<PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PIN_ANALOG_IE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PIN_ANALOG_IE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN_USB_DP_PU` reader - RW, USB UD+pin internal pull-up resistor enable
        pub type PIN_USB_DP_PU_R = crate::BitReader;
        ///Field `PIN_USB_DP_PU` writer - RW, USB UD+pin internal pull-up resistor enable
        pub type PIN_USB_DP_PU_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ANALOG_IE_SPEC, O>;
        ///Field `PIN_USB_IE` reader - RW, USB pin enable
        pub type PIN_USB_IE_R = crate::BitReader;
        ///Field `PIN_USB_IE` writer - RW, USB pin enable
        pub type PIN_USB_IE_W<'a, const O: u8> = crate::BitWriter<'a, PIN_ANALOG_IE_SPEC, O>;
        impl R {
            ///Bit 6 - RW, USB UD+pin internal pull-up resistor enable
            #[inline(always)]
            pub fn pin_usb_dp_pu(&self) -> PIN_USB_DP_PU_R {
                PIN_USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, USB pin enable
            #[inline(always)]
            pub fn pin_usb_ie(&self) -> PIN_USB_IE_R {
                PIN_USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 6 - RW, USB UD+pin internal pull-up resistor enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_dp_pu(&mut self) -> PIN_USB_DP_PU_W<6> {
                PIN_USB_DP_PU_W::new(self)
            }
            ///Bit 7 - RW, USB pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_ie(&mut self) -> PIN_USB_IE_W<7> {
                PIN_USB_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Analog pin enable and digital input disable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pin_analog_ie](index.html) module
        pub struct PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pin_analog_ie::R](R) reader structure
        impl crate::Readable for PIN_ANALOG_IE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pin_analog_ie::W](W) writer structure
        impl crate::Writable for PIN_ANALOG_IE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PIN_ANALOG_IE to value 0
        impl crate::Resettable for PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PIN_CONFIG2 (rw) register accessor: an alias for `Reg<PIN_CONFIG2_SPEC>`
    pub type PIN_CONFIG2 = crate::Reg<pin_config2::PIN_CONFIG2_SPEC>;
    ///RW, Pin configuration register 2
    pub mod pin_config2 {
        ///Register `PIN_CONFIG2` reader
        pub struct R(crate::R<PIN_CONFIG2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PIN_CONFIG2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PIN_CONFIG2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PIN_CONFIG2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PIN_CONFIG2` writer
        pub struct W(crate::W<PIN_CONFIG2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PIN_CONFIG2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PIN_CONFIG2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PIN_CONFIG2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN_PA_DIS_4_15` reader - RW, PA4-PA15 channel pin digital input enable
        pub type PIN_PA_DIS_4_15_R = crate::FieldReader<u16>;
        ///Field `PIN_PA_DIS_4_15` writer - RW, PA4-PA15 channel pin digital input enable
        pub type PIN_PA_DIS_4_15_W<'a, const O: u8> =
            crate::FieldWriter<'a, PIN_CONFIG2_SPEC, 12, O, u16>;
        ///Field `PIN_PB_DIS_0` reader - RW, PB0 channel pin digital input enable
        pub type PIN_PB_DIS_0_R = crate::BitReader;
        ///Field `PIN_PB_DIS_0` writer - RW, PB0 channel pin digital input enable
        pub type PIN_PB_DIS_0_W<'a, const O: u8> = crate::BitWriter<'a, PIN_CONFIG2_SPEC, O>;
        ///Field `PIN_PB_DIS_20` reader - RW, PB4 channel pin digital input enable
        pub type PIN_PB_DIS_20_R = crate::BitReader;
        ///Field `PIN_PB_DIS_20` writer - RW, PB4 channel pin digital input enable
        pub type PIN_PB_DIS_20_W<'a, const O: u8> = crate::BitWriter<'a, PIN_CONFIG2_SPEC, O>;
        ///Field `PIN_PB_DIS_6_7` reader - RW, PB6-PB7 channel pin digital input enable
        pub type PIN_PB_DIS_6_7_R = crate::FieldReader;
        ///Field `PIN_PB_DIS_6_7` writer - RW, PB6-PB7 channel pin digital input enable
        pub type PIN_PB_DIS_6_7_W<'a, const O: u8> = crate::FieldWriter<'a, PIN_CONFIG2_SPEC, 2, O>;
        ///Field `PIN_PB_DIS_8_9` reader - RW, PB22-PB23 channel pin digital input enable
        pub type PIN_PB_DIS_8_9_R = crate::FieldReader;
        ///Field `PIN_PB_DIS_8_9` writer - RW, PB22-PB23 channel pin digital input enable
        pub type PIN_PB_DIS_8_9_W<'a, const O: u8> = crate::FieldWriter<'a, PIN_CONFIG2_SPEC, 2, O>;
        ///Field `PIN_PB_DIS_10_15` reader - RW, PB10-PB15 channel pin digital input enable
        pub type PIN_PB_DIS_10_15_R = crate::FieldReader;
        ///Field `PIN_PB_DIS_10_15` writer - RW, PB10-PB15 channel pin digital input enable
        pub type PIN_PB_DIS_10_15_W<'a, const O: u8> =
            crate::FieldWriter<'a, PIN_CONFIG2_SPEC, 6, O>;
        impl R {
            ///Bits 4:15 - RW, PA4-PA15 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pa_dis_4_15(&self) -> PIN_PA_DIS_4_15_R {
                PIN_PA_DIS_4_15_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
            ///Bit 16 - RW, PB0 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pb_dis_0(&self) -> PIN_PB_DIS_0_R {
                PIN_PB_DIS_0_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 20 - RW, PB4 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pb_dis_20(&self) -> PIN_PB_DIS_20_R {
                PIN_PB_DIS_20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bits 22:23 - RW, PB6-PB7 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pb_dis_6_7(&self) -> PIN_PB_DIS_6_7_R {
                PIN_PB_DIS_6_7_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - RW, PB22-PB23 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pb_dis_8_9(&self) -> PIN_PB_DIS_8_9_R {
                PIN_PB_DIS_8_9_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:31 - RW, PB10-PB15 channel pin digital input enable
            #[inline(always)]
            pub fn pin_pb_dis_10_15(&self) -> PIN_PB_DIS_10_15_R {
                PIN_PB_DIS_10_15_R::new(((self.bits >> 26) & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 4:15 - RW, PA4-PA15 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pa_dis_4_15(&mut self) -> PIN_PA_DIS_4_15_W<4> {
                PIN_PA_DIS_4_15_W::new(self)
            }
            ///Bit 16 - RW, PB0 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pb_dis_0(&mut self) -> PIN_PB_DIS_0_W<16> {
                PIN_PB_DIS_0_W::new(self)
            }
            ///Bit 20 - RW, PB4 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pb_dis_20(&mut self) -> PIN_PB_DIS_20_W<20> {
                PIN_PB_DIS_20_W::new(self)
            }
            ///Bits 22:23 - RW, PB6-PB7 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pb_dis_6_7(&mut self) -> PIN_PB_DIS_6_7_W<22> {
                PIN_PB_DIS_6_7_W::new(self)
            }
            ///Bits 24:25 - RW, PB22-PB23 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pb_dis_8_9(&mut self) -> PIN_PB_DIS_8_9_W<24> {
                PIN_PB_DIS_8_9_W::new(self)
            }
            ///Bits 26:31 - RW, PB10-PB15 channel pin digital input enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pb_dis_10_15(&mut self) -> PIN_PB_DIS_10_15_W<26> {
                PIN_PB_DIS_10_15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Pin configuration register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pin_config2](index.html) module
        pub struct PIN_CONFIG2_SPEC;
        impl crate::RegisterSpec for PIN_CONFIG2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pin_config2::R](R) reader structure
        impl crate::Readable for PIN_CONFIG2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pin_config2::W](W) writer structure
        impl crate::Writable for PIN_CONFIG2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PIN_CONFIG2 to value 0
        impl crate::Resettable for PIN_CONFIG2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///POWER_PLAN (rw) register accessor: an alias for `Reg<POWER_PLAN_SPEC>`
    pub type POWER_PLAN = crate::Reg<power_plan::POWER_PLAN_SPEC>;
    ///RWA, power plan before sleep instruction, SAM
    pub mod power_plan {
        ///Register `POWER_PLAN` reader
        pub struct R(crate::R<POWER_PLAN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<POWER_PLAN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<POWER_PLAN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `POWER_PLAN` writer
        pub struct W(crate::W<POWER_PLAN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<POWER_PLAN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<POWER_PLAN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWR_XROM` reader - RWA, power for FlashROM
        pub type PWR_XROM_R = crate::BitReader;
        ///Field `PWR_XROM` writer - RWA, power for FlashROM
        pub type PWR_XROM_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_RAM2K` reader - RWA, SRAM power supply for RAM2K
        pub type PWR_RAM2K_R = crate::BitReader;
        ///Field `PWR_RAM2K` writer - RWA, SRAM power supply for RAM2K
        pub type PWR_RAM2K_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_CORE` reader - RWA, power retention for core and base peripherals
        pub type PWR_CORE_R = crate::BitReader;
        ///Field `PWR_CORE` writer - RWA, power retention for core and base peripherals
        pub type PWR_CORE_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_R = crate::BitReader;
        ///Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_RAM24K` reader - RWA, SRAM power supply for RAM24K
        pub type PWR_RAM24K_R = crate::BitReader;
        ///Field `PWR_RAM24K` writer - RWA, SRAM power supply for RAM24K
        pub type PWR_RAM24K_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `MAIN_ACT` reader - RWA, Main power selection
        pub type MAIN_ACT_R = crate::BitReader;
        ///Field `MAIN_ACT` writer - RWA, Main power selection
        pub type MAIN_ACT_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_SYS_EN` reader - RWA, power for system
        pub type PWR_SYS_EN_R = crate::BitReader;
        ///Field `PWR_SYS_EN` writer - RWA, power for system
        pub type PWR_SYS_EN_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_LDO_EN` reader - RWA, Internal LDO control
        pub type PWR_LDO_EN_R = crate::BitReader;
        ///Field `PWR_LDO_EN` writer - RWA, Internal LDO control
        pub type PWR_LDO_EN_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable
        pub type PWR_DCDC_EN_R = crate::BitReader;
        ///Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable
        pub type PWR_DCDC_EN_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_R = crate::BitReader;
        ///Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        ///Field `PWR_PLAN_EN` reader - RWA, must write 0010
        pub type PWR_PLAN_EN_R = crate::BitReader;
        ///Field `PWR_PLAN_EN` writer - RWA, must write 0010
        pub type PWR_PLAN_EN_W<'a, const O: u8> = crate::BitWriter<'a, POWER_PLAN_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, power for FlashROM
            #[inline(always)]
            pub fn pwr_xrom(&self) -> PWR_XROM_R {
                PWR_XROM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, SRAM power supply for RAM2K
            #[inline(always)]
            pub fn pwr_ram2k(&self) -> PWR_RAM2K_R {
                PWR_RAM2K_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            pub fn pwr_core(&self) -> PWR_CORE_R {
                PWR_CORE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            pub fn pwr_extend(&self) -> PWR_EXTEND_R {
                PWR_EXTEND_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, SRAM power supply for RAM24K
            #[inline(always)]
            pub fn pwr_ram24k(&self) -> PWR_RAM24K_R {
                PWR_RAM24K_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RWA, Main power selection
            #[inline(always)]
            pub fn main_act(&self) -> MAIN_ACT_R {
                MAIN_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            pub fn pwr_sys_en(&self) -> PWR_SYS_EN_R {
                PWR_SYS_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RWA, Internal LDO control
            #[inline(always)]
            pub fn pwr_ldo_en(&self) -> PWR_LDO_EN_R {
                PWR_LDO_EN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RWA, DC/DC converter enable
            #[inline(always)]
            pub fn pwr_dcdc_en(&self) -> PWR_DCDC_EN_R {
                PWR_DCDC_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            pub fn pwr_dcdc_pre(&self) -> PWR_DCDC_PRE_R {
                PWR_DCDC_PRE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            pub fn pwr_plan_en(&self) -> PWR_PLAN_EN_R {
                PWR_PLAN_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, power for FlashROM
            #[inline(always)]
            #[must_use]
            pub fn pwr_xrom(&mut self) -> PWR_XROM_W<0> {
                PWR_XROM_W::new(self)
            }
            ///Bit 1 - RWA, SRAM power supply for RAM2K
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram2k(&mut self) -> PWR_RAM2K_W<1> {
                PWR_RAM2K_W::new(self)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            #[must_use]
            pub fn pwr_core(&mut self) -> PWR_CORE_W<2> {
                PWR_CORE_W::new(self)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            #[must_use]
            pub fn pwr_extend(&mut self) -> PWR_EXTEND_W<3> {
                PWR_EXTEND_W::new(self)
            }
            ///Bit 4 - RWA, SRAM power supply for RAM24K
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram24k(&mut self) -> PWR_RAM24K_W<4> {
                PWR_RAM24K_W::new(self)
            }
            ///Bit 6 - RWA, Main power selection
            #[inline(always)]
            #[must_use]
            pub fn main_act(&mut self) -> MAIN_ACT_W<6> {
                MAIN_ACT_W::new(self)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            #[must_use]
            pub fn pwr_sys_en(&mut self) -> PWR_SYS_EN_W<7> {
                PWR_SYS_EN_W::new(self)
            }
            ///Bit 8 - RWA, Internal LDO control
            #[inline(always)]
            #[must_use]
            pub fn pwr_ldo_en(&mut self) -> PWR_LDO_EN_W<8> {
                PWR_LDO_EN_W::new(self)
            }
            ///Bit 9 - RWA, DC/DC converter enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_en(&mut self) -> PWR_DCDC_EN_W<9> {
                PWR_DCDC_EN_W::new(self)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_pre(&mut self) -> PWR_DCDC_PRE_W<10> {
                PWR_DCDC_PRE_W::new(self)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            #[must_use]
            pub fn pwr_plan_en(&mut self) -> PWR_PLAN_EN_W<15> {
                PWR_PLAN_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, power plan before sleep instruction, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [power_plan](index.html) module
        pub struct POWER_PLAN_SPEC;
        impl crate::RegisterSpec for POWER_PLAN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [power_plan::R](R) reader structure
        impl crate::Readable for POWER_PLAN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [power_plan::W](W) writer structure
        impl crate::Writable for POWER_PLAN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets POWER_PLAN to value 0x31df
        impl crate::Resettable for POWER_PLAN_SPEC {
            const RESET_VALUE: Self::Ux = 0x31df;
        }
    }
    ///AUX_POWER_ADJ (rw) register accessor: an alias for `Reg<AUX_POWER_ADJ_SPEC>`
    pub type AUX_POWER_ADJ = crate::Reg<aux_power_adj::AUX_POWER_ADJ_SPEC>;
    ///RWA, aux power adjust control, SAM
    pub mod aux_power_adj {
        ///Register `AUX_POWER_ADJ` reader
        pub struct R(crate::R<AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AUX_POWER_ADJ_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AUX_POWER_ADJ_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AUX_POWER_ADJ` writer
        pub struct W(crate::W<AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AUX_POWER_ADJ_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AUX_POWER_ADJ_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ULPLDO_ADJ` reader - RWA, Output voltage regulation value of auxiliary power supply for ultra-low power consumption LDO
        pub type ULPLDO_ADJ_R = crate::FieldReader;
        ///Field `ULPLDO_ADJ` writer - RWA, Output voltage regulation value of auxiliary power supply for ultra-low power consumption LDO
        pub type ULPLDO_ADJ_W<'a, const O: u8> = crate::FieldWriter<'a, AUX_POWER_ADJ_SPEC, 3, O>;
        ///Field `DCDC_CHARGE` reader - RWA, Low power auxiliary DC-DC enable bit
        pub type DCDC_CHARGE_R = crate::BitReader;
        ///Field `DCDC_CHARGE` writer - RWA, Low power auxiliary DC-DC enable bit
        pub type DCDC_CHARGE_W<'a, const O: u8> = crate::BitWriter<'a, AUX_POWER_ADJ_SPEC, O>;
        ///Field `CFG_IVREF` reader - RWA, retain. The original value must be kept unchanged when writing
        pub type CFG_IVREF_R = crate::FieldReader;
        ///Field `CFG_IVREF` writer - RWA, retain. The original value must be kept unchanged when writing
        pub type CFG_IVREF_W<'a, const O: u8> = crate::FieldWriter<'a, AUX_POWER_ADJ_SPEC, 4, O>;
        ///Field `IB_TKEY_SEL` reader - RWA, TouchKey bias current, used to stabilize I/O potential and prevent accidental wake-up
        pub type IB_TKEY_SEL_R = crate::FieldReader;
        ///Field `IB_TKEY_SEL` writer - RWA, TouchKey bias current, used to stabilize I/O potential and prevent accidental wake-up
        pub type IB_TKEY_SEL_W<'a, const O: u8> = crate::FieldWriter<'a, AUX_POWER_ADJ_SPEC, 2, O>;
        impl R {
            ///Bits 0:2 - RWA, Output voltage regulation value of auxiliary power supply for ultra-low power consumption LDO
            #[inline(always)]
            pub fn ulpldo_adj(&self) -> ULPLDO_ADJ_R {
                ULPLDO_ADJ_R::new((self.bits & 7) as u8)
            }
            ///Bit 7 - RWA, Low power auxiliary DC-DC enable bit
            #[inline(always)]
            pub fn dcdc_charge(&self) -> DCDC_CHARGE_R {
                DCDC_CHARGE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - RWA, retain. The original value must be kept unchanged when writing
            #[inline(always)]
            pub fn cfg_ivref(&self) -> CFG_IVREF_R {
                CFG_IVREF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 14:15 - RWA, TouchKey bias current, used to stabilize I/O potential and prevent accidental wake-up
            #[inline(always)]
            pub fn ib_tkey_sel(&self) -> IB_TKEY_SEL_R {
                IB_TKEY_SEL_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, Output voltage regulation value of auxiliary power supply for ultra-low power consumption LDO
            #[inline(always)]
            #[must_use]
            pub fn ulpldo_adj(&mut self) -> ULPLDO_ADJ_W<0> {
                ULPLDO_ADJ_W::new(self)
            }
            ///Bit 7 - RWA, Low power auxiliary DC-DC enable bit
            #[inline(always)]
            #[must_use]
            pub fn dcdc_charge(&mut self) -> DCDC_CHARGE_W<7> {
                DCDC_CHARGE_W::new(self)
            }
            ///Bits 8:11 - RWA, retain. The original value must be kept unchanged when writing
            #[inline(always)]
            #[must_use]
            pub fn cfg_ivref(&mut self) -> CFG_IVREF_W<8> {
                CFG_IVREF_W::new(self)
            }
            ///Bits 14:15 - RWA, TouchKey bias current, used to stabilize I/O potential and prevent accidental wake-up
            #[inline(always)]
            #[must_use]
            pub fn ib_tkey_sel(&mut self) -> IB_TKEY_SEL_W<14> {
                IB_TKEY_SEL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, aux power adjust control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [aux_power_adj](index.html) module
        pub struct AUX_POWER_ADJ_SPEC;
        impl crate::RegisterSpec for AUX_POWER_ADJ_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [aux_power_adj::R](R) reader structure
        impl crate::Readable for AUX_POWER_ADJ_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [aux_power_adj::W](W) writer structure
        impl crate::Writable for AUX_POWER_ADJ_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AUX_POWER_ADJ to value 0
        impl crate::Resettable for AUX_POWER_ADJ_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BAT_DET_CTRL (rw) register accessor: an alias for `Reg<BAT_DET_CTRL_SPEC>`
    pub type BAT_DET_CTRL = crate::Reg<bat_det_ctrl::BAT_DET_CTRL_SPEC>;
    ///RWA, battery voltage detector control, SAM
    pub mod bat_det_ctrl {
        ///Register `BAT_DET_CTRL` reader
        pub struct R(crate::R<BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_DET_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_DET_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BAT_DET_CTRL` writer
        pub struct W(crate::W<BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BAT_DET_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BAT_DET_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BAT_DET_EN` reader - RWA, When RB_BAT_MON_EN=0, it is enabled by high-precision battery voltage detection function
        pub type BAT_DET_EN_R = crate::BitReader;
        ///Field `BAT_DET_EN` writer - RWA, When RB_BAT_MON_EN=0, it is enabled by high-precision battery voltage detection function
        pub type BAT_DET_EN_W<'a, const O: u8> = crate::BitWriter<'a, BAT_DET_CTRL_SPEC, O>;
        ///Field `BAT_LOW_VTHX` reader - RWA, When RB_BAT_MON_EN=1, set low power consumption
        pub type BAT_LOW_VTHX_R = crate::BitReader;
        ///Field `BAT_LOW_VTHX` writer - RWA, When RB_BAT_MON_EN=1, set low power consumption
        pub type BAT_LOW_VTHX_W<'a, const O: u8> = crate::BitWriter<'a, BAT_DET_CTRL_SPEC, O>;
        ///Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_R = crate::BitReader;
        ///Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_W<'a, const O: u8> = crate::BitWriter<'a, BAT_DET_CTRL_SPEC, O>;
        ///Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_R = crate::BitReader;
        ///Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_W<'a, const O: u8> = crate::BitWriter<'a, BAT_DET_CTRL_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, When RB_BAT_MON_EN=0, it is enabled by high-precision battery voltage detection function
            #[inline(always)]
            pub fn bat_det_en(&self) -> BAT_DET_EN_R {
                BAT_DET_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, When RB_BAT_MON_EN=1, set low power consumption
            #[inline(always)]
            pub fn bat_low_vthx(&self) -> BAT_LOW_VTHX_R {
                BAT_LOW_VTHX_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            pub fn bat_lower_ie(&self) -> BAT_LOWER_IE_R {
                BAT_LOWER_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            pub fn bat_low_ie(&self) -> BAT_LOW_IE_R {
                BAT_LOW_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, When RB_BAT_MON_EN=0, it is enabled by high-precision battery voltage detection function
            #[inline(always)]
            #[must_use]
            pub fn bat_det_en(&mut self) -> BAT_DET_EN_W<0> {
                BAT_DET_EN_W::new(self)
            }
            ///Bit 1 - RWA, When RB_BAT_MON_EN=1, set low power consumption
            #[inline(always)]
            #[must_use]
            pub fn bat_low_vthx(&mut self) -> BAT_LOW_VTHX_W<1> {
                BAT_LOW_VTHX_W::new(self)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_lower_ie(&mut self) -> BAT_LOWER_IE_W<2> {
                BAT_LOWER_IE_W::new(self)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_low_ie(&mut self) -> BAT_LOW_IE_W<3> {
                BAT_LOW_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_det_ctrl](index.html) module
        pub struct BAT_DET_CTRL_SPEC;
        impl crate::RegisterSpec for BAT_DET_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_det_ctrl::R](R) reader structure
        impl crate::Readable for BAT_DET_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bat_det_ctrl::W](W) writer structure
        impl crate::Writable for BAT_DET_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BAT_DET_CTRL to value 0
        impl crate::Resettable for BAT_DET_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BAT_DET_CFG (rw) register accessor: an alias for `Reg<BAT_DET_CFG_SPEC>`
    pub type BAT_DET_CFG = crate::Reg<bat_det_cfg::BAT_DET_CFG_SPEC>;
    ///RWA, battery voltage detector configuration, SAM
    pub mod bat_det_cfg {
        ///Register `BAT_DET_CFG` reader
        pub struct R(crate::R<BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_DET_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_DET_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BAT_DET_CFG` writer
        pub struct W(crate::W<BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BAT_DET_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BAT_DET_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_R = crate::FieldReader;
        ///Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_W<'a, const O: u8> = crate::FieldWriter<'a, BAT_DET_CFG_SPEC, 2, O>;
        impl R {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            pub fn bat_low_vth(&self) -> BAT_LOW_VTH_R {
                BAT_LOW_VTH_R::new(self.bits & 3)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            #[must_use]
            pub fn bat_low_vth(&mut self) -> BAT_LOW_VTH_W<0> {
                BAT_LOW_VTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_det_cfg](index.html) module
        pub struct BAT_DET_CFG_SPEC;
        impl crate::RegisterSpec for BAT_DET_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_det_cfg::R](R) reader structure
        impl crate::Readable for BAT_DET_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bat_det_cfg::W](W) writer structure
        impl crate::Writable for BAT_DET_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BAT_DET_CFG to value 0x02
        impl crate::Resettable for BAT_DET_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///BAT_STATUS (r) register accessor: an alias for `Reg<BAT_STATUS_SPEC>`
    pub type BAT_STATUS = crate::Reg<bat_status::BAT_STATUS_SPEC>;
    ///RO, battery status
    pub mod bat_status {
        ///Register `BAT_STATUS` reader
        pub struct R(crate::R<BAT_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action
        pub type BAT_STAT_LOWER_R = crate::BitReader;
        ///Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action
        pub type BAT_STAT_LOW_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, battery lower voltage status, high action
            #[inline(always)]
            pub fn bat_stat_lower(&self) -> BAT_STAT_LOWER_R {
                BAT_STAT_LOWER_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, battery low voltage status, high action
            #[inline(always)]
            pub fn bat_stat_low(&self) -> BAT_STAT_LOW_R {
                BAT_STAT_LOW_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///RO, battery status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_status](index.html) module
        pub struct BAT_STATUS_SPEC;
        impl crate::RegisterSpec for BAT_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_status::R](R) reader structure
        impl crate::Readable for BAT_STATUS_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets BAT_STATUS to value 0
        impl crate::Resettable for BAT_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INT32K_TUNE (rw) register accessor: an alias for `Reg<INT32K_TUNE_SPEC>`
    pub type INT32K_TUNE = crate::Reg<int32k_tune::INT32K_TUNE_SPEC>;
    ///RWA, internal 32KHz oscillator tune control, SAM
    pub mod int32k_tune {
        ///Register `INT32K_TUNE` reader
        pub struct R(crate::R<INT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INT32K_TUNE` writer
        pub struct W(crate::W<INT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_R = crate::FieldReader<u16>;
        ///Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_W<'a, const O: u8> =
            crate::FieldWriter<'a, INT32K_TUNE_SPEC, 13, O, u16>;
        impl R {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            pub fn int32k_tune(&self) -> INT32K_TUNE_R {
                INT32K_TUNE_R::new(self.bits & 0x1fff)
            }
        }
        impl W {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            #[must_use]
            pub fn int32k_tune(&mut self) -> INT32K_TUNE_W<0> {
                INT32K_TUNE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, internal 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [int32k_tune](index.html) module
        pub struct INT32K_TUNE_SPEC;
        impl crate::RegisterSpec for INT32K_TUNE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [int32k_tune::R](R) reader structure
        impl crate::Readable for INT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [int32k_tune::W](W) writer structure
        impl crate::Writable for INT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INT32K_TUNE to value 0x1011
        impl crate::Resettable for INT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x1011;
        }
    }
    ///XT32K_TUNE (rw) register accessor: an alias for `Reg<XT32K_TUNE_SPEC>`
    pub type XT32K_TUNE = crate::Reg<xt32k_tune::XT32K_TUNE_SPEC>;
    ///RWA, External 32KHz oscillator tune control, SAM
    pub mod xt32k_tune {
        ///Register `XT32K_TUNE` reader
        pub struct R(crate::R<XT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<XT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<XT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `XT32K_TUNE` writer
        pub struct W(crate::W<XT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<XT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<XT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `XT32K_I_TUNE` reader - RWA, External 32KHz oscillator bias current selection
        pub type XT32K_I_TUNE_R = crate::FieldReader;
        ///Field `XT32K_I_TUNE` writer - RWA, External 32KHz oscillator bias current selection
        pub type XT32K_I_TUNE_W<'a, const O: u8> = crate::FieldWriter<'a, XT32K_TUNE_SPEC, 2, O>;
        ///Field `XT32K_C_LOAD` reader - RWA, External 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_R = crate::FieldReader;
        ///Field `XT32K_C_LOAD` writer - RWA, External 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_W<'a, const O: u8> = crate::FieldWriter<'a, XT32K_TUNE_SPEC, 4, O>;
        impl R {
            ///Bits 0:1 - RWA, External 32KHz oscillator bias current selection
            #[inline(always)]
            pub fn xt32k_i_tune(&self) -> XT32K_I_TUNE_R {
                XT32K_I_TUNE_R::new(self.bits & 3)
            }
            ///Bits 4:7 - RWA, External 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            pub fn xt32k_c_load(&self) -> XT32K_C_LOAD_R {
                XT32K_C_LOAD_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, External 32KHz oscillator bias current selection
            #[inline(always)]
            #[must_use]
            pub fn xt32k_i_tune(&mut self) -> XT32K_I_TUNE_W<0> {
                XT32K_I_TUNE_W::new(self)
            }
            ///Bits 4:7 - RWA, External 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            #[must_use]
            pub fn xt32k_c_load(&mut self) -> XT32K_C_LOAD_W<4> {
                XT32K_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, External 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [xt32k_tune](index.html) module
        pub struct XT32K_TUNE_SPEC;
        impl crate::RegisterSpec for XT32K_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [xt32k_tune::R](R) reader structure
        impl crate::Readable for XT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [xt32k_tune::W](W) writer structure
        impl crate::Writable for XT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets XT32K_TUNE to value 0xc3
        impl crate::Resettable for XT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0xc3;
        }
    }
    ///CK32K_CONFIG (rw) register accessor: an alias for `Reg<CK32K_CONFIG_SPEC>`
    pub type CK32K_CONFIG = crate::Reg<ck32k_config::CK32K_CONFIG_SPEC>;
    ///RWA, 32KHz oscillator configure
    pub mod ck32k_config {
        ///Register `CK32K_CONFIG` reader
        pub struct R(crate::R<CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CK32K_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CK32K_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CK32K_CONFIG` writer
        pub struct W(crate::W<CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CK32K_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CK32K_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_R = crate::BitReader;
        ///Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_W<'a, const O: u8> = crate::BitWriter<'a, CK32K_CONFIG_SPEC, O>;
        ///Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_R = crate::BitReader;
        ///Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_W<'a, const O: u8> = crate::BitWriter<'a, CK32K_CONFIG_SPEC, O>;
        ///Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_R = crate::BitReader;
        ///Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_W<'a, const O: u8> = crate::BitWriter<'a, CK32K_CONFIG_SPEC, O>;
        ///Field `CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_R = crate::BitReader;
        ///Field `CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_W<'a, const O: u8> = crate::BitWriter<'a, CK32K_CONFIG_SPEC, O>;
        ///Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status
        pub type CLK_32K_PIN_R = crate::BitReader;
        ///Field `CLK_32K_PIN` writer - RO, 32KHz oscillator clock pin status
        pub type CLK_32K_PIN_W<'a, const O: u8> = crate::BitWriter<'a, CK32K_CONFIG_SPEC, O>;
        impl R {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_xt32k_pon(&self) -> CLK_XT32K_PON_R {
                CLK_XT32K_PON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_int32k_pon(&self) -> CLK_INT32K_PON_R {
                CLK_INT32K_PON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            pub fn clk_osc32k_xt(&self) -> CLK_OSC32K_XT_R {
                CLK_OSC32K_XT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            pub fn clk_osc32k_filt(&self) -> CLK_OSC32K_FILT_R {
                CLK_OSC32K_FILT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            pub fn clk_32k_pin(&self) -> CLK_32K_PIN_R {
                CLK_32K_PIN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32k_pon(&mut self) -> CLK_XT32K_PON_W<0> {
                CLK_XT32K_PON_W::new(self)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_int32k_pon(&mut self) -> CLK_INT32K_PON_W<1> {
                CLK_INT32K_PON_W::new(self)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_xt(&mut self) -> CLK_OSC32K_XT_W<2> {
                CLK_OSC32K_XT_W::new(self)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_filt(&mut self) -> CLK_OSC32K_FILT_W<3> {
                CLK_OSC32K_FILT_W::new(self)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            #[must_use]
            pub fn clk_32k_pin(&mut self) -> CLK_32K_PIN_W<7> {
                CLK_32K_PIN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, 32KHz oscillator configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ck32k_config](index.html) module
        pub struct CK32K_CONFIG_SPEC;
        impl crate::RegisterSpec for CK32K_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ck32k_config::R](R) reader structure
        impl crate::Readable for CK32K_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ck32k_config::W](W) writer structure
        impl crate::Writable for CK32K_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CK32K_CONFIG to value 0x02
        impl crate::Resettable for CK32K_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
}
///Real time clock
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    ///Pointer to the register block
    pub const PTR: *const rtc::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///Real time clock
pub mod rtc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x30],
        ///0x30 - RWA, Real time clock
        pub flag_ctrl: FLAG_CTRL,
        ///0x31 - RWA, RTC mode control, SAM
        pub mode_ctrl: MODE_CTRL,
        _reserved2: [u8; 0x02],
        ///0x34 - RWA, RTC trigger value, SAM
        pub trig: TRIG,
        ///0x38 - RO, RTC count based 32KHz
        pub cnt_32k: CNT_32K,
        ///0x3a - RO, RTC count based 2 second
        pub cnt_2s: CNT_2S,
        ///0x3c - RO, RTC count based one day, only low 14 bit
        pub cnt_day: CNT_DAY,
    }
    ///FLAG_CTRL (rw) register accessor: an alias for `Reg<FLAG_CTRL_SPEC>`
    pub type FLAG_CTRL = crate::Reg<flag_ctrl::FLAG_CTRL_SPEC>;
    ///RWA, Real time clock
    pub mod flag_ctrl {
        ///Register `FLAG_CTRL` reader
        pub struct R(crate::R<FLAG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FLAG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FLAG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FLAG_CTRL` writer
        pub struct W(crate::W<FLAG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FLAG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FLAG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear
        pub type TMR_CLR_R = crate::BitReader;
        ///Field `TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear
        pub type TMR_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FLAG_CTRL_SPEC, O>;
        ///Field `TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type TRIG_CLR_R = crate::BitReader;
        ///Field `TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type TRIG_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FLAG_CTRL_SPEC, O>;
        ///Field `TMR_FLAG` reader - RO, RTC timer action flag
        pub type TMR_FLAG_R = crate::BitReader;
        ///Field `TRIG_FLAG` reader - RO, RTC trigger action flag
        pub type TRIG_FLAG_R = crate::BitReader;
        impl R {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            pub fn tmr_clr(&self) -> TMR_CLR_R {
                TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            pub fn trig_clr(&self) -> TRIG_CLR_R {
                TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, RTC timer action flag
            #[inline(always)]
            pub fn tmr_flag(&self) -> TMR_FLAG_R {
                TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, RTC trigger action flag
            #[inline(always)]
            pub fn trig_flag(&self) -> TRIG_FLAG_R {
                TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn tmr_clr(&mut self) -> TMR_CLR_W<4> {
                TMR_CLR_W::new(self)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn trig_clr(&mut self) -> TRIG_CLR_W<5> {
                TRIG_CLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, Real time clock
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [flag_ctrl](index.html) module
        pub struct FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [flag_ctrl::R](R) reader structure
        impl crate::Readable for FLAG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [flag_ctrl::W](W) writer structure
        impl crate::Writable for FLAG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FLAG_CTRL to value 0x30
        impl crate::Resettable for FLAG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x30;
        }
    }
    ///MODE_CTRL (rw) register accessor: an alias for `Reg<MODE_CTRL_SPEC>`
    pub type MODE_CTRL = crate::Reg<mode_ctrl::MODE_CTRL_SPEC>;
    ///RWA, RTC mode control, SAM
    pub mod mode_ctrl {
        ///Register `MODE_CTRL` reader
        pub struct R(crate::R<MODE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MODE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MODE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MODE_CTRL` writer
        pub struct W(crate::W<MODE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MODE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MODE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type TMR_MODE_R = crate::FieldReader;
        ///Field `TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type TMR_MODE_W<'a, const O: u8> = crate::FieldWriter<'a, MODE_CTRL_SPEC, 3, O>;
        ///Field `IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type IGNORE_B0_R = crate::BitReader;
        ///Field `IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type IGNORE_B0_W<'a, const O: u8> = crate::BitWriter<'a, MODE_CTRL_SPEC, O>;
        ///Field `TMR_EN` reader - RWA, RTC timer mode enable
        pub type TMR_EN_R = crate::BitReader;
        ///Field `TMR_EN` writer - RWA, RTC timer mode enable
        pub type TMR_EN_W<'a, const O: u8> = crate::BitWriter<'a, MODE_CTRL_SPEC, O>;
        ///Field `TRIG_EN` reader - RWA, RTC trigger mode enable
        pub type TRIG_EN_R = crate::BitReader;
        ///Field `TRIG_EN` writer - RWA, RTC trigger mode enable
        pub type TRIG_EN_W<'a, const O: u8> = crate::BitWriter<'a, MODE_CTRL_SPEC, O>;
        ///Field `LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type LOAD_LO_R = crate::BitReader;
        ///Field `LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type LOAD_LO_W<'a, const O: u8> = crate::BitWriter<'a, MODE_CTRL_SPEC, O>;
        ///Field `LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type LOAD_HI_R = crate::BitReader;
        ///Field `LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type LOAD_HI_W<'a, const O: u8> = crate::BitWriter<'a, MODE_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            pub fn tmr_mode(&self) -> TMR_MODE_R {
                TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            pub fn ignore_b0(&self) -> IGNORE_B0_R {
                IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            pub fn tmr_en(&self) -> TMR_EN_R {
                TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            pub fn trig_en(&self) -> TRIG_EN_R {
                TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            pub fn load_lo(&self) -> LOAD_LO_R {
                LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            pub fn load_hi(&self) -> LOAD_HI_R {
                LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode(&mut self) -> TMR_MODE_W<0> {
                TMR_MODE_W::new(self)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            #[must_use]
            pub fn ignore_b0(&mut self) -> IGNORE_B0_W<3> {
                IGNORE_B0_W::new(self)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_en(&mut self) -> TMR_EN_W<4> {
                TMR_EN_W::new(self)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            #[must_use]
            pub fn trig_en(&mut self) -> TRIG_EN_W<5> {
                TRIG_EN_W::new(self)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn load_lo(&mut self) -> LOAD_LO_W<6> {
                LOAD_LO_W::new(self)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn load_hi(&mut self) -> LOAD_HI_W<7> {
                LOAD_HI_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC mode control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [mode_ctrl](index.html) module
        pub struct MODE_CTRL_SPEC;
        impl crate::RegisterSpec for MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [mode_ctrl::R](R) reader structure
        impl crate::Readable for MODE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [mode_ctrl::W](W) writer structure
        impl crate::Writable for MODE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MODE_CTRL to value 0xc2
        impl crate::Resettable for MODE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0xc2;
        }
    }
    ///TRIG (rw) register accessor: an alias for `Reg<TRIG_SPEC>`
    pub type TRIG = crate::Reg<trig::TRIG_SPEC>;
    ///RWA, RTC trigger value, SAM
    pub mod trig {
        ///Register `TRIG` reader
        pub struct R(crate::R<TRIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TRIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TRIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TRIG` writer
        pub struct W(crate::W<TRIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TRIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TRIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TRIG` reader - RWA, RTC trigger value
        pub type TRIG_R = crate::FieldReader<u32>;
        ///Field `TRIG` writer - RWA, RTC trigger value
        pub type TRIG_W<'a, const O: u8> = crate::FieldWriter<'a, TRIG_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            pub fn trig(&self) -> TRIG_R {
                TRIG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            #[must_use]
            pub fn trig(&mut self) -> TRIG_W<0> {
                TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC trigger value, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [trig](index.html) module
        pub struct TRIG_SPEC;
        impl crate::RegisterSpec for TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [trig::R](R) reader structure
        impl crate::Readable for TRIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [trig::W](W) writer structure
        impl crate::Writable for TRIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TRIG to value 0
        impl crate::Resettable for TRIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT_32K (r) register accessor: an alias for `Reg<CNT_32K_SPEC>`
    pub type CNT_32K = crate::Reg<cnt_32k::CNT_32K_SPEC>;
    ///RO, RTC count based 32KHz
    pub mod cnt_32k {
        ///Register `CNT_32K` reader
        pub struct R(crate::R<CNT_32K_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_32K_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_32K_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_32K_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CNT_32K` reader - R0,RTC count based 32KHz
        pub type CNT_32K_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - R0,RTC count based 32KHz
            #[inline(always)]
            pub fn cnt_32k(&self) -> CNT_32K_R {
                CNT_32K_R::new(self.bits)
            }
        }
        ///RO, RTC count based 32KHz
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt_32k](index.html) module
        pub struct CNT_32K_SPEC;
        impl crate::RegisterSpec for CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cnt_32k::R](R) reader structure
        impl crate::Readable for CNT_32K_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CNT_32K to value 0
        impl crate::Resettable for CNT_32K_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT_2S (r) register accessor: an alias for `Reg<CNT_2S_SPEC>`
    pub type CNT_2S = crate::Reg<cnt_2s::CNT_2S_SPEC>;
    ///RO, RTC count based 2 second
    pub mod cnt_2s {
        ///Register `CNT_2S` reader
        pub struct R(crate::R<CNT_2S_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_2S_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_2S_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_2S_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CNT_2S` reader - RO, RTC count based 2 second
        pub type CNT_2S_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RO, RTC count based 2 second
            #[inline(always)]
            pub fn cnt_2s(&self) -> CNT_2S_R {
                CNT_2S_R::new(self.bits)
            }
        }
        ///RO, RTC count based 2 second
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt_2s](index.html) module
        pub struct CNT_2S_SPEC;
        impl crate::RegisterSpec for CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cnt_2s::R](R) reader structure
        impl crate::Readable for CNT_2S_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CNT_2S to value 0
        impl crate::Resettable for CNT_2S_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT_DAY (r) register accessor: an alias for `Reg<CNT_DAY_SPEC>`
    pub type CNT_DAY = crate::Reg<cnt_day::CNT_DAY_SPEC>;
    ///RO, RTC count based one day, only low 14 bit
    pub mod cnt_day {
        ///Register `CNT_DAY` reader
        pub struct R(crate::R<CNT_DAY_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_DAY_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_DAY_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_DAY_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CNT_DAY` reader - RWA,RTC count based one day
        pub type CNT_DAY_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:13 - RWA,RTC count based one day
            #[inline(always)]
            pub fn cnt_day(&self) -> CNT_DAY_R {
                CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        ///RO, RTC count based one day, only low 14 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt_day](index.html) module
        pub struct CNT_DAY_SPEC;
        impl crate::RegisterSpec for CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt_day::R](R) reader structure
        impl crate::Readable for CNT_DAY_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CNT_DAY to value 0
        impl crate::Resettable for CNT_DAY_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///System control related registers
pub struct SYSCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCTL {}
impl SYSCTL {
    ///Pointer to the register block
    pub const PTR: *const sysctl::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sysctl::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSCTL {
    type Target = sysctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSCTL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSCTL").finish()
    }
}
///System control related registers
pub mod sysctl {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x40],
        ///0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        pub safe_access_sig: SAFE_ACCESS_SIG,
        ///0x41 - RF, chip ID register, always is ID_CH59*
        pub chip_id: CHIP_ID,
        ///0x42 - RF, safe accessing ID register, always 0x0C
        pub safe_access_id: SAFE_ACCESS_ID,
        ///0x43 - RW, watch-dog count, count by clock frequency Fsys/131072
        pub wdog_count: WDOG_COUNT,
        ///0x44 - RWA, reset status, SAM or flash ROM configuration
        pub reset_status_r8_glob_rom_cfg: RESET_STATUS_R8_GLOB_ROM_CFG,
        ///0x45 - RO, global configuration information and status
        pub glob_cfg_info: GLOB_CFG_INFO,
        ///0x46 - RWA, reset and watch-dog control, SAM
        pub rst_wdog_ctrl: RST_WDOG_CTRL,
        ///0x47 - RW, value keeper during global reset
        pub glob_reset_keep: GLOB_RESET_KEEP,
        _reserved8: [u8; 0x03],
        ///0x4b - RWA, PLL configuration control, SAM
        pub pll_config: PLL_CONFIG,
        _reserved9: [u8; 0x02],
        ///0x4e - RWA, external 32MHz oscillator tune control, SAM
        pub xt32m_tune: XT32M_TUNE,
        _reserved10: [u8; 0x01],
        ///0x50 - RO, system clock count value for 32KHz multi-cycles
        pub osc_cal_cnt: OSC_CAL_CNT,
        ///0x52 - RO, oscillator frequency calibration overflow times
        pub osc_cal_ov_cnt: OSC_CAL_OV_CNT,
        ///0x53 - RWA, oscillator frequency calibration control, SAM
        pub osc_cal_ctrl: OSC_CAL_CTRL,
        _reserved13: [u8; 0x07b2],
        ///0x806 -
        pub flash_ctrl: FLASH_CTRL,
        ///0x807 -
        pub flash_cfg: FLASH_CFG,
    }
    ///SAFE_ACCESS_SIG (rw) register accessor: an alias for `Reg<SAFE_ACCESS_SIG_SPEC>`
    pub type SAFE_ACCESS_SIG = crate::Reg<safe_access_sig::SAFE_ACCESS_SIG_SPEC>;
    ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    pub mod safe_access_sig {
        ///Register `SAFE_ACCESS_SIG` reader
        pub struct R(crate::R<SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAFE_ACCESS_SIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAFE_ACCESS_SIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAFE_ACCESS_SIG` writer
        pub struct W(crate::W<SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAFE_ACCESS_SIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAFE_ACCESS_SIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_R = crate::FieldReader;
        ///Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, SAFE_ACCESS_SIG_SPEC, 8, O>;
        ///Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_R = crate::BitReader;
        ///Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_R = crate::FieldReader;
        impl R {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SAFE_ACC_MODE_R {
                SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            pub fn safe_acc_act(&self) -> SAFE_ACC_ACT_R {
                SAFE_ACC_ACT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SAFE_ACC_TIMER_R {
                SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn safe_access_sig(&mut self) -> SAFE_ACCESS_SIG_W<0> {
                SAFE_ACCESS_SIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [safe_access_sig](index.html) module
        pub struct SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [safe_access_sig::R](R) reader structure
        impl crate::Readable for SAFE_ACCESS_SIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [safe_access_sig::W](W) writer structure
        impl crate::Writable for SAFE_ACCESS_SIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHIP_ID (r) register accessor: an alias for `Reg<CHIP_ID_SPEC>`
    pub type CHIP_ID = crate::Reg<chip_id::CHIP_ID_SPEC>;
    ///RF, chip ID register, always is ID_CH59*
    pub mod chip_id {
        ///Register `CHIP_ID` reader
        pub struct R(crate::R<CHIP_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHIP_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHIP_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHIP_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CHIP_ID` reader - RF,chip ID register
        pub type CHIP_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,chip ID register
            #[inline(always)]
            pub fn chip_id(&self) -> CHIP_ID_R {
                CHIP_ID_R::new(self.bits)
            }
        }
        ///RF, chip ID register, always is ID_CH59*
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chip_id](index.html) module
        pub struct CHIP_ID_SPEC;
        impl crate::RegisterSpec for CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [chip_id::R](R) reader structure
        impl crate::Readable for CHIP_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CHIP_ID to value 0
        impl crate::Resettable for CHIP_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAFE_ACCESS_ID (r) register accessor: an alias for `Reg<SAFE_ACCESS_ID_SPEC>`
    pub type SAFE_ACCESS_ID = crate::Reg<safe_access_id::SAFE_ACCESS_ID_SPEC>;
    ///RF, safe accessing ID register, always 0x0C
    pub mod safe_access_id {
        ///Register `SAFE_ACCESS_ID` reader
        pub struct R(crate::R<SAFE_ACCESS_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAFE_ACCESS_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAFE_ACCESS_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAFE_ACCESS_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register
        pub type SAFE_ACCESS_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,safe accessing ID register
            #[inline(always)]
            pub fn safe_access_id(&self) -> SAFE_ACCESS_ID_R {
                SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///RF, safe accessing ID register, always 0x0C
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [safe_access_id](index.html) module
        pub struct SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [safe_access_id::R](R) reader structure
        impl crate::Readable for SAFE_ACCESS_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SAFE_ACCESS_ID to value 0x0c
        impl crate::Resettable for SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c;
        }
    }
    ///WDOG_COUNT (rw) register accessor: an alias for `Reg<WDOG_COUNT_SPEC>`
    pub type WDOG_COUNT = crate::Reg<wdog_count::WDOG_COUNT_SPEC>;
    ///RW, watch-dog count, count by clock frequency Fsys/131072
    pub mod wdog_count {
        ///Register `WDOG_COUNT` reader
        pub struct R(crate::R<WDOG_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDOG_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDOG_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDOG_COUNT` writer
        pub struct W(crate::W<WDOG_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDOG_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDOG_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WDOG_COUNT` reader - RW,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_R = crate::FieldReader;
        ///Field `WDOG_COUNT` writer - RW,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_W<'a, const O: u8> = crate::FieldWriter<'a, WDOG_COUNT_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            pub fn wdog_count(&self) -> WDOG_COUNT_R {
                WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            #[must_use]
            pub fn wdog_count(&mut self) -> WDOG_COUNT_W<0> {
                WDOG_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, watch-dog count, count by clock frequency Fsys/131072
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdog_count](index.html) module
        pub struct WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [wdog_count::R](R) reader structure
        impl crate::Readable for WDOG_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdog_count::W](W) writer structure
        impl crate::Writable for WDOG_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDOG_COUNT to value 0
        impl crate::Resettable for WDOG_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RESET_STATUS_R8_GLOB_ROM_CFG (r) register accessor: an alias for `Reg<RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>`
    pub type RESET_STATUS_R8_GLOB_ROM_CFG =
        crate::Reg<reset_status_r8_glob_rom_cfg::RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>;
    ///RWA, reset status, SAM or flash ROM configuration
    pub mod reset_status_r8_glob_rom_cfg {
        ///Register `RESET_STATUS_R8_GLOB_ROM_CFG` reader
        pub struct R(crate::R<RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RESET_STATUS_R8_GLOB_ROM_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RESET_FLAG` reader - RO, recent reset flag
        pub type RESET_FLAG_R = crate::FieldReader;
        ///Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
        pub type ROM_CODE_OFS_R = crate::BitReader;
        ///Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable
        pub type ROM_CTRL_EN_R = crate::BitReader;
        ///Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write
        pub type ROM_DATA_WE_R = crate::BitReader;
        ///Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write
        pub type ROM_CODE_WE_R = crate::BitReader;
        impl R {
            ///Bits 0:2 - RO, recent reset flag
            #[inline(always)]
            pub fn reset_flag(&self) -> RESET_FLAG_R {
                RESET_FLAG_R::new(self.bits & 7)
            }
            ///Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> ROM_CODE_OFS_R {
                ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable flash ROM control interface enable
            #[inline(always)]
            pub fn rom_ctrl_en(&self) -> ROM_CTRL_EN_R {
                ROM_CTRL_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA,enable flash ROM data and code area being erase/write
            #[inline(always)]
            pub fn rom_data_we(&self) -> ROM_DATA_WE_R {
                ROM_DATA_WE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable flash ROM code area being erase or write
            #[inline(always)]
            pub fn rom_code_we(&self) -> ROM_CODE_WE_R {
                ROM_CODE_WE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RWA, reset status, SAM or flash ROM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [reset_status_r8_glob_rom_cfg](index.html) module
        pub struct RESET_STATUS_R8_GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [reset_status_r8_glob_rom_cfg::R](R) reader structure
        impl crate::Readable for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RESET_STATUS_R8_GLOB_ROM_CFG to value 0x01
        impl crate::Resettable for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///GLOB_CFG_INFO (r) register accessor: an alias for `Reg<GLOB_CFG_INFO_SPEC>`
    pub type GLOB_CFG_INFO = crate::Reg<glob_cfg_info::GLOB_CFG_INFO_SPEC>;
    ///RO, global configuration information and status
    pub mod glob_cfg_info {
        ///Register `GLOB_CFG_INFO` reader
        pub struct R(crate::R<GLOB_CFG_INFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GLOB_CFG_INFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GLOB_CFG_INFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GLOB_CFG_INFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
        pub type CFG_ROM_READ_R = crate::BitReader;
        ///Field `CFG_RESET_EN` reader - RO, manual reset input enable status
        pub type CFG_RESET_EN_R = crate::BitReader;
        ///Field `CFG_BOOT_EN` reader - RO, boot-loader enable status
        pub type CFG_BOOT_EN_R = crate::BitReader;
        ///Field `CFG_DEBUG_EN` reader - RO, debug enable status
        pub type CFG_DEBUG_EN_R = crate::BitReader;
        ///Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
        pub type BOOT_LOADER_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
            #[inline(always)]
            pub fn cfg_rom_read(&self) -> CFG_ROM_READ_R {
                CFG_ROM_READ_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RO, manual reset input enable status
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CFG_RESET_EN_R {
                CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, boot-loader enable status
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CFG_BOOT_EN_R {
                CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, debug enable status
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CFG_DEBUG_EN_R {
                CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
            #[inline(always)]
            pub fn boot_loader(&self) -> BOOT_LOADER_R {
                BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///RO, global configuration information and status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [glob_cfg_info](index.html) module
        pub struct GLOB_CFG_INFO_SPEC;
        impl crate::RegisterSpec for GLOB_CFG_INFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [glob_cfg_info::R](R) reader structure
        impl crate::Readable for GLOB_CFG_INFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets GLOB_CFG_INFO to value 0
        impl crate::Resettable for GLOB_CFG_INFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RST_WDOG_CTRL (rw) register accessor: an alias for `Reg<RST_WDOG_CTRL_SPEC>`
    pub type RST_WDOG_CTRL = crate::Reg<rst_wdog_ctrl::RST_WDOG_CTRL_SPEC>;
    ///RWA, reset and watch-dog control, SAM
    pub mod rst_wdog_ctrl {
        ///Register `RST_WDOG_CTRL` reader
        pub struct R(crate::R<RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RST_WDOG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RST_WDOG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RST_WDOG_CTRL` writer
        pub struct W(crate::W<RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RST_WDOG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RST_WDOG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_R = crate::BitReader;
        ///Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_W<'a, const O: u8> = crate::BitWriter<'a, RST_WDOG_CTRL_SPEC, O>;
        ///Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_R = crate::BitReader;
        ///Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_W<'a, const O: u8> = crate::BitWriter<'a, RST_WDOG_CTRL_SPEC, O>;
        ///Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_R = crate::BitReader;
        ///Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_W<'a, const O: u8> = crate::BitWriter<'a, RST_WDOG_CTRL_SPEC, O>;
        ///Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_R = crate::BitReader;
        ///Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_W<'a, const O: u8> = crate::BitWriter<'a, RST_WDOG_CTRL_SPEC, O>;
        impl R {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            pub fn software_reset(&self) -> SOFTWARE_RESET_R {
                SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WDOG_RST_EN_R {
                WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WDOG_INT_EN_R {
                WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WDOG_INT_FLAG_R {
                WDOG_INT_FLAG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn software_reset(&mut self) -> SOFTWARE_RESET_W<0> {
                SOFTWARE_RESET_W::new(self)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn wdog_rst_en(&mut self) -> WDOG_RST_EN_W<1> {
                WDOG_RST_EN_W::new(self)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_en(&mut self) -> WDOG_INT_EN_W<2> {
                WDOG_INT_EN_W::new(self)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_flag(&mut self) -> WDOG_INT_FLAG_W<4> {
                WDOG_INT_FLAG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, reset and watch-dog control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rst_wdog_ctrl](index.html) module
        pub struct RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rst_wdog_ctrl::R](R) reader structure
        impl crate::Readable for RST_WDOG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rst_wdog_ctrl::W](W) writer structure
        impl crate::Writable for RST_WDOG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RST_WDOG_CTRL to value 0
        impl crate::Resettable for RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GLOB_RESET_KEEP (rw) register accessor: an alias for `Reg<GLOB_RESET_KEEP_SPEC>`
    pub type GLOB_RESET_KEEP = crate::Reg<glob_reset_keep::GLOB_RESET_KEEP_SPEC>;
    ///RW, value keeper during global reset
    pub mod glob_reset_keep {
        ///Register `GLOB_RESET_KEEP` reader
        pub struct R(crate::R<GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GLOB_RESET_KEEP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GLOB_RESET_KEEP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `GLOB_RESET_KEEP` writer
        pub struct W(crate::W<GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<GLOB_RESET_KEEP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<GLOB_RESET_KEEP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_R = crate::FieldReader;
        ///Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_W<'a, const O: u8> =
            crate::FieldWriter<'a, GLOB_RESET_KEEP_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GLOB_RESET_KEEP_R {
                GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn glob_reset_keep(&mut self) -> GLOB_RESET_KEEP_W<0> {
                GLOB_RESET_KEEP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, value keeper during global reset
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [glob_reset_keep](index.html) module
        pub struct GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [glob_reset_keep::R](R) reader structure
        impl crate::Readable for GLOB_RESET_KEEP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [glob_reset_keep::W](W) writer structure
        impl crate::Writable for GLOB_RESET_KEEP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets GLOB_RESET_KEEP to value 0
        impl crate::Resettable for GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PLL_CONFIG (rw) register accessor: an alias for `Reg<PLL_CONFIG_SPEC>`
    pub type PLL_CONFIG = crate::Reg<pll_config::PLL_CONFIG_SPEC>;
    ///RWA, PLL configuration control, SAM
    pub mod pll_config {
        ///Register `PLL_CONFIG` reader
        pub struct R(crate::R<PLL_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PLL_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PLL_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PLL_CONFIG` writer
        pub struct W(crate::W<PLL_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PLL_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PLL_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PLL_CFG_DAT` reader - RWA, PLL configure data
        pub type PLL_CFG_DAT_R = crate::FieldReader;
        ///Field `PLL_CFG_DAT` writer - RWA, PLL configure data
        pub type PLL_CFG_DAT_W<'a, const O: u8> = crate::FieldWriter<'a, PLL_CONFIG_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            pub fn pll_cfg_dat(&self) -> PLL_CFG_DAT_R {
                PLL_CFG_DAT_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            #[must_use]
            pub fn pll_cfg_dat(&mut self) -> PLL_CFG_DAT_W<0> {
                PLL_CFG_DAT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, PLL configuration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pll_config](index.html) module
        pub struct PLL_CONFIG_SPEC;
        impl crate::RegisterSpec for PLL_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pll_config::R](R) reader structure
        impl crate::Readable for PLL_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pll_config::W](W) writer structure
        impl crate::Writable for PLL_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PLL_CONFIG to value 0x02
        impl crate::Resettable for PLL_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///XT32M_TUNE (rw) register accessor: an alias for `Reg<XT32M_TUNE_SPEC>`
    pub type XT32M_TUNE = crate::Reg<xt32m_tune::XT32M_TUNE_SPEC>;
    ///RWA, external 32MHz oscillator tune control, SAM
    pub mod xt32m_tune {
        ///Register `XT32M_TUNE` reader
        pub struct R(crate::R<XT32M_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<XT32M_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<XT32M_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `XT32M_TUNE` writer
        pub struct W(crate::W<XT32M_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<XT32M_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<XT32M_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_R = crate::FieldReader;
        ///Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_W<'a, const O: u8> = crate::FieldWriter<'a, XT32M_TUNE_SPEC, 2, O>;
        ///Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_R = crate::FieldReader;
        ///Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_W<'a, const O: u8> = crate::FieldWriter<'a, XT32M_TUNE_SPEC, 3, O>;
        impl R {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            pub fn xt32m_i_bias(&self) -> XT32M_I_BIAS_R {
                XT32M_I_BIAS_R::new(self.bits & 3)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            pub fn xt32m_c_load(&self) -> XT32M_C_LOAD_R {
                XT32M_C_LOAD_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            #[must_use]
            pub fn xt32m_i_bias(&mut self) -> XT32M_I_BIAS_W<0> {
                XT32M_I_BIAS_W::new(self)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            #[must_use]
            pub fn xt32m_c_load(&mut self) -> XT32M_C_LOAD_W<4> {
                XT32M_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, external 32MHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [xt32m_tune](index.html) module
        pub struct XT32M_TUNE_SPEC;
        impl crate::RegisterSpec for XT32M_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [xt32m_tune::R](R) reader structure
        impl crate::Readable for XT32M_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [xt32m_tune::W](W) writer structure
        impl crate::Writable for XT32M_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets XT32M_TUNE to value 0x32
        impl crate::Resettable for XT32M_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x32;
        }
    }
    ///OSC_CAL_CNT (r) register accessor: an alias for `Reg<OSC_CAL_CNT_SPEC>`
    pub type OSC_CAL_CNT = crate::Reg<osc_cal_cnt::OSC_CAL_CNT_SPEC>;
    ///RO, system clock count value for 32KHz multi-cycles
    pub mod osc_cal_cnt {
        ///Register `OSC_CAL_CNT` reader
        pub struct R(crate::R<OSC_CAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles
        pub type OSC_CAL_CNT_R = crate::FieldReader<u16>;
        ///Field `OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
        pub type OSC_CAL_OV_CLR_R = crate::BitReader;
        ///Field `OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear
        pub type OSC_CAL_IF_R = crate::BitReader;
        impl R {
            ///Bits 0:13 - RO, system clock count value for 32KHz multi-cycles
            #[inline(always)]
            pub fn osc_cal_cnt(&self) -> OSC_CAL_CNT_R {
                OSC_CAL_CNT_R::new(self.bits & 0x3fff)
            }
            ///Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
            #[inline(always)]
            pub fn osc_cal_ov_clr(&self) -> OSC_CAL_OV_CLR_R {
                OSC_CAL_OV_CLR_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear
            #[inline(always)]
            pub fn osc_cal_if(&self) -> OSC_CAL_IF_R {
                OSC_CAL_IF_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///RO, system clock count value for 32KHz multi-cycles
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_cnt](index.html) module
        pub struct OSC_CAL_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [osc_cal_cnt::R](R) reader structure
        impl crate::Readable for OSC_CAL_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OSC_CAL_CNT to value 0
        impl crate::Resettable for OSC_CAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OSC_CAL_OV_CNT (r) register accessor: an alias for `Reg<OSC_CAL_OV_CNT_SPEC>`
    pub type OSC_CAL_OV_CNT = crate::Reg<osc_cal_ov_cnt::OSC_CAL_OV_CNT_SPEC>;
    ///RO, oscillator frequency calibration overflow times
    pub mod osc_cal_ov_cnt {
        ///Register `OSC_CAL_OV_CNT` reader
        pub struct R(crate::R<OSC_CAL_OV_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_OV_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_OV_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_OV_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times
        pub type OSC_CAL_OV_CNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, oscillator frequency calibration overflow times
            #[inline(always)]
            pub fn osc_cal_ov_cnt(&self) -> OSC_CAL_OV_CNT_R {
                OSC_CAL_OV_CNT_R::new(self.bits)
            }
        }
        ///RO, oscillator frequency calibration overflow times
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_ov_cnt](index.html) module
        pub struct OSC_CAL_OV_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_OV_CNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [osc_cal_ov_cnt::R](R) reader structure
        impl crate::Readable for OSC_CAL_OV_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OSC_CAL_OV_CNT to value 0
        impl crate::Resettable for OSC_CAL_OV_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OSC_CAL_CTRL (rw) register accessor: an alias for `Reg<OSC_CAL_CTRL_SPEC>`
    pub type OSC_CAL_CTRL = crate::Reg<osc_cal_ctrl::OSC_CAL_CTRL_SPEC>;
    ///RWA, oscillator frequency calibration control, SAM
    pub mod osc_cal_ctrl {
        ///Register `OSC_CAL_CTRL` reader
        pub struct R(crate::R<OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OSC_CAL_CTRL` writer
        pub struct W(crate::W<OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OSC_CAL_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OSC_CAL_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_R = crate::FieldReader;
        ///Field `OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_W<'a, const O: u8> = crate::FieldWriter<'a, OSC_CAL_CTRL_SPEC, 3, O>;
        ///Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
        pub type OSC_CNT_HALT_R = crate::BitReader;
        ///Field `OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_R = crate::BitReader;
        ///Field `OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_W<'a, const O: u8> = crate::BitWriter<'a, OSC_CAL_CTRL_SPEC, O>;
        ///Field `OSC_CNT_EN` reader - RWA, calibration counter enable
        pub type OSC_CNT_EN_R = crate::BitReader;
        ///Field `OSC_CNT_EN` writer - RWA, calibration counter enable
        pub type OSC_CNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, OSC_CAL_CTRL_SPEC, O>;
        ///Field `OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_R = crate::BitReader;
        ///Field `OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_W<'a, const O: u8> = crate::BitWriter<'a, OSC_CAL_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            pub fn osc_cnt_total(&self) -> OSC_CNT_TOTAL_R {
                OSC_CNT_TOTAL_R::new(self.bits & 7)
            }
            ///Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
            #[inline(always)]
            pub fn osc_cnt_halt(&self) -> OSC_CNT_HALT_R {
                OSC_CNT_HALT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            pub fn osc_cal_ie(&self) -> OSC_CAL_IE_R {
                OSC_CAL_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            pub fn osc_cnt_en(&self) -> OSC_CNT_EN_R {
                OSC_CNT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            pub fn osc_cnt_end(&self) -> OSC_CNT_END_R {
                OSC_CNT_END_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_total(&mut self) -> OSC_CNT_TOTAL_W<0> {
                OSC_CNT_TOTAL_W::new(self)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            #[must_use]
            pub fn osc_cal_ie(&mut self) -> OSC_CAL_IE_W<4> {
                OSC_CAL_IE_W::new(self)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_en(&mut self) -> OSC_CNT_EN_W<5> {
                OSC_CNT_EN_W::new(self)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_end(&mut self) -> OSC_CNT_END_W<6> {
                OSC_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, oscillator frequency calibration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_ctrl](index.html) module
        pub struct OSC_CAL_CTRL_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [osc_cal_ctrl::R](R) reader structure
        impl crate::Readable for OSC_CAL_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [osc_cal_ctrl::W](W) writer structure
        impl crate::Writable for OSC_CAL_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OSC_CAL_CTRL to value 0x09
        impl crate::Resettable for OSC_CAL_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x09;
        }
    }
    ///FLASH_CFG (rw) register accessor: an alias for `Reg<FLASH_CFG_SPEC>`
    pub type FLASH_CFG = crate::Reg<flash_cfg::FLASH_CFG_SPEC>;
    ///
    pub mod flash_cfg {
        ///Register `FLASH_CFG` reader
        pub struct R(crate::R<FLASH_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FLASH_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FLASH_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FLASH_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FLASH_CFG` writer
        pub struct W(crate::W<FLASH_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FLASH_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FLASH_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FLASH_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FLASH_CFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [flash_cfg](index.html) module
        pub struct FLASH_CFG_SPEC;
        impl crate::RegisterSpec for FLASH_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [flash_cfg::R](R) reader structure
        impl crate::Readable for FLASH_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [flash_cfg::W](W) writer structure
        impl crate::Writable for FLASH_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FLASH_CFG to value 0x07
        impl crate::Resettable for FLASH_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x07;
        }
    }
    ///FLASH_CTRL (rw) register accessor: an alias for `Reg<FLASH_CTRL_SPEC>`
    pub type FLASH_CTRL = crate::Reg<flash_ctrl::FLASH_CTRL_SPEC>;
    ///
    pub mod flash_ctrl {
        ///Register `FLASH_CTRL` reader
        pub struct R(crate::R<FLASH_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FLASH_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FLASH_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FLASH_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FLASH_CTRL` writer
        pub struct W(crate::W<FLASH_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FLASH_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FLASH_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FLASH_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FLASH_CTRL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [flash_ctrl](index.html) module
        pub struct FLASH_CTRL_SPEC;
        impl crate::RegisterSpec for FLASH_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [flash_ctrl::R](R) reader structure
        impl crate::Readable for FLASH_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [flash_ctrl::W](W) writer structure
        impl crate::Writable for FLASH_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FLASH_CTRL to value 0x40
        impl crate::Resettable for FLASH_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
}
///Touch buttons
pub struct TOUCH_KEY {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TOUCH_KEY {}
impl TOUCH_KEY {
    ///Pointer to the register block
    pub const PTR: *const touch_key::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const touch_key::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TOUCH_KEY {
    type Target = touch_key::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TOUCH_KEY {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TOUCH_KEY").finish()
    }
}
///Touch buttons
pub mod touch_key {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x54],
        ///0x54 - RW, Touchkey charge and discharge count
        pub tkey_count: TKEY_COUNT,
        _reserved1: [u8; 0x01],
        ///0x56 - RW, Touchkey convert start control
        pub tkey_convert: TKEY_CONVERT,
        ///0x57 - RW, Touchkey configure
        pub tkey_cfg: TKEY_CFG,
    }
    ///TKEY_COUNT (rw) register accessor: an alias for `Reg<TKEY_COUNT_SPEC>`
    pub type TKEY_COUNT = crate::Reg<tkey_count::TKEY_COUNT_SPEC>;
    ///RW, Touchkey charge and discharge count
    pub mod tkey_count {
        ///Register `TKEY_COUNT` reader
        pub struct R(crate::R<TKEY_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_COUNT` writer
        pub struct W(crate::W<TKEY_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_R = crate::FieldReader;
        ///Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_W<'a, const O: u8> = crate::FieldWriter<'a, TKEY_COUNT_SPEC, 5, O>;
        ///Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_R = crate::FieldReader;
        ///Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_W<'a, const O: u8> = crate::FieldWriter<'a, TKEY_COUNT_SPEC, 3, O>;
        impl R {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            pub fn tkey_charg_cnt(&self) -> TKEY_CHARG_CNT_R {
                TKEY_CHARG_CNT_R::new(self.bits & 0x1f)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            pub fn tkey_disch_cnt(&self) -> TKEY_DISCH_CNT_R {
                TKEY_DISCH_CNT_R::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_charg_cnt(&mut self) -> TKEY_CHARG_CNT_W<0> {
                TKEY_CHARG_CNT_W::new(self)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_disch_cnt(&mut self) -> TKEY_DISCH_CNT_W<5> {
                TKEY_DISCH_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey charge and discharge count
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_count](index.html) module
        pub struct TKEY_COUNT_SPEC;
        impl crate::RegisterSpec for TKEY_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_count::R](R) reader structure
        impl crate::Readable for TKEY_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_count::W](W) writer structure
        impl crate::Writable for TKEY_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_COUNT to value 0
        impl crate::Resettable for TKEY_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TKEY_CONVERT (rw) register accessor: an alias for `Reg<TKEY_CONVERT_SPEC>`
    pub type TKEY_CONVERT = crate::Reg<tkey_convert::TKEY_CONVERT_SPEC>;
    ///RW, Touchkey convert start control
    pub mod tkey_convert {
        ///Register `TKEY_CONVERT` reader
        pub struct R(crate::R<TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_CONVERT` writer
        pub struct W(crate::W<TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_START` reader - RW, Touchkey convert start control
        pub type TKEY_START_R = crate::BitReader;
        ///Field `TKEY_START` writer - RW, Touchkey convert start control
        pub type TKEY_START_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CONVERT_SPEC, O>;
        impl R {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            pub fn tkey_start(&self) -> TKEY_START_R {
                TKEY_START_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            #[must_use]
            pub fn tkey_start(&mut self) -> TKEY_START_W<0> {
                TKEY_START_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey convert start control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_convert](index.html) module
        pub struct TKEY_CONVERT_SPEC;
        impl crate::RegisterSpec for TKEY_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_convert::R](R) reader structure
        impl crate::Readable for TKEY_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_convert::W](W) writer structure
        impl crate::Writable for TKEY_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_CONVERT to value 0
        impl crate::Resettable for TKEY_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TKEY_CFG (rw) register accessor: an alias for `Reg<TKEY_CFG_SPEC>`
    pub type TKEY_CFG = crate::Reg<tkey_cfg::TKEY_CFG_SPEC>;
    ///RW, Touchkey configure
    pub mod tkey_cfg {
        ///Register `TKEY_CFG` reader
        pub struct R(crate::R<TKEY_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_CFG` writer
        pub struct W(crate::W<TKEY_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_PWR_ON` reader - RW, Touchkey power on
        pub type TKEY_PWR_ON_R = crate::BitReader;
        ///Field `TKEY_PWR_ON` writer - RW, Touchkey power on
        pub type TKEY_PWR_ON_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        ///Field `TKEY_CURRENT` reader - R0, Touchkey charge current selection
        pub type TKEY_CURRENT_R = crate::BitReader;
        ///Field `TKEY_DRV_EN` reader - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_R = crate::BitReader;
        ///Field `TKEY_DRV_EN` writer - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        ///Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_R = crate::BitReader;
        ///Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        ///Field `TKEY_DMA_EN` reader - RW, TouchKey DMA Enable
        pub type TKEY_DMA_EN_R = crate::BitReader;
        ///Field `TKEY_DMA_EN` writer - RW, TouchKey DMA Enable
        pub type TKEY_DMA_EN_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        ///Field `TKEY_AUTO_EN` reader - RW, TouchKey automatic trigger enable
        pub type TKEY_AUTO_EN_R = crate::BitReader;
        ///Field `TKEY_AUTO_EN` writer - RW, TouchKey automatic trigger enable
        pub type TKEY_AUTO_EN_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        ///Field `TKEY_RAND_EN` reader - RW, TouchKey Trigger enable at will
        pub type TKEY_RAND_EN_R = crate::BitReader;
        ///Field `TKEY_RAND_EN` writer - RW, TouchKey Trigger enable at will
        pub type TKEY_RAND_EN_W<'a, const O: u8> = crate::BitWriter<'a, TKEY_CFG_SPEC, O>;
        impl R {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            pub fn tkey_pwr_on(&self) -> TKEY_PWR_ON_R {
                TKEY_PWR_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - R0, Touchkey charge current selection
            #[inline(always)]
            pub fn tkey_current(&self) -> TKEY_CURRENT_R {
                TKEY_CURRENT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            pub fn tkey_drv_en(&self) -> TKEY_DRV_EN_R {
                TKEY_DRV_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            pub fn tkey_pga_adj(&self) -> TKEY_PGA_ADJ_R {
                TKEY_PGA_ADJ_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, TouchKey DMA Enable
            #[inline(always)]
            pub fn tkey_dma_en(&self) -> TKEY_DMA_EN_R {
                TKEY_DMA_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, TouchKey automatic trigger enable
            #[inline(always)]
            pub fn tkey_auto_en(&self) -> TKEY_AUTO_EN_R {
                TKEY_AUTO_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, TouchKey Trigger enable at will
            #[inline(always)]
            pub fn tkey_rand_en(&self) -> TKEY_RAND_EN_R {
                TKEY_RAND_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            #[must_use]
            pub fn tkey_pwr_on(&mut self) -> TKEY_PWR_ON_W<0> {
                TKEY_PWR_ON_W::new(self)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_drv_en(&mut self) -> TKEY_DRV_EN_W<2> {
                TKEY_DRV_EN_W::new(self)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_pga_adj(&mut self) -> TKEY_PGA_ADJ_W<3> {
                TKEY_PGA_ADJ_W::new(self)
            }
            ///Bit 4 - RW, TouchKey DMA Enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_dma_en(&mut self) -> TKEY_DMA_EN_W<4> {
                TKEY_DMA_EN_W::new(self)
            }
            ///Bit 5 - RW, TouchKey automatic trigger enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_auto_en(&mut self) -> TKEY_AUTO_EN_W<5> {
                TKEY_AUTO_EN_W::new(self)
            }
            ///Bit 6 - RW, TouchKey Trigger enable at will
            #[inline(always)]
            #[must_use]
            pub fn tkey_rand_en(&mut self) -> TKEY_RAND_EN_W<6> {
                TKEY_RAND_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_cfg](index.html) module
        pub struct TKEY_CFG_SPEC;
        impl crate::RegisterSpec for TKEY_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_cfg::R](R) reader structure
        impl crate::Readable for TKEY_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_cfg::W](W) writer structure
        impl crate::Writable for TKEY_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_CFG to value 0
        impl crate::Resettable for TKEY_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Analog to Digital Converter
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    ///Pointer to the register block
    pub const PTR: *const adc::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
///Analog to Digital Converter
pub mod adc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x58],
        ///0x58 - RW, ADC input channel selection
        pub adc_channel: ADC_CHANNEL,
        ///0x59 - RW, ADC configure
        pub adc_cfg: ADC_CFG,
        ///0x5a - RW, ADC convert control
        pub adc_convert: ADC_CONVERT,
        ///0x5b - RW, temperature sensor control
        pub tem_sensor: TEM_SENSOR,
        ///0x5c - RO, ADC data
        pub adc_data: ADC_DATA,
        ///0x5e - RO, ADC interrupt flag register
        pub adc_int_flag: ADC_INT_FLAG,
        _reserved6: [u8; 0x02],
        ///0x61 - RW, ADC DMA control
        pub adc_ctrl_dma: ADC_CTRL_DMA,
        ///0x62 - RW1, ADC and DMA interrupt flag registers
        pub adc_dma_if: ADC_DMA_IF,
        ///0x63 - RO, ADC interrupt flag
        pub adc_auto_cycle: ADC_AUTO_CYCLE,
        ///0x64 - RO, ADC DMA current address
        pub adc_dma_now: ADC_DMA_NOW,
        _reserved10: [u8; 0x02],
        ///0x68 - RW, ADC DMA begin address
        pub adc_dma_beg: ADC_DMA_BEG,
        _reserved11: [u8; 0x02],
        ///0x6c - RW, ADC DMA end address
        pub adc_dma_end: ADC_DMA_END,
    }
    ///ADC_CHANNEL (rw) register accessor: an alias for `Reg<ADC_CHANNEL_SPEC>`
    pub type ADC_CHANNEL = crate::Reg<adc_channel::ADC_CHANNEL_SPEC>;
    ///RW, ADC input channel selection
    pub mod adc_channel {
        ///Register `ADC_CHANNEL` reader
        pub struct R(crate::R<ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CHANNEL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CHANNEL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CHANNEL` writer
        pub struct W(crate::W<ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CHANNEL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CHANNEL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_CH_INX` reader - RW, ADC input channel index
        pub type ADC_CH_INX_R = crate::FieldReader;
        ///Field `ADC_CH_INX` writer - RW, ADC input channel index
        pub type ADC_CH_INX_W<'a, const O: u8> = crate::FieldWriter<'a, ADC_CHANNEL_SPEC, 4, O>;
        impl R {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            pub fn adc_ch_inx(&self) -> ADC_CH_INX_R {
                ADC_CH_INX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn adc_ch_inx(&mut self) -> ADC_CH_INX_W<0> {
                ADC_CH_INX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC input channel selection
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_channel](index.html) module
        pub struct ADC_CHANNEL_SPEC;
        impl crate::RegisterSpec for ADC_CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_channel::R](R) reader structure
        impl crate::Readable for ADC_CHANNEL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_channel::W](W) writer structure
        impl crate::Writable for ADC_CHANNEL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CHANNEL to value 0x0f
        impl crate::Resettable for ADC_CHANNEL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0f;
        }
    }
    ///ADC_CFG (rw) register accessor: an alias for `Reg<ADC_CFG_SPEC>`
    pub type ADC_CFG = crate::Reg<adc_cfg::ADC_CFG_SPEC>;
    ///RW, ADC configure
    pub mod adc_cfg {
        ///Register `ADC_CFG` reader
        pub struct R(crate::R<ADC_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CFG` writer
        pub struct W(crate::W<ADC_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_R = crate::BitReader;
        ///Field `ADC_POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CFG_SPEC, O>;
        ///Field `ADC_BUF_EN` reader - RW, ADC input buffer enable
        pub type ADC_BUF_EN_R = crate::BitReader;
        ///Field `ADC_BUF_EN` writer - RW, ADC input buffer enable
        pub type ADC_BUF_EN_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CFG_SPEC, O>;
        ///Field `ADC_DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_R = crate::BitReader;
        ///Field `ADC_DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CFG_SPEC, O>;
        ///Field `ADC_OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_R = crate::BitReader;
        ///Field `ADC_OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CFG_SPEC, O>;
        ///Field `ADC_PGA_GAIN_10` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_10_R = crate::FieldReader;
        ///Field `ADC_PGA_GAIN_10` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_10_W<'a, const O: u8> = crate::FieldWriter<'a, ADC_CFG_SPEC, 2, O>;
        ///Field `ADC_CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_R = crate::FieldReader;
        ///Field `ADC_CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_W<'a, const O: u8> = crate::FieldWriter<'a, ADC_CFG_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn adc_power_on(&self) -> ADC_POWER_ON_R {
                ADC_POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            pub fn adc_buf_en(&self) -> ADC_BUF_EN_R {
                ADC_BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn adc_diff_en(&self) -> ADC_DIFF_EN_R {
                ADC_DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            pub fn adc_ofs_test(&self) -> ADC_OFS_TEST_R {
                ADC_OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn adc_pga_gain_10(&self) -> ADC_PGA_GAIN_10_R {
                ADC_PGA_GAIN_10_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn adc_clk_div(&self) -> ADC_CLK_DIV_R {
                ADC_CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn adc_power_on(&mut self) -> ADC_POWER_ON_W<0> {
                ADC_POWER_ON_W::new(self)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn adc_buf_en(&mut self) -> ADC_BUF_EN_W<1> {
                ADC_BUF_EN_W::new(self)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn adc_diff_en(&mut self) -> ADC_DIFF_EN_W<2> {
                ADC_DIFF_EN_W::new(self)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            #[must_use]
            pub fn adc_ofs_test(&mut self) -> ADC_OFS_TEST_W<3> {
                ADC_OFS_TEST_W::new(self)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn adc_pga_gain_10(&mut self) -> ADC_PGA_GAIN_10_W<4> {
                ADC_PGA_GAIN_10_W::new(self)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn adc_clk_div(&mut self) -> ADC_CLK_DIV_W<6> {
                ADC_CLK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_cfg](index.html) module
        pub struct ADC_CFG_SPEC;
        impl crate::RegisterSpec for ADC_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_cfg::R](R) reader structure
        impl crate::Readable for ADC_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_cfg::W](W) writer structure
        impl crate::Writable for ADC_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CFG to value 0xa0
        impl crate::Resettable for ADC_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0xa0;
        }
    }
    ///ADC_CONVERT (rw) register accessor: an alias for `Reg<ADC_CONVERT_SPEC>`
    pub type ADC_CONVERT = crate::Reg<adc_convert::ADC_CONVERT_SPEC>;
    ///RW, ADC convert control
    pub mod adc_convert {
        ///Register `ADC_CONVERT` reader
        pub struct R(crate::R<ADC_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CONVERT` writer
        pub struct W(crate::W<ADC_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_R = crate::BitReader;
        ///Field `ADC_START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CONVERT_SPEC, O>;
        ///Field `ADC_PGA_GAIN_2` reader - RW, ADC input PGA gain direction selection, combined with RB_ ADC_ PGA_ GAIN \[1:0\]
        ///usage
        pub type ADC_PGA_GAIN_2_R = crate::BitReader;
        ///Field `ADC_PGA_GAIN_2` writer - RW, ADC input PGA gain direction selection, combined with RB_ ADC_ PGA_ GAIN \[1:0\]
        ///usage
        pub type ADC_PGA_GAIN_2_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CONVERT_SPEC, O>;
        ///Field `ADC_EOC_X` reader - RO, end of ADC conversion flag
        pub type ADC_EOC_X_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            pub fn adc_start(&self) -> ADC_START_R {
                ADC_START_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input PGA gain direction selection, combined with RB_ ADC_ PGA_ GAIN \[1:0\]
            ///usage
            #[inline(always)]
            pub fn adc_pga_gain_2(&self) -> ADC_PGA_GAIN_2_R {
                ADC_PGA_GAIN_2_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RO, end of ADC conversion flag
            #[inline(always)]
            pub fn adc_eoc_x(&self) -> ADC_EOC_X_R {
                ADC_EOC_X_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            #[must_use]
            pub fn adc_start(&mut self) -> ADC_START_W<0> {
                ADC_START_W::new(self)
            }
            ///Bit 1 - RW, ADC input PGA gain direction selection, combined with RB_ ADC_ PGA_ GAIN \[1:0\]
            ///usage
            #[inline(always)]
            #[must_use]
            pub fn adc_pga_gain_2(&mut self) -> ADC_PGA_GAIN_2_W<1> {
                ADC_PGA_GAIN_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC convert control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_convert](index.html) module
        pub struct ADC_CONVERT_SPEC;
        impl crate::RegisterSpec for ADC_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_convert::R](R) reader structure
        impl crate::Readable for ADC_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_convert::W](W) writer structure
        impl crate::Writable for ADC_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CONVERT to value 0
        impl crate::Resettable for ADC_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TEM_SENSOR (rw) register accessor: an alias for `Reg<TEM_SENSOR_SPEC>`
    pub type TEM_SENSOR = crate::Reg<tem_sensor::TEM_SENSOR_SPEC>;
    ///RW, temperature sensor control
    pub mod tem_sensor {
        ///Register `TEM_SENSOR` reader
        pub struct R(crate::R<TEM_SENSOR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TEM_SENSOR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TEM_SENSOR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TEM_SENSOR` writer
        pub struct W(crate::W<TEM_SENSOR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TEM_SENSOR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TEM_SENSOR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_R = crate::BitReader;
        ///Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_W<'a, const O: u8> = crate::BitWriter<'a, TEM_SENSOR_SPEC, O>;
        impl R {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn tem_sen_pwr_on(&self) -> TEM_SEN_PWR_ON_R {
                TEM_SEN_PWR_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn tem_sen_pwr_on(&mut self) -> TEM_SEN_PWR_ON_W<7> {
                TEM_SEN_PWR_ON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, temperature sensor control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tem_sensor](index.html) module
        pub struct TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tem_sensor::R](R) reader structure
        impl crate::Readable for TEM_SENSOR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tem_sensor::W](W) writer structure
        impl crate::Writable for TEM_SENSOR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TEM_SENSOR to value 0
        impl crate::Resettable for TEM_SENSOR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DATA (r) register accessor: an alias for `Reg<ADC_DATA_SPEC>`
    pub type ADC_DATA = crate::Reg<adc_data::ADC_DATA_SPEC>;
    ///RO, ADC data
    pub mod adc_data {
        ///Register `ADC_DATA` reader
        pub struct R(crate::R<ADC_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_DATA` reader - RO, ADC conversion data
        pub type ADC_DATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:11 - RO, ADC conversion data
            #[inline(always)]
            pub fn adc_data(&self) -> ADC_DATA_R {
                ADC_DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///RO, ADC data
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_data](index.html) module
        pub struct ADC_DATA_SPEC;
        impl crate::RegisterSpec for ADC_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_data::R](R) reader structure
        impl crate::Readable for ADC_DATA_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_DATA to value 0
        impl crate::Resettable for ADC_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_INT_FLAG (r) register accessor: an alias for `Reg<ADC_INT_FLAG_SPEC>`
    pub type ADC_INT_FLAG = crate::Reg<adc_int_flag::ADC_INT_FLAG_SPEC>;
    ///RO, ADC interrupt flag register
    pub mod adc_int_flag {
        ///Register `ADC_INT_FLAG` reader
        pub struct R(crate::R<ADC_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_IF_EOC` reader - RO, ADC conversion interrupt flag
        pub type ADC_IF_EOC_R = crate::BitReader;
        impl R {
            ///Bit 7 - RO, ADC conversion interrupt flag
            #[inline(always)]
            pub fn adc_if_eoc(&self) -> ADC_IF_EOC_R {
                ADC_IF_EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, ADC interrupt flag register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_int_flag](index.html) module
        pub struct ADC_INT_FLAG_SPEC;
        impl crate::RegisterSpec for ADC_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_int_flag::R](R) reader structure
        impl crate::Readable for ADC_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_INT_FLAG to value 0
        impl crate::Resettable for ADC_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_CTRL_DMA (rw) register accessor: an alias for `Reg<ADC_CTRL_DMA_SPEC>`
    pub type ADC_CTRL_DMA = crate::Reg<adc_ctrl_dma::ADC_CTRL_DMA_SPEC>;
    ///RW, ADC DMA control
    pub mod adc_ctrl_dma {
        ///Register `ADC_CTRL_DMA` reader
        pub struct R(crate::R<ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CTRL_DMA` writer
        pub struct W(crate::W<ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_ENABLE` reader - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_R = crate::BitReader;
        ///Field `ADC_DMA_ENABLE` writer - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        ///Field `ADC_DMA_LOOP` reader - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_R = crate::BitReader;
        ///Field `ADC_DMA_LOOP` writer - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        ///Field `ADC_IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_R = crate::BitReader;
        ///Field `ADC_IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        ///Field `ADC_IE_EOC` reader - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_R = crate::BitReader;
        ///Field `ADC_IE_EOC` writer - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        ///Field `ADC_CONT_EN` reader - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_R = crate::BitReader;
        ///Field `ADC_CONT_EN` writer - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        ///Field `ADC_AUTO_EN` reader - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_R = crate::BitReader;
        ///Field `ADC_AUTO_EN` writer - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_W<'a, const O: u8> = crate::BitWriter<'a, ADC_CTRL_DMA_SPEC, O>;
        impl R {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_enable(&self) -> ADC_DMA_ENABLE_R {
                ADC_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            pub fn adc_dma_loop(&self) -> ADC_DMA_LOOP_R {
                ADC_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            pub fn adc_ie_dma_end(&self) -> ADC_IE_DMA_END_R {
                ADC_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            pub fn adc_ie_eoc(&self) -> ADC_IE_EOC_R {
                ADC_IE_EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            pub fn adc_cont_en(&self) -> ADC_CONT_EN_R {
                ADC_CONT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn adc_auto_en(&self) -> ADC_AUTO_EN_R {
                ADC_AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_enable(&mut self) -> ADC_DMA_ENABLE_W<0> {
                ADC_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_loop(&mut self) -> ADC_DMA_LOOP_W<2> {
                ADC_DMA_LOOP_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_dma_end(&mut self) -> ADC_IE_DMA_END_W<3> {
                ADC_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_eoc(&mut self) -> ADC_IE_EOC_W<4> {
                ADC_IE_EOC_W::new(self)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            #[must_use]
            pub fn adc_cont_en(&mut self) -> ADC_CONT_EN_W<6> {
                ADC_CONT_EN_W::new(self)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_en(&mut self) -> ADC_AUTO_EN_W<7> {
                ADC_AUTO_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_ctrl_dma](index.html) module
        pub struct ADC_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for ADC_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_ctrl_dma::R](R) reader structure
        impl crate::Readable for ADC_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_ctrl_dma::W](W) writer structure
        impl crate::Writable for ADC_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CTRL_DMA to value 0
        impl crate::Resettable for ADC_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_IF (rw) register accessor: an alias for `Reg<ADC_DMA_IF_SPEC>`
    pub type ADC_DMA_IF = crate::Reg<adc_dma_if::ADC_DMA_IF_SPEC>;
    ///RW1, ADC and DMA interrupt flag registers
    pub mod adc_dma_if {
        ///Register `ADC_DMA_IF` reader
        pub struct R(crate::R<ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_IF` writer
        pub struct W(crate::W<ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_IF_DMA_END` reader - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_R = crate::BitReader;
        ///Field `ADC_IF_DMA_END` writer - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, ADC_DMA_IF_SPEC, O>;
        ///Field `ADC_IF_END_ADC` reader - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_R = crate::BitReader;
        ///Field `ADC_IF_END_ADC` writer - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_W<'a, const O: u8> = crate::BitWriter<'a, ADC_DMA_IF_SPEC, O>;
        impl R {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            pub fn adc_if_dma_end(&self) -> ADC_IF_DMA_END_R {
                ADC_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            pub fn adc_if_end_adc(&self) -> ADC_IF_END_ADC_R {
                ADC_IF_END_ADC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_dma_end(&mut self) -> ADC_IF_DMA_END_W<3> {
                ADC_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_end_adc(&mut self) -> ADC_IF_END_ADC_W<4> {
                ADC_IF_END_ADC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, ADC and DMA interrupt flag registers
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_if](index.html) module
        pub struct ADC_DMA_IF_SPEC;
        impl crate::RegisterSpec for ADC_DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_dma_if::R](R) reader structure
        impl crate::Readable for ADC_DMA_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_if::W](W) writer structure
        impl crate::Writable for ADC_DMA_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_IF to value 0
        impl crate::Resettable for ADC_DMA_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_AUTO_CYCLE (rw) register accessor: an alias for `Reg<ADC_AUTO_CYCLE_SPEC>`
    pub type ADC_AUTO_CYCLE = crate::Reg<adc_auto_cycle::ADC_AUTO_CYCLE_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_auto_cycle {
        ///Register `ADC_AUTO_CYCLE` reader
        pub struct R(crate::R<ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_AUTO_CYCLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_AUTO_CYCLE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_AUTO_CYCLE` writer
        pub struct W(crate::W<ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_AUTO_CYCLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_AUTO_CYCLE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_R = crate::FieldReader;
        ///Field `ADC_AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_W<'a, const O: u8> =
            crate::FieldWriter<'a, ADC_AUTO_CYCLE_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            pub fn adc_auto_cycle(&self) -> ADC_AUTO_CYCLE_R {
                ADC_AUTO_CYCLE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_cycle(&mut self) -> ADC_AUTO_CYCLE_W<0> {
                ADC_AUTO_CYCLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_auto_cycle](index.html) module
        pub struct ADC_AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for ADC_AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_auto_cycle::R](R) reader structure
        impl crate::Readable for ADC_AUTO_CYCLE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_auto_cycle::W](W) writer structure
        impl crate::Writable for ADC_AUTO_CYCLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_AUTO_CYCLE to value 0
        impl crate::Resettable for ADC_AUTO_CYCLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_NOW (r) register accessor: an alias for `Reg<ADC_DMA_NOW_SPEC>`
    pub type ADC_DMA_NOW = crate::Reg<adc_dma_now::ADC_DMA_NOW_SPEC>;
    ///RO, ADC DMA current address
    pub mod adc_dma_now {
        ///Register `ADC_DMA_NOW` reader
        pub struct R(crate::R<ADC_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_DMA_NOW` reader - ADC DMA current address
        pub type ADC_DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 1:14 - ADC DMA current address
            #[inline(always)]
            pub fn adc_dma_now(&self) -> ADC_DMA_NOW_R {
                ADC_DMA_NOW_R::new((self.bits >> 1) & 0x3fff)
            }
        }
        ///RO, ADC DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_now](index.html) module
        pub struct ADC_DMA_NOW_SPEC;
        impl crate::RegisterSpec for ADC_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_now::R](R) reader structure
        impl crate::Readable for ADC_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_DMA_NOW to value 0
        impl crate::Resettable for ADC_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_BEG (rw) register accessor: an alias for `Reg<ADC_DMA_BEG_SPEC>`
    pub type ADC_DMA_BEG = crate::Reg<adc_dma_beg::ADC_DMA_BEG_SPEC>;
    ///RW, ADC DMA begin address
    pub mod adc_dma_beg {
        ///Register `ADC_DMA_BEG` reader
        pub struct R(crate::R<ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_BEG` writer
        pub struct W(crate::W<ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_BEG` reader - ADC DMA begin address
        pub type ADC_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_BEG` writer - ADC DMA begin address
        pub type ADC_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, ADC_DMA_BEG_SPEC, 14, O, u16>;
        impl R {
            ///Bits 1:14 - ADC DMA begin address
            #[inline(always)]
            pub fn adc_dma_beg(&self) -> ADC_DMA_BEG_R {
                ADC_DMA_BEG_R::new((self.bits >> 1) & 0x3fff)
            }
        }
        impl W {
            ///Bits 1:14 - ADC DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_beg(&mut self) -> ADC_DMA_BEG_W<1> {
                ADC_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_beg](index.html) module
        pub struct ADC_DMA_BEG_SPEC;
        impl crate::RegisterSpec for ADC_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_beg::R](R) reader structure
        impl crate::Readable for ADC_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_beg::W](W) writer structure
        impl crate::Writable for ADC_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_BEG to value 0
        impl crate::Resettable for ADC_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_END (rw) register accessor: an alias for `Reg<ADC_DMA_END_SPEC>`
    pub type ADC_DMA_END = crate::Reg<adc_dma_end::ADC_DMA_END_SPEC>;
    ///RW, ADC DMA end address
    pub mod adc_dma_end {
        ///Register `ADC_DMA_END` reader
        pub struct R(crate::R<ADC_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_END` writer
        pub struct W(crate::W<ADC_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_END` reader - ADC DMA end address
        pub type ADC_DMA_END_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_END` writer - ADC DMA end address
        pub type ADC_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, ADC_DMA_END_SPEC, 14, O, u16>;
        impl R {
            ///Bits 1:14 - ADC DMA end address
            #[inline(always)]
            pub fn adc_dma_end(&self) -> ADC_DMA_END_R {
                ADC_DMA_END_R::new((self.bits >> 1) & 0x3fff)
            }
        }
        impl W {
            ///Bits 1:14 - ADC DMA end address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_end(&mut self) -> ADC_DMA_END_W<1> {
                ADC_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_end](index.html) module
        pub struct ADC_DMA_END_SPEC;
        impl crate::RegisterSpec for ADC_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_end::R](R) reader structure
        impl crate::Readable for ADC_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_end::W](W) writer structure
        impl crate::Writable for ADC_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_END to value 0
        impl crate::Resettable for ADC_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General porpose intput output
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    ///Pointer to the register block
    pub const PTR: *const gpio::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
///General porpose intput output
pub mod gpio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x90],
        ///0x90 - RW, GPIO PA interrupt enable
        pub pa_int_en: PA_INT_EN,
        ///0x92 - RW, GPIO PB interrupt enable
        pub pb_int_en: PB_INT_EN,
        ///0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        pub pa_int_mode: PA_INT_MODE,
        ///0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        pub pb_int_mode: PB_INT_MODE,
        _reserved4: [u8; 0x04],
        ///0x9c - RW1, GPIO PA interrupt flag
        pub pa_int_if: PA_INT_IF,
        ///0x9e - RW1, GPIO PB interrupt flag
        pub pb_int_if: PB_INT_IF,
        ///0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out
        pub pa_dir: PA_DIR,
        ///0xa4 - RO, GPIO PA input
        pub pa_pin: PA_PIN,
        ///0xa8 - RW, GPIO PA output
        pub pa_out: PA_OUT,
        ///0xac - WZ, GPIO PA clear output: 0=keep, 1=clear
        pub pa_clr: PA_CLR,
        ///0xb0 - RW, GPIO PA pullup resistance enable
        pub pa_pu: PA_PU,
        ///0xb4 - RW, PA pulldown for input or PA driving capability for output
        pub pa_pd_drv: PA_PD_DRV,
        _reserved12: [u8; 0x08],
        ///0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out
        pub pb_dir: PB_DIR,
        ///0xc4 - RO, GPIO PB input
        pub pb_pin: PB_PIN,
        ///0xc8 - RW, GPIO PB output;RW, data for parallel slave read
        pub pb_out: PB_OUT,
        ///0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear
        pub pb_clr: PB_CLR,
        ///0xd0 - RW, GPIO PB pullup resistance enable
        pub pb_pu: PB_PU,
        ///0xd4 - RW, PB pulldown for input or PB driving capability for output
        pub pb_pd_drv: PB_PD_DRV,
    }
    ///PA_INT_EN (rw) register accessor: an alias for `Reg<PA_INT_EN_SPEC>`
    pub type PA_INT_EN = crate::Reg<pa_int_en::PA_INT_EN_SPEC>;
    ///RW, GPIO PA interrupt enable
    pub mod pa_int_en {
        ///Register `PA_INT_EN` reader
        pub struct R(crate::R<PA_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_EN` writer
        pub struct W(crate::W<PA_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_EN` reader - GPIO PA interrupt enable
        pub type PA_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PA_INT_EN` writer - GPIO PA interrupt enable
        pub type PA_INT_EN_W<'a, const O: u8> = crate::FieldWriter<'a, PA_INT_EN_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            pub fn pa_int_en(&self) -> PA_INT_EN_R {
                PA_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pa_int_en(&mut self) -> PA_INT_EN_W<0> {
                PA_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_en](index.html) module
        pub struct PA_INT_EN_SPEC;
        impl crate::RegisterSpec for PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_en::R](R) reader structure
        impl crate::Readable for PA_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_en::W](W) writer structure
        impl crate::Writable for PA_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_EN to value 0
        impl crate::Resettable for PA_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_EN (rw) register accessor: an alias for `Reg<PB_INT_EN_SPEC>`
    pub type PB_INT_EN = crate::Reg<pb_int_en::PB_INT_EN_SPEC>;
    ///RW, GPIO PB interrupt enable
    pub mod pb_int_en {
        ///Register `PB_INT_EN` reader
        pub struct R(crate::R<PB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_EN` writer
        pub struct W(crate::W<PB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_EN` reader - GPIO PB interrupt enable
        pub type PB_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PB_INT_EN` writer - GPIO PB interrupt enable
        pub type PB_INT_EN_W<'a, const O: u8> = crate::FieldWriter<'a, PB_INT_EN_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            pub fn pb_int_en(&self) -> PB_INT_EN_R {
                PB_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pb_int_en(&mut self) -> PB_INT_EN_W<0> {
                PB_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_en](index.html) module
        pub struct PB_INT_EN_SPEC;
        impl crate::RegisterSpec for PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_en::R](R) reader structure
        impl crate::Readable for PB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_en::W](W) writer structure
        impl crate::Writable for PB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_EN to value 0
        impl crate::Resettable for PB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_INT_MODE (rw) register accessor: an alias for `Reg<PA_INT_MODE_SPEC>`
    pub type PA_INT_MODE = crate::Reg<pa_int_mode::PA_INT_MODE_SPEC>;
    ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    pub mod pa_int_mode {
        ///Register `PA_INT_MODE` reader
        pub struct R(crate::R<PA_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_MODE` writer
        pub struct W(crate::W<PA_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_MODE` reader - GPIO PA interrupt mode
        pub type PA_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PA_INT_MODE` writer - GPIO PA interrupt mode
        pub type PA_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, PA_INT_MODE_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            pub fn pa_int_mode(&self) -> PA_INT_MODE_R {
                PA_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pa_int_mode(&mut self) -> PA_INT_MODE_W<0> {
                PA_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_mode](index.html) module
        pub struct PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_mode::R](R) reader structure
        impl crate::Readable for PA_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_mode::W](W) writer structure
        impl crate::Writable for PA_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_MODE to value 0
        impl crate::Resettable for PA_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_MODE (rw) register accessor: an alias for `Reg<PB_INT_MODE_SPEC>`
    pub type PB_INT_MODE = crate::Reg<pb_int_mode::PB_INT_MODE_SPEC>;
    ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    pub mod pb_int_mode {
        ///Register `PB_INT_MODE` reader
        pub struct R(crate::R<PB_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_MODE` writer
        pub struct W(crate::W<PB_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_MODE` reader - GPIO PB interrupt mode
        pub type PB_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PB_INT_MODE` writer - GPIO PB interrupt mode
        pub type PB_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, PB_INT_MODE_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            pub fn pb_int_mode(&self) -> PB_INT_MODE_R {
                PB_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pb_int_mode(&mut self) -> PB_INT_MODE_W<0> {
                PB_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_mode](index.html) module
        pub struct PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_mode::R](R) reader structure
        impl crate::Readable for PB_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_mode::W](W) writer structure
        impl crate::Writable for PB_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_MODE to value 0
        impl crate::Resettable for PB_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_INT_IF (rw) register accessor: an alias for `Reg<PA_INT_IF_SPEC>`
    pub type PA_INT_IF = crate::Reg<pa_int_if::PA_INT_IF_SPEC>;
    ///RW1, GPIO PA interrupt flag
    pub mod pa_int_if {
        ///Register `PA_INT_IF` reader
        pub struct R(crate::R<PA_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_IF` writer
        pub struct W(crate::W<PA_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_IF` reader - GPIO PA interrupt flag
        pub type PA_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PA_INT_IF` writer - GPIO PA interrupt flag
        pub type PA_INT_IF_W<'a, const O: u8> = crate::FieldWriter<'a, PA_INT_IF_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            pub fn pa_int_if(&self) -> PA_INT_IF_R {
                PA_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa_int_if(&mut self) -> PA_INT_IF_W<0> {
                PA_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PA interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_if](index.html) module
        pub struct PA_INT_IF_SPEC;
        impl crate::RegisterSpec for PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_if::R](R) reader structure
        impl crate::Readable for PA_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_if::W](W) writer structure
        impl crate::Writable for PA_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_IF to value 0
        impl crate::Resettable for PA_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_IF (rw) register accessor: an alias for `Reg<PB_INT_IF_SPEC>`
    pub type PB_INT_IF = crate::Reg<pb_int_if::PB_INT_IF_SPEC>;
    ///RW1, GPIO PB interrupt flag
    pub mod pb_int_if {
        ///Register `PB_INT_IF` reader
        pub struct R(crate::R<PB_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_IF` writer
        pub struct W(crate::W<PB_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_IF` reader - GPIO PB interrupt flag
        pub type PB_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PB_INT_IF` writer - GPIO PB interrupt flag
        pub type PB_INT_IF_W<'a, const O: u8> = crate::FieldWriter<'a, PB_INT_IF_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            pub fn pb_int_if(&self) -> PB_INT_IF_R {
                PB_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb_int_if(&mut self) -> PB_INT_IF_W<0> {
                PB_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_if](index.html) module
        pub struct PB_INT_IF_SPEC;
        impl crate::RegisterSpec for PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_if::R](R) reader structure
        impl crate::Readable for PB_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_if::W](W) writer structure
        impl crate::Writable for PB_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_IF to value 0
        impl crate::Resettable for PB_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_DIR (rw) register accessor: an alias for `Reg<PA_DIR_SPEC>`
    pub type PA_DIR = crate::Reg<pa_dir::PA_DIR_SPEC>;
    ///RW, GPIO PA I/O direction: 0=in, 1=out
    pub mod pa_dir {
        ///Register `PA_DIR` reader
        pub struct R(crate::R<PA_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_DIR` writer
        pub struct W(crate::W<PA_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_DIR` reader - GPIO PA I/O direction
        pub type PA_DIR_R = crate::FieldReader<u16>;
        ///Field `PA_DIR` writer - GPIO PA I/O direction
        pub type PA_DIR_W<'a, const O: u8> = crate::FieldWriter<'a, PA_DIR_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA I/O direction
            #[inline(always)]
            pub fn pa_dir(&self) -> PA_DIR_R {
                PA_DIR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA I/O direction
            #[inline(always)]
            #[must_use]
            pub fn pa_dir(&mut self) -> PA_DIR_W<0> {
                PA_DIR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_dir](index.html) module
        pub struct PA_DIR_SPEC;
        impl crate::RegisterSpec for PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_dir::R](R) reader structure
        impl crate::Readable for PA_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_dir::W](W) writer structure
        impl crate::Writable for PA_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_DIR to value 0
        impl crate::Resettable for PA_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PIN (r) register accessor: an alias for `Reg<PA_PIN_SPEC>`
    pub type PA_PIN = crate::Reg<pa_pin::PA_PIN_SPEC>;
    ///RO, GPIO PA input
    pub mod pa_pin {
        ///Register `PA_PIN` reader
        pub struct R(crate::R<PA_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PA_PIN` reader - GPIO PA input data
        pub type PA_PIN_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - GPIO PA input data
            #[inline(always)]
            pub fn pa_pin(&self) -> PA_PIN_R {
                PA_PIN_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///RO, GPIO PA input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pin](index.html) module
        pub struct PA_PIN_SPEC;
        impl crate::RegisterSpec for PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pin::R](R) reader structure
        impl crate::Readable for PA_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PA_PIN to value 0
        impl crate::Resettable for PA_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_OUT (rw) register accessor: an alias for `Reg<PA_OUT_SPEC>`
    pub type PA_OUT = crate::Reg<pa_out::PA_OUT_SPEC>;
    ///RW, GPIO PA output
    pub mod pa_out {
        ///Register `PA_OUT` reader
        pub struct R(crate::R<PA_OUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_OUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_OUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_OUT` writer
        pub struct W(crate::W<PA_OUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_OUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_OUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_OUT` reader - GPIO PA output data
        pub type PA_OUT_R = crate::FieldReader<u16>;
        ///Field `PA_OUT` writer - GPIO PA output data
        pub type PA_OUT_W<'a, const O: u8> = crate::FieldWriter<'a, PA_OUT_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA output data
            #[inline(always)]
            pub fn pa_out(&self) -> PA_OUT_R {
                PA_OUT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA output data
            #[inline(always)]
            #[must_use]
            pub fn pa_out(&mut self) -> PA_OUT_W<0> {
                PA_OUT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_out](index.html) module
        pub struct PA_OUT_SPEC;
        impl crate::RegisterSpec for PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_out::R](R) reader structure
        impl crate::Readable for PA_OUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_out::W](W) writer structure
        impl crate::Writable for PA_OUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_OUT to value 0
        impl crate::Resettable for PA_OUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_CLR (w) register accessor: an alias for `Reg<PA_CLR_SPEC>`
    pub type PA_CLR = crate::Reg<pa_clr::PA_CLR_SPEC>;
    ///WZ, GPIO PA clear output: 0=keep, 1=clear
    pub mod pa_clr {
        ///Register `PA_CLR` writer
        pub struct W(crate::W<PA_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_CLR` writer - GPIO PA output clear
        pub type PA_CLR_W<'a, const O: u8> = crate::FieldWriter<'a, PA_CLR_SPEC, 16, O, u16>;
        impl W {
            ///Bits 0:15 - GPIO PA output clear
            #[inline(always)]
            #[must_use]
            pub fn pa_clr(&mut self) -> PA_CLR_W<0> {
                PA_CLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PA clear output: 0=keep, 1=clear
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_clr](index.html) module
        pub struct PA_CLR_SPEC;
        impl crate::RegisterSpec for PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pa_clr::W](W) writer structure
        impl crate::Writable for PA_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_CLR to value 0
        impl crate::Resettable for PA_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PU (rw) register accessor: an alias for `Reg<PA_PU_SPEC>`
    pub type PA_PU = crate::Reg<pa_pu::PA_PU_SPEC>;
    ///RW, GPIO PA pullup resistance enable
    pub mod pa_pu {
        ///Register `PA_PU` reader
        pub struct R(crate::R<PA_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_PU` writer
        pub struct W(crate::W<PA_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_PU` reader - GPIO PA pull-up enable
        pub type PA_PU_R = crate::FieldReader<u16>;
        ///Field `PA_PU` writer - GPIO PA pull-up enable
        pub type PA_PU_W<'a, const O: u8> = crate::FieldWriter<'a, PA_PU_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA pull-up enable
            #[inline(always)]
            pub fn pa_pu(&self) -> PA_PU_R {
                PA_PU_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn pa_pu(&mut self) -> PA_PU_W<0> {
                PA_PU_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pu](index.html) module
        pub struct PA_PU_SPEC;
        impl crate::RegisterSpec for PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pu::R](R) reader structure
        impl crate::Readable for PA_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_pu::W](W) writer structure
        impl crate::Writable for PA_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_PU to value 0
        impl crate::Resettable for PA_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PD_DRV (rw) register accessor: an alias for `Reg<PA_PD_DRV_SPEC>`
    pub type PA_PD_DRV = crate::Reg<pa_pd_drv::PA_PD_DRV_SPEC>;
    ///RW, PA pulldown for input or PA driving capability for output
    pub mod pa_pd_drv {
        ///Register `PA_PD_DRV` reader
        pub struct R(crate::R<PA_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_PD_DRV` writer
        pub struct W(crate::W<PA_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_PD_DRV` reader - GPIO PA pull-down drive strength
        pub type PA_PD_DRV_R = crate::FieldReader<u16>;
        ///Field `PA_PD_DRV` writer - GPIO PA pull-down drive strength
        pub type PA_PD_DRV_W<'a, const O: u8> = crate::FieldWriter<'a, PA_PD_DRV_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA pull-down drive strength
            #[inline(always)]
            pub fn pa_pd_drv(&self) -> PA_PD_DRV_R {
                PA_PD_DRV_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA pull-down drive strength
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv(&mut self) -> PA_PD_DRV_W<0> {
                PA_PD_DRV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PA pulldown for input or PA driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pd_drv](index.html) module
        pub struct PA_PD_DRV_SPEC;
        impl crate::RegisterSpec for PA_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pd_drv::R](R) reader structure
        impl crate::Readable for PA_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_pd_drv::W](W) writer structure
        impl crate::Writable for PA_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_PD_DRV to value 0
        impl crate::Resettable for PA_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_DIR (rw) register accessor: an alias for `Reg<PB_DIR_SPEC>`
    pub type PB_DIR = crate::Reg<pb_dir::PB_DIR_SPEC>;
    ///RW, GPIO PB I/O direction: 0=in, 1=out
    pub mod pb_dir {
        ///Register `PB_DIR` reader
        pub struct R(crate::R<PB_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_DIR` writer
        pub struct W(crate::W<PB_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_DIR` reader - GPIO PB I/O direction
        pub type PB_DIR_R = crate::FieldReader<u32>;
        ///Field `PB_DIR` writer - GPIO PB I/O direction
        pub type PB_DIR_W<'a, const O: u8> = crate::FieldWriter<'a, PB_DIR_SPEC, 24, O, u32>;
        impl R {
            ///Bits 0:23 - GPIO PB I/O direction
            #[inline(always)]
            pub fn pb_dir(&self) -> PB_DIR_R {
                PB_DIR_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO PB I/O direction
            #[inline(always)]
            #[must_use]
            pub fn pb_dir(&mut self) -> PB_DIR_W<0> {
                PB_DIR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_dir](index.html) module
        pub struct PB_DIR_SPEC;
        impl crate::RegisterSpec for PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_dir::R](R) reader structure
        impl crate::Readable for PB_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_dir::W](W) writer structure
        impl crate::Writable for PB_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_DIR to value 0
        impl crate::Resettable for PB_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PIN (r) register accessor: an alias for `Reg<PB_PIN_SPEC>`
    pub type PB_PIN = crate::Reg<pb_pin::PB_PIN_SPEC>;
    ///RO, GPIO PB input
    pub mod pb_pin {
        ///Register `PB_PIN` reader
        pub struct R(crate::R<PB_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PB_PIN_0` reader - GPIO PB input byte 0
        pub type PB_PIN_0_R = crate::FieldReader;
        ///Field `PB_PIN_1` reader - GPIO PB input byte 1
        pub type PB_PIN_1_R = crate::FieldReader;
        ///Field `PB_PIN_2` reader - GPIO PB input byte 2
        pub type PB_PIN_2_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - GPIO PB input byte 0
            #[inline(always)]
            pub fn pb_pin_0(&self) -> PB_PIN_0_R {
                PB_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB input byte 1
            #[inline(always)]
            pub fn pb_pin_1(&self) -> PB_PIN_1_R {
                PB_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB input byte 2
            #[inline(always)]
            pub fn pb_pin_2(&self) -> PB_PIN_2_R {
                PB_PIN_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///RO, GPIO PB input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pin](index.html) module
        pub struct PB_PIN_SPEC;
        impl crate::RegisterSpec for PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pin::R](R) reader structure
        impl crate::Readable for PB_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PB_PIN to value 0
        impl crate::Resettable for PB_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_OUT (rw) register accessor: an alias for `Reg<PB_OUT_SPEC>`
    pub type PB_OUT = crate::Reg<pb_out::PB_OUT_SPEC>;
    ///RW, GPIO PB output;RW, data for parallel slave read
    pub mod pb_out {
        ///Register `PB_OUT` reader
        pub struct R(crate::R<PB_OUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_OUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_OUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_OUT` writer
        pub struct W(crate::W<PB_OUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_OUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_OUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_OUT` reader - GPIO PB output data
        pub type PB_OUT_R = crate::FieldReader<u32>;
        ///Field `PB_OUT` writer - GPIO PB output data
        pub type PB_OUT_W<'a, const O: u8> = crate::FieldWriter<'a, PB_OUT_SPEC, 24, O, u32>;
        impl R {
            ///Bits 0:23 - GPIO PB output data
            #[inline(always)]
            pub fn pb_out(&self) -> PB_OUT_R {
                PB_OUT_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO PB output data
            #[inline(always)]
            #[must_use]
            pub fn pb_out(&mut self) -> PB_OUT_W<0> {
                PB_OUT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB output;RW, data for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_out](index.html) module
        pub struct PB_OUT_SPEC;
        impl crate::RegisterSpec for PB_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_out::R](R) reader structure
        impl crate::Readable for PB_OUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_out::W](W) writer structure
        impl crate::Writable for PB_OUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_OUT to value 0
        impl crate::Resettable for PB_OUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_CLR (rw) register accessor: an alias for `Reg<PB_CLR_SPEC>`
    pub type PB_CLR = crate::Reg<pb_clr::PB_CLR_SPEC>;
    ///WZ, GPIO PB clear output: 0=keep, 1=clear
    pub mod pb_clr {
        ///Register `PB_CLR` reader
        pub struct R(crate::R<PB_CLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_CLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_CLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_CLR` writer
        pub struct W(crate::W<PB_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_CLR` reader - GPIO PB output clear
        pub type PB_CLR_R = crate::FieldReader<u32>;
        ///Field `PB_CLR` writer - GPIO PB output clear
        pub type PB_CLR_W<'a, const O: u8> = crate::FieldWriter<'a, PB_CLR_SPEC, 24, O, u32>;
        impl R {
            ///Bits 0:23 - GPIO PB output clear
            #[inline(always)]
            pub fn pb_clr(&self) -> PB_CLR_R {
                PB_CLR_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO PB output clear
            #[inline(always)]
            #[must_use]
            pub fn pb_clr(&mut self) -> PB_CLR_W<0> {
                PB_CLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PB clear output: 0=keep, 1=clear
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_clr](index.html) module
        pub struct PB_CLR_SPEC;
        impl crate::RegisterSpec for PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_clr::R](R) reader structure
        impl crate::Readable for PB_CLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_clr::W](W) writer structure
        impl crate::Writable for PB_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_CLR to value 0
        impl crate::Resettable for PB_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PU (rw) register accessor: an alias for `Reg<PB_PU_SPEC>`
    pub type PB_PU = crate::Reg<pb_pu::PB_PU_SPEC>;
    ///RW, GPIO PB pullup resistance enable
    pub mod pb_pu {
        ///Register `PB_PU` reader
        pub struct R(crate::R<PB_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_PU` writer
        pub struct W(crate::W<PB_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_PU` reader - GPIO PB pull-up enable
        pub type PB_PU_R = crate::FieldReader<u32>;
        ///Field `PB_PU` writer - GPIO PB pull-up enable
        pub type PB_PU_W<'a, const O: u8> = crate::FieldWriter<'a, PB_PU_SPEC, 24, O, u32>;
        impl R {
            ///Bits 0:23 - GPIO PB pull-up enable
            #[inline(always)]
            pub fn pb_pu(&self) -> PB_PU_R {
                PB_PU_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO PB pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn pb_pu(&mut self) -> PB_PU_W<0> {
                PB_PU_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pu](index.html) module
        pub struct PB_PU_SPEC;
        impl crate::RegisterSpec for PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pu::R](R) reader structure
        impl crate::Readable for PB_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_pu::W](W) writer structure
        impl crate::Writable for PB_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_PU to value 0
        impl crate::Resettable for PB_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PD_DRV (rw) register accessor: an alias for `Reg<PB_PD_DRV_SPEC>`
    pub type PB_PD_DRV = crate::Reg<pb_pd_drv::PB_PD_DRV_SPEC>;
    ///RW, PB pulldown for input or PB driving capability for output
    pub mod pb_pd_drv {
        ///Register `PB_PD_DRV` reader
        pub struct R(crate::R<PB_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_PD_DRV` writer
        pub struct W(crate::W<PB_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_PD_DRV` reader - GPIO PB pull-down drive strength
        pub type PB_PD_DRV_R = crate::FieldReader<u32>;
        ///Field `PB_PD_DRV` writer - GPIO PB pull-down drive strength
        pub type PB_PD_DRV_W<'a, const O: u8> = crate::FieldWriter<'a, PB_PD_DRV_SPEC, 24, O, u32>;
        impl R {
            ///Bits 0:23 - GPIO PB pull-down drive strength
            #[inline(always)]
            pub fn pb_pd_drv(&self) -> PB_PD_DRV_R {
                PB_PD_DRV_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO PB pull-down drive strength
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv(&mut self) -> PB_PD_DRV_W<0> {
                PB_PD_DRV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PB pulldown for input or PB driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pd_drv](index.html) module
        pub struct PB_PD_DRV_SPEC;
        impl crate::RegisterSpec for PB_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pd_drv::R](R) reader structure
        impl crate::Readable for PB_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_pd_drv::W](W) writer structure
        impl crate::Writable for PB_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_PD_DRV to value 0
        impl crate::Resettable for PB_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///Timer0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR0 mode control
        pub tmr0_ctrl_mod: TMR0_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR0 interrupt enable
        pub tmr0_inter_en: TMR0_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR0 interrupt flag
        pub tmr0_int_flag: TMR0_INT_FLAG,
        ///0x07 - RO, TMR0 FIFO count status
        pub tmr0_fifo_count: TMR0_FIFO_COUNT,
        ///0x08 - RO, TMR0 current count
        pub tmr0_count: TMR0_COUNT,
        ///0x0c - RW, TMR0 end count value, only low 26 bit
        pub tmr0_cnt_end: TMR0_CNT_END,
        ///0x10 - RO/WO, TMR0 FIFO register, only low 26 bit
        pub tmr0_fifo: TMR0_FIFO,
    }
    ///TMR0_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR0_CTRL_MOD_SPEC>`
    pub type TMR0_CTRL_MOD = crate::Reg<tmr0_ctrl_mod::TMR0_CTRL_MOD_SPEC>;
    ///RW, TMR0 mode control
    pub mod tmr0_ctrl_mod {
        ///Register `TMR0_CTRL_MOD` reader
        pub struct R(crate::R<TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_CTRL_MOD` writer
        pub struct W(crate::W<TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_CTRL_MOD_SPEC, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_CTRL_MOD_SPEC, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, TMR0_CTRL_MOD_SPEC, O>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR0_CTRL_MOD_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_ctrl_mod](index.html) module
        pub struct TMR0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR0_INTER_EN (rw) register accessor: an alias for `Reg<TMR0_INTER_EN_SPEC>`
    pub type TMR0_INTER_EN = crate::Reg<tmr0_inter_en::TMR0_INTER_EN_SPEC>;
    ///RW, TMR0 interrupt enable
    pub mod tmr0_inter_en {
        ///Register `TMR0_INTER_EN` reader
        pub struct R(crate::R<TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_INTER_EN` writer
        pub struct W(crate::W<TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INTER_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_inter_en](index.html) module
        pub struct TMR0_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_inter_en::R](R) reader structure
        impl crate::Readable for TMR0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_inter_en::W](W) writer structure
        impl crate::Writable for TMR0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_INTER_EN to value 0
        impl crate::Resettable for TMR0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_INT_FLAG (rw) register accessor: an alias for `Reg<TMR0_INT_FLAG_SPEC>`
    pub type TMR0_INT_FLAG = crate::Reg<tmr0_int_flag::TMR0_INT_FLAG_SPEC>;
    ///RW1, TMR0 interrupt flag
    pub mod tmr0_int_flag {
        ///Register `TMR0_INT_FLAG` reader
        pub struct R(crate::R<TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_INT_FLAG` writer
        pub struct W(crate::W<TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR0_INT_FLAG_SPEC, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_int_flag](index.html) module
        pub struct TMR0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_int_flag::R](R) reader structure
        impl crate::Readable for TMR0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_int_flag::W](W) writer structure
        impl crate::Writable for TMR0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_INT_FLAG to value 0
        impl crate::Resettable for TMR0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR0_FIFO_COUNT_SPEC>`
    pub type TMR0_FIFO_COUNT = crate::Reg<tmr0_fifo_count::TMR0_FIFO_COUNT_SPEC>;
    ///RO, TMR0 FIFO count status
    pub mod tmr0_fifo_count {
        ///Register `TMR0_FIFO_COUNT` reader
        pub struct R(crate::R<TMR0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_FIFO_COUNT` reader - R0,TMR0 FIFO count status
        pub type TMR0_FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - R0,TMR0 FIFO count status
            #[inline(always)]
            pub fn tmr0_fifo_count(&self) -> TMR0_FIFO_COUNT_R {
                TMR0_FIFO_COUNT_R::new(self.bits & 0x0f)
            }
        }
        ///RO, TMR0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_fifo_count](index.html) module
        pub struct TMR0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_fifo_count::R](R) reader structure
        impl crate::Readable for TMR0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_FIFO_COUNT to value 0
        impl crate::Resettable for TMR0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_COUNT (r) register accessor: an alias for `Reg<TMR0_COUNT_SPEC>`
    pub type TMR0_COUNT = crate::Reg<tmr0_count::TMR0_COUNT_SPEC>;
    ///RO, TMR0 current count
    pub mod tmr0_count {
        ///Register `TMR0_COUNT` reader
        pub struct R(crate::R<TMR0_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_COUNT` reader - RW1,TMR0 current count
        pub type TMR0_COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:25 - RW1,TMR0 current count
            #[inline(always)]
            pub fn tmr0_count(&self) -> TMR0_COUNT_R {
                TMR0_COUNT_R::new(self.bits & 0x03ff_ffff)
            }
        }
        ///RO, TMR0 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_count](index.html) module
        pub struct TMR0_COUNT_SPEC;
        impl crate::RegisterSpec for TMR0_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_count::R](R) reader structure
        impl crate::Readable for TMR0_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_COUNT to value 0
        impl crate::Resettable for TMR0_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_CNT_END (rw) register accessor: an alias for `Reg<TMR0_CNT_END_SPEC>`
    pub type TMR0_CNT_END = crate::Reg<tmr0_cnt_end::TMR0_CNT_END_SPEC>;
    ///RW, TMR0 end count value, only low 26 bit
    pub mod tmr0_cnt_end {
        ///Register `TMR0_CNT_END` reader
        pub struct R(crate::R<TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_CNT_END` writer
        pub struct W(crate::W<TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR0_CNT_END` reader - RW1,TMR0 end count value
        pub type TMR0_CNT_END_R = crate::FieldReader<u32>;
        ///Field `TMR0_CNT_END` writer - RW1,TMR0 end count value
        pub type TMR0_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR0_CNT_END_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            pub fn tmr0_cnt_end(&self) -> TMR0_CNT_END_R {
                TMR0_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            #[must_use]
            pub fn tmr0_cnt_end(&mut self) -> TMR0_CNT_END_W<0> {
                TMR0_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_cnt_end](index.html) module
        pub struct TMR0_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR0_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_cnt_end::R](R) reader structure
        impl crate::Readable for TMR0_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_cnt_end::W](W) writer structure
        impl crate::Writable for TMR0_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_CNT_END to value 0
        impl crate::Resettable for TMR0_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_FIFO (r) register accessor: an alias for `Reg<TMR0_FIFO_SPEC>`
    pub type TMR0_FIFO = crate::Reg<tmr0_fifo::TMR0_FIFO_SPEC>;
    ///RO/WO, TMR0 FIFO register, only low 26 bit
    pub mod tmr0_fifo {
        ///Register `TMR0_FIFO` reader
        pub struct R(crate::R<TMR0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_FIFO` reader - RW1,TMR0 FIFO register
        pub type TMR0_FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 FIFO register
            #[inline(always)]
            pub fn tmr0_fifo(&self) -> TMR0_FIFO_R {
                TMR0_FIFO_R::new(self.bits)
            }
        }
        ///RO/WO, TMR0 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_fifo](index.html) module
        pub struct TMR0_FIFO_SPEC;
        impl crate::RegisterSpec for TMR0_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_fifo::R](R) reader structure
        impl crate::Readable for TMR0_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_FIFO to value 0
        impl crate::Resettable for TMR0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///Timer1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR1 mode control
        pub tmr1_ctrl_mod: TMR1_CTRL_MOD,
        ///0x01 - RW, TMR1 DMA control
        pub tmr1_ctrl_dma: TMR1_CTRL_DMA,
        ///0x02 - RW, TMR1 interrupt enable
        pub tmr1_inter_en: TMR1_INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR1 interrupt flag
        pub tmr1_int_flag: TMR1_INT_FLAG,
        ///0x07 - RO, TMR1 FIFO count status
        pub tmr1_fifo_count: TMR1_FIFO_COUNT,
        ///0x08 - RO, TMR1 current count
        pub tmr1_count: TMR1_COUNT,
        ///0x0c - RW, TMR1 end count value, only low 26 bit
        pub tmr1_cnt_end: TMR1_CNT_END,
        ///0x10 - RO, TMR1 FIFO register, only low 26 bit
        pub tmr1_fifo: TMR1_FIFO,
        ///0x14 - RO, TMR1 DMA current address
        pub tmr1_dma_now: TMR1_DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR1 DMA begin address
        pub tmr1_dma_beg: TMR1_DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR1 DMA end address
        pub tmr1_dma_end: TMR1_DMA_END,
    }
    ///TMR1_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR1_CTRL_MOD_SPEC>`
    pub type TMR1_CTRL_MOD = crate::Reg<tmr1_ctrl_mod::TMR1_CTRL_MOD_SPEC>;
    ///RW, TMR1 mode control
    pub mod tmr1_ctrl_mod {
        ///Register `TMR1_CTRL_MOD` reader
        pub struct R(crate::R<TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CTRL_MOD` writer
        pub struct W(crate::W<TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_MOD_SPEC, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_MOD_SPEC, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, TMR1_CTRL_MOD_SPEC, O>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR1_CTRL_MOD_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_ctrl_mod](index.html) module
        pub struct TMR1_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR1_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR1_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR1_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR1_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR1_CTRL_DMA (rw) register accessor: an alias for `Reg<TMR1_CTRL_DMA_SPEC>`
    pub type TMR1_CTRL_DMA = crate::Reg<tmr1_ctrl_dma::TMR1_CTRL_DMA_SPEC>;
    ///RW, TMR1 DMA control
    pub mod tmr1_ctrl_dma {
        ///Register `TMR1_CTRL_DMA` reader
        pub struct R(crate::R<TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CTRL_DMA` writer
        pub struct W(crate::W<TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_DMA_SPEC, O>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_CTRL_DMA_SPEC, O>;
        impl R {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<0> {
                TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<2> {
                TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_ctrl_dma](index.html) module
        pub struct TMR1_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for TMR1_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_ctrl_dma::R](R) reader structure
        impl crate::Readable for TMR1_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_ctrl_dma::W](W) writer structure
        impl crate::Writable for TMR1_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CTRL_DMA to value 0
        impl crate::Resettable for TMR1_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_INTER_EN (rw) register accessor: an alias for `Reg<TMR1_INTER_EN_SPEC>`
    pub type TMR1_INTER_EN = crate::Reg<tmr1_inter_en::TMR1_INTER_EN_SPEC>;
    ///RW, TMR1 interrupt enable
    pub mod tmr1_inter_en {
        ///Register `TMR1_INTER_EN` reader
        pub struct R(crate::R<TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_INTER_EN` writer
        pub struct W(crate::W<TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INTER_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_inter_en](index.html) module
        pub struct TMR1_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR1_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_inter_en::R](R) reader structure
        impl crate::Readable for TMR1_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_inter_en::W](W) writer structure
        impl crate::Writable for TMR1_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_INTER_EN to value 0
        impl crate::Resettable for TMR1_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_INT_FLAG (rw) register accessor: an alias for `Reg<TMR1_INT_FLAG_SPEC>`
    pub type TMR1_INT_FLAG = crate::Reg<tmr1_int_flag::TMR1_INT_FLAG_SPEC>;
    ///RW1, TMR1 interrupt flag
    pub mod tmr1_int_flag {
        ///Register `TMR1_INT_FLAG` reader
        pub struct R(crate::R<TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_INT_FLAG` writer
        pub struct W(crate::W<TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR1_INT_FLAG_SPEC, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR1 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_int_flag](index.html) module
        pub struct TMR1_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR1_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_int_flag::R](R) reader structure
        impl crate::Readable for TMR1_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_int_flag::W](W) writer structure
        impl crate::Writable for TMR1_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_INT_FLAG to value 0
        impl crate::Resettable for TMR1_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR1_FIFO_COUNT_SPEC>`
    pub type TMR1_FIFO_COUNT = crate::Reg<tmr1_fifo_count::TMR1_FIFO_COUNT_SPEC>;
    ///RO, TMR1 FIFO count status
    pub mod tmr1_fifo_count {
        ///Register `TMR1_FIFO_COUNT` reader
        pub struct R(crate::R<TMR1_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_FIFO_COUNT` reader - RW1, TMR1 FIFO count status
        pub type TMR1_FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - RW1, TMR1 FIFO count status
            #[inline(always)]
            pub fn tmr1_fifo_count(&self) -> TMR1_FIFO_COUNT_R {
                TMR1_FIFO_COUNT_R::new(self.bits & 0x0f)
            }
        }
        ///RO, TMR1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_fifo_count](index.html) module
        pub struct TMR1_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR1_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_fifo_count::R](R) reader structure
        impl crate::Readable for TMR1_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_FIFO_COUNT to value 0
        impl crate::Resettable for TMR1_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_COUNT (r) register accessor: an alias for `Reg<TMR1_COUNT_SPEC>`
    pub type TMR1_COUNT = crate::Reg<tmr1_count::TMR1_COUNT_SPEC>;
    ///RO, TMR1 current count
    pub mod tmr1_count {
        ///Register `TMR1_COUNT` reader
        pub struct R(crate::R<TMR1_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_COUNT` reader - RW1,TMR1 current count
        pub type TMR1_COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:25 - RW1,TMR1 current count
            #[inline(always)]
            pub fn tmr1_count(&self) -> TMR1_COUNT_R {
                TMR1_COUNT_R::new(self.bits & 0x03ff_ffff)
            }
        }
        ///RO, TMR1 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_count](index.html) module
        pub struct TMR1_COUNT_SPEC;
        impl crate::RegisterSpec for TMR1_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_count::R](R) reader structure
        impl crate::Readable for TMR1_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_COUNT to value 0
        impl crate::Resettable for TMR1_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_CNT_END (rw) register accessor: an alias for `Reg<TMR1_CNT_END_SPEC>`
    pub type TMR1_CNT_END = crate::Reg<tmr1_cnt_end::TMR1_CNT_END_SPEC>;
    ///RW, TMR1 end count value, only low 26 bit
    pub mod tmr1_cnt_end {
        ///Register `TMR1_CNT_END` reader
        pub struct R(crate::R<TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CNT_END` writer
        pub struct W(crate::W<TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_CNT_END` reader - RW1,TMR1 end count value,
        pub type TMR1_CNT_END_R = crate::FieldReader<u32>;
        ///Field `TMR1_CNT_END` writer - RW1,TMR1 end count value,
        pub type TMR1_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR1_CNT_END_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            pub fn tmr1_cnt_end(&self) -> TMR1_CNT_END_R {
                TMR1_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            #[must_use]
            pub fn tmr1_cnt_end(&mut self) -> TMR1_CNT_END_W<0> {
                TMR1_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_cnt_end](index.html) module
        pub struct TMR1_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR1_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_cnt_end::R](R) reader structure
        impl crate::Readable for TMR1_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_cnt_end::W](W) writer structure
        impl crate::Writable for TMR1_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CNT_END to value 0
        impl crate::Resettable for TMR1_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_FIFO (r) register accessor: an alias for `Reg<TMR1_FIFO_SPEC>`
    pub type TMR1_FIFO = crate::Reg<tmr1_fifo::TMR1_FIFO_SPEC>;
    ///RO, TMR1 FIFO register, only low 26 bit
    pub mod tmr1_fifo {
        ///Register `TMR1_FIFO` reader
        pub struct R(crate::R<TMR1_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_FIFO` reader - RW1,TMR1 FIFO register
        pub type TMR1_FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn tmr1_fifo(&self) -> TMR1_FIFO_R {
                TMR1_FIFO_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_fifo](index.html) module
        pub struct TMR1_FIFO_SPEC;
        impl crate::RegisterSpec for TMR1_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_fifo::R](R) reader structure
        impl crate::Readable for TMR1_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_FIFO to value 0
        impl crate::Resettable for TMR1_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_NOW (r) register accessor: an alias for `Reg<TMR1_DMA_NOW_SPEC>`
    pub type TMR1_DMA_NOW = crate::Reg<tmr1_dma_now::TMR1_DMA_NOW_SPEC>;
    ///RO, TMR1 DMA current address
    pub mod tmr1_dma_now {
        ///Register `TMR1_DMA_NOW` reader
        pub struct R(crate::R<TMR1_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_DMA_NOW` reader - RO,DMA data buffer current address
        pub type TMR1_DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 2:14 - RO,DMA data buffer current address
            #[inline(always)]
            pub fn tmr1_dma_now(&self) -> TMR1_DMA_NOW_R {
                TMR1_DMA_NOW_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        ///RO, TMR1 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_now](index.html) module
        pub struct TMR1_DMA_NOW_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_now::R](R) reader structure
        impl crate::Readable for TMR1_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_DMA_NOW to value 0
        impl crate::Resettable for TMR1_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_BEG (rw) register accessor: an alias for `Reg<TMR1_DMA_BEG_SPEC>`
    pub type TMR1_DMA_BEG = crate::Reg<tmr1_dma_beg::TMR1_DMA_BEG_SPEC>;
    ///RW, TMR1 DMA begin address
    pub mod tmr1_dma_beg {
        ///Register `TMR1_DMA_BEG` reader
        pub struct R(crate::R<TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_DMA_BEG` writer
        pub struct W(crate::W<TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_DMA_BEG` reader - RW,TMR1 DMA data buffer start address
        pub type TMR1_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `TMR1_DMA_BEG` writer - RW,TMR1 DMA data buffer start address
        pub type TMR1_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR1_DMA_BEG_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,TMR1 DMA data buffer start address
            #[inline(always)]
            pub fn tmr1_dma_beg(&self) -> TMR1_DMA_BEG_R {
                TMR1_DMA_BEG_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,TMR1 DMA data buffer start address
            #[inline(always)]
            #[must_use]
            pub fn tmr1_dma_beg(&mut self) -> TMR1_DMA_BEG_W<2> {
                TMR1_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_beg](index.html) module
        pub struct TMR1_DMA_BEG_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_beg::R](R) reader structure
        impl crate::Readable for TMR1_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_dma_beg::W](W) writer structure
        impl crate::Writable for TMR1_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_DMA_BEG to value 0
        impl crate::Resettable for TMR1_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_END (rw) register accessor: an alias for `Reg<TMR1_DMA_END_SPEC>`
    pub type TMR1_DMA_END = crate::Reg<tmr1_dma_end::TMR1_DMA_END_SPEC>;
    ///RW, TMR1 DMA end address
    pub mod tmr1_dma_end {
        ///Register `TMR1_DMA_END` reader
        pub struct R(crate::R<TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_DMA_END` writer
        pub struct W(crate::W<TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_DMA_END` reader - RW,DMA data buffer end address
        pub type TMR1_DMA_END_R = crate::FieldReader<u16>;
        ///Field `TMR1_DMA_END` writer - RW,DMA data buffer end address
        pub type TMR1_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR1_DMA_END_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,DMA data buffer end address
            #[inline(always)]
            pub fn tmr1_dma_end(&self) -> TMR1_DMA_END_R {
                TMR1_DMA_END_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,DMA data buffer end address
            #[inline(always)]
            #[must_use]
            pub fn tmr1_dma_end(&mut self) -> TMR1_DMA_END_W<2> {
                TMR1_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_end](index.html) module
        pub struct TMR1_DMA_END_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_end::R](R) reader structure
        impl crate::Readable for TMR1_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_dma_end::W](W) writer structure
        impl crate::Writable for TMR1_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_DMA_END to value 0
        impl crate::Resettable for TMR1_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr2::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR2 {
    type Target = tmr2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///Timer2 register
pub mod tmr2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR2 mode control
        pub tmr2_ctrl_mod: TMR2_CTRL_MOD,
        ///0x01 - RW, TMR2 DMA control
        pub tmr2_ctrl_dma: TMR2_CTRL_DMA,
        ///0x02 - RW, TMR2 interrupt enable
        pub tmr2_inter_en: TMR2_INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR2 interrupt flag
        pub tmr2_int_flag: TMR2_INT_FLAG,
        ///0x07 - RO, TMR2 FIFO count status
        pub tmr2_fifo_count: TMR2_FIFO_COUNT,
        ///0x08 - RO, TMR2 current count
        pub tmr2_count: TMR2_COUNT,
        ///0x0c - RW, TMR2 end count value, only low 26 bit
        pub tmr2_cnt_end: TMR2_CNT_END,
        ///0x10 - RO, TMR2 FIFO register, only low 26 bit
        pub tmr2_fifo: TMR2_FIFO,
        ///0x14 - RO, TMR2 DMA current address
        pub tmr2_dma_now: TMR2_DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR2 DMA begin address
        pub tmr2_dma_beg: TMR2_DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR2 DMA end address
        pub tmr2_dma_end: TMR2_DMA_END,
    }
    ///TMR2_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR2_CTRL_MOD_SPEC>`
    pub type TMR2_CTRL_MOD = crate::Reg<tmr2_ctrl_mod::TMR2_CTRL_MOD_SPEC>;
    ///RW, TMR2 mode control
    pub mod tmr2_ctrl_mod {
        ///Register `TMR2_CTRL_MOD` reader
        pub struct R(crate::R<TMR2_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_CTRL_MOD` writer
        pub struct W(crate::W<TMR2_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_MOD_SPEC, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_MOD_SPEC, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, TMR2_CTRL_MOD_SPEC, O>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR2_CTRL_MOD_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_ctrl_mod](index.html) module
        pub struct TMR2_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR2_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr2_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR2_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR2_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR2_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR2_CTRL_DMA (rw) register accessor: an alias for `Reg<TMR2_CTRL_DMA_SPEC>`
    pub type TMR2_CTRL_DMA = crate::Reg<tmr2_ctrl_dma::TMR2_CTRL_DMA_SPEC>;
    ///RW, TMR2 DMA control
    pub mod tmr2_ctrl_dma {
        ///Register `TMR2_CTRL_DMA` reader
        pub struct R(crate::R<TMR2_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_CTRL_DMA` writer
        pub struct W(crate::W<TMR2_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_DMA_SPEC, O>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_CTRL_DMA_SPEC, O>;
        impl R {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<0> {
                TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<2> {
                TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_ctrl_dma](index.html) module
        pub struct TMR2_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for TMR2_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr2_ctrl_dma::R](R) reader structure
        impl crate::Readable for TMR2_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_ctrl_dma::W](W) writer structure
        impl crate::Writable for TMR2_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_CTRL_DMA to value 0
        impl crate::Resettable for TMR2_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_INTER_EN (rw) register accessor: an alias for `Reg<TMR2_INTER_EN_SPEC>`
    pub type TMR2_INTER_EN = crate::Reg<tmr2_inter_en::TMR2_INTER_EN_SPEC>;
    ///RW, TMR2 interrupt enable
    pub mod tmr2_inter_en {
        ///Register `TMR2_INTER_EN` reader
        pub struct R(crate::R<TMR2_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_INTER_EN` writer
        pub struct W(crate::W<TMR2_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INTER_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_inter_en](index.html) module
        pub struct TMR2_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR2_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr2_inter_en::R](R) reader structure
        impl crate::Readable for TMR2_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_inter_en::W](W) writer structure
        impl crate::Writable for TMR2_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_INTER_EN to value 0
        impl crate::Resettable for TMR2_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_INT_FLAG (rw) register accessor: an alias for `Reg<TMR2_INT_FLAG_SPEC>`
    pub type TMR2_INT_FLAG = crate::Reg<tmr2_int_flag::TMR2_INT_FLAG_SPEC>;
    ///RW1, TMR2 interrupt flag
    pub mod tmr2_int_flag {
        ///Register `TMR2_INT_FLAG` reader
        pub struct R(crate::R<TMR2_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_INT_FLAG` writer
        pub struct W(crate::W<TMR2_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR2_INT_FLAG_SPEC, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR2 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_int_flag](index.html) module
        pub struct TMR2_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR2_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr2_int_flag::R](R) reader structure
        impl crate::Readable for TMR2_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_int_flag::W](W) writer structure
        impl crate::Writable for TMR2_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_INT_FLAG to value 0
        impl crate::Resettable for TMR2_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR2_FIFO_COUNT_SPEC>`
    pub type TMR2_FIFO_COUNT = crate::Reg<tmr2_fifo_count::TMR2_FIFO_COUNT_SPEC>;
    ///RO, TMR2 FIFO count status
    pub mod tmr2_fifo_count {
        ///Register `TMR2_FIFO_COUNT` reader
        pub struct R(crate::R<TMR2_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_FIFO_COUNT` reader - RW, TMR2 FIFO count status
        pub type TMR2_FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - RW, TMR2 FIFO count status
            #[inline(always)]
            pub fn tmr2_fifo_count(&self) -> TMR2_FIFO_COUNT_R {
                TMR2_FIFO_COUNT_R::new(self.bits & 0x0f)
            }
        }
        ///RO, TMR2 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_fifo_count](index.html) module
        pub struct TMR2_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR2_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr2_fifo_count::R](R) reader structure
        impl crate::Readable for TMR2_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR2_FIFO_COUNT to value 0
        impl crate::Resettable for TMR2_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_COUNT (r) register accessor: an alias for `Reg<TMR2_COUNT_SPEC>`
    pub type TMR2_COUNT = crate::Reg<tmr2_count::TMR2_COUNT_SPEC>;
    ///RO, TMR2 current count
    pub mod tmr2_count {
        ///Register `TMR2_COUNT` reader
        pub struct R(crate::R<TMR2_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_COUNT` reader - RW, TMR2 current count
        pub type TMR2_COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:25 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_count(&self) -> TMR2_COUNT_R {
                TMR2_COUNT_R::new(self.bits & 0x03ff_ffff)
            }
        }
        ///RO, TMR2 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_count](index.html) module
        pub struct TMR2_COUNT_SPEC;
        impl crate::RegisterSpec for TMR2_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr2_count::R](R) reader structure
        impl crate::Readable for TMR2_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR2_COUNT to value 0
        impl crate::Resettable for TMR2_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_CNT_END (rw) register accessor: an alias for `Reg<TMR2_CNT_END_SPEC>`
    pub type TMR2_CNT_END = crate::Reg<tmr2_cnt_end::TMR2_CNT_END_SPEC>;
    ///RW, TMR2 end count value, only low 26 bit
    pub mod tmr2_cnt_end {
        ///Register `TMR2_CNT_END` reader
        pub struct R(crate::R<TMR2_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_CNT_END` writer
        pub struct W(crate::W<TMR2_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_COUNT` reader - RW, TMR2 current count
        pub type TMR2_COUNT_R = crate::FieldReader<u32>;
        ///Field `TMR2_COUNT` writer - RW, TMR2 current count
        pub type TMR2_COUNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR2_CNT_END_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_count(&self) -> TMR2_COUNT_R {
                TMR2_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn tmr2_count(&mut self) -> TMR2_COUNT_W<0> {
                TMR2_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_cnt_end](index.html) module
        pub struct TMR2_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR2_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr2_cnt_end::R](R) reader structure
        impl crate::Readable for TMR2_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_cnt_end::W](W) writer structure
        impl crate::Writable for TMR2_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_CNT_END to value 0
        impl crate::Resettable for TMR2_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_FIFO (rw) register accessor: an alias for `Reg<TMR2_FIFO_SPEC>`
    pub type TMR2_FIFO = crate::Reg<tmr2_fifo::TMR2_FIFO_SPEC>;
    ///RO, TMR2 FIFO register, only low 26 bit
    pub mod tmr2_fifo {
        ///Register `TMR2_FIFO` reader
        pub struct R(crate::R<TMR2_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_FIFO` writer
        pub struct W(crate::W<TMR2_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_FIFO` reader - RW, TMR2 current count
        pub type TMR2_FIFO_R = crate::FieldReader<u32>;
        ///Field `TMR2_FIFO` writer - RW, TMR2 current count
        pub type TMR2_FIFO_W<'a, const O: u8> = crate::FieldWriter<'a, TMR2_FIFO_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_fifo(&self) -> TMR2_FIFO_R {
                TMR2_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn tmr2_fifo(&mut self) -> TMR2_FIFO_W<0> {
                TMR2_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, TMR2 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_fifo](index.html) module
        pub struct TMR2_FIFO_SPEC;
        impl crate::RegisterSpec for TMR2_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr2_fifo::R](R) reader structure
        impl crate::Readable for TMR2_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_fifo::W](W) writer structure
        impl crate::Writable for TMR2_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_FIFO to value 0
        impl crate::Resettable for TMR2_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_DMA_NOW (r) register accessor: an alias for `Reg<TMR2_DMA_NOW_SPEC>`
    pub type TMR2_DMA_NOW = crate::Reg<tmr2_dma_now::TMR2_DMA_NOW_SPEC>;
    ///RO, TMR2 DMA current address
    pub mod tmr2_dma_now {
        ///Register `TMR2_DMA_NOW` reader
        pub struct R(crate::R<TMR2_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_DMA_NOW` reader - RO, DMA data buffer current address
        pub type TMR2_DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 2:14 - RO, DMA data buffer current address
            #[inline(always)]
            pub fn tmr2_dma_now(&self) -> TMR2_DMA_NOW_R {
                TMR2_DMA_NOW_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        ///RO, TMR2 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_dma_now](index.html) module
        pub struct TMR2_DMA_NOW_SPEC;
        impl crate::RegisterSpec for TMR2_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr2_dma_now::R](R) reader structure
        impl crate::Readable for TMR2_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR2_DMA_NOW to value 0
        impl crate::Resettable for TMR2_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_DMA_BEG (rw) register accessor: an alias for `Reg<TMR2_DMA_BEG_SPEC>`
    pub type TMR2_DMA_BEG = crate::Reg<tmr2_dma_beg::TMR2_DMA_BEG_SPEC>;
    ///RW, TMR2 DMA begin address
    pub mod tmr2_dma_beg {
        ///Register `TMR2_DMA_BEG` reader
        pub struct R(crate::R<TMR2_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_DMA_BEG` writer
        pub struct W(crate::W<TMR2_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_DMA_BEG` reader - RW, TMR2 DMA data buffer start address
        pub type TMR2_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `TMR2_DMA_BEG` writer - RW, TMR2 DMA data buffer start address
        pub type TMR2_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR2_DMA_BEG_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW, TMR2 DMA data buffer start address
            #[inline(always)]
            pub fn tmr2_dma_beg(&self) -> TMR2_DMA_BEG_R {
                TMR2_DMA_BEG_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW, TMR2 DMA data buffer start address
            #[inline(always)]
            #[must_use]
            pub fn tmr2_dma_beg(&mut self) -> TMR2_DMA_BEG_W<2> {
                TMR2_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_dma_beg](index.html) module
        pub struct TMR2_DMA_BEG_SPEC;
        impl crate::RegisterSpec for TMR2_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr2_dma_beg::R](R) reader structure
        impl crate::Readable for TMR2_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_dma_beg::W](W) writer structure
        impl crate::Writable for TMR2_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_DMA_BEG to value 0
        impl crate::Resettable for TMR2_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR2_DMA_END (rw) register accessor: an alias for `Reg<TMR2_DMA_END_SPEC>`
    pub type TMR2_DMA_END = crate::Reg<tmr2_dma_end::TMR2_DMA_END_SPEC>;
    ///RW, TMR2 DMA end address
    pub mod tmr2_dma_end {
        ///Register `TMR2_DMA_END` reader
        pub struct R(crate::R<TMR2_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR2_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR2_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR2_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR2_DMA_END` writer
        pub struct W(crate::W<TMR2_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR2_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR2_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR2_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_DMA_END` reader - RW, TMR2 DMA end address
        pub type TMR2_DMA_END_R = crate::FieldReader<u16>;
        ///Field `TMR2_DMA_END` writer - RW, TMR2 DMA end address
        pub type TMR2_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR2_DMA_END_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW, TMR2 DMA end address
            #[inline(always)]
            pub fn tmr2_dma_end(&self) -> TMR2_DMA_END_R {
                TMR2_DMA_END_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW, TMR2 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn tmr2_dma_end(&mut self) -> TMR2_DMA_END_W<2> {
                TMR2_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr2_dma_end](index.html) module
        pub struct TMR2_DMA_END_SPEC;
        impl crate::RegisterSpec for TMR2_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr2_dma_end::R](R) reader structure
        impl crate::Readable for TMR2_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr2_dma_end::W](W) writer structure
        impl crate::Writable for TMR2_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR2_DMA_END to value 0
        impl crate::Resettable for TMR2_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer3 register
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    ///Pointer to the register block
    pub const PTR: *const tmr3::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR3 {
    type Target = tmr3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
///Timer3 register
pub mod tmr3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR3 mode control
        pub tmr3_ctrl_mod: TMR3_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR3 interrupt enable
        pub tmr3_inter_en: TMR3_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR3 interrupt flag
        pub tmr3_int_flag: TMR3_INT_FLAG,
        ///0x07 - RO, TMR3 FIFO count status
        pub tmr3_fifo_count: TMR3_FIFO_COUNT,
        ///0x08 - RO, TMR3 current count
        pub tmr3_count: TMR3_COUNT,
        ///0x0c - RW, TMR3 end count value, only low 26 bit
        pub tmr3_cnt_end: TMR3_CNT_END,
        ///0x10 - RO/WO, TMR3 FIFO register, only low 26 bit
        pub tmr3_fifo: TMR3_FIFO,
    }
    ///TMR3_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR3_CTRL_MOD_SPEC>`
    pub type TMR3_CTRL_MOD = crate::Reg<tmr3_ctrl_mod::TMR3_CTRL_MOD_SPEC>;
    ///RW, TMR3 mode control
    pub mod tmr3_ctrl_mod {
        ///Register `TMR3_CTRL_MOD` reader
        pub struct R(crate::R<TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_CTRL_MOD` writer
        pub struct W(crate::W<TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_CTRL_MOD_SPEC, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_CTRL_MOD_SPEC, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_CTRL_MOD_SPEC, O>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, TMR3_CTRL_MOD_SPEC, O>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR3_CTRL_MOD_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_ctrl_mod](index.html) module
        pub struct TMR3_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR3_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR3_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR3_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR3_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR3_INTER_EN (rw) register accessor: an alias for `Reg<TMR3_INTER_EN_SPEC>`
    pub type TMR3_INTER_EN = crate::Reg<tmr3_inter_en::TMR3_INTER_EN_SPEC>;
    ///RW, TMR3 interrupt enable
    pub mod tmr3_inter_en {
        ///Register `TMR3_INTER_EN` reader
        pub struct R(crate::R<TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_INTER_EN` writer
        pub struct W(crate::W<TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INTER_EN_SPEC, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INTER_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_inter_en](index.html) module
        pub struct TMR3_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR3_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_inter_en::R](R) reader structure
        impl crate::Readable for TMR3_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_inter_en::W](W) writer structure
        impl crate::Writable for TMR3_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_INTER_EN to value 0
        impl crate::Resettable for TMR3_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_INT_FLAG (rw) register accessor: an alias for `Reg<TMR3_INT_FLAG_SPEC>`
    pub type TMR3_INT_FLAG = crate::Reg<tmr3_int_flag::TMR3_INT_FLAG_SPEC>;
    ///RW1, TMR3 interrupt flag
    pub mod tmr3_int_flag {
        ///Register `TMR3_INT_FLAG` reader
        pub struct R(crate::R<TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_INT_FLAG` writer
        pub struct W(crate::W<TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INT_FLAG_SPEC, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, TMR3_INT_FLAG_SPEC, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo more than 4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR3 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_int_flag](index.html) module
        pub struct TMR3_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR3_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_int_flag::R](R) reader structure
        impl crate::Readable for TMR3_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_int_flag::W](W) writer structure
        impl crate::Writable for TMR3_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_INT_FLAG to value 0
        impl crate::Resettable for TMR3_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR3_FIFO_COUNT_SPEC>`
    pub type TMR3_FIFO_COUNT = crate::Reg<tmr3_fifo_count::TMR3_FIFO_COUNT_SPEC>;
    ///RO, TMR3 FIFO count status
    pub mod tmr3_fifo_count {
        ///Register `TMR3_FIFO_COUNT` reader
        pub struct R(crate::R<TMR3_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR3_FIFO_COUNT` reader - RO, TMR3 FIFO count status
        pub type TMR3_FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - RO, TMR3 FIFO count status
            #[inline(always)]
            pub fn tmr3_fifo_count(&self) -> TMR3_FIFO_COUNT_R {
                TMR3_FIFO_COUNT_R::new(self.bits & 0x0f)
            }
        }
        ///RO, TMR3 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_fifo_count](index.html) module
        pub struct TMR3_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR3_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_fifo_count::R](R) reader structure
        impl crate::Readable for TMR3_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR3_FIFO_COUNT to value 0
        impl crate::Resettable for TMR3_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_COUNT (r) register accessor: an alias for `Reg<TMR3_COUNT_SPEC>`
    pub type TMR3_COUNT = crate::Reg<tmr3_count::TMR3_COUNT_SPEC>;
    ///RO, TMR3 current count
    pub mod tmr3_count {
        ///Register `TMR3_COUNT` reader
        pub struct R(crate::R<TMR3_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR3_COUNT` reader - RO, TMR3 current count
        pub type TMR3_COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:25 - RO, TMR3 current count
            #[inline(always)]
            pub fn tmr3_count(&self) -> TMR3_COUNT_R {
                TMR3_COUNT_R::new(self.bits & 0x03ff_ffff)
            }
        }
        ///RO, TMR3 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_count](index.html) module
        pub struct TMR3_COUNT_SPEC;
        impl crate::RegisterSpec for TMR3_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_count::R](R) reader structure
        impl crate::Readable for TMR3_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR3_COUNT to value 0
        impl crate::Resettable for TMR3_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_CNT_END (rw) register accessor: an alias for `Reg<TMR3_CNT_END_SPEC>`
    pub type TMR3_CNT_END = crate::Reg<tmr3_cnt_end::TMR3_CNT_END_SPEC>;
    ///RW, TMR3 end count value, only low 26 bit
    pub mod tmr3_cnt_end {
        ///Register `TMR3_CNT_END` reader
        pub struct R(crate::R<TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_CNT_END` writer
        pub struct W(crate::W<TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR3_CNT_END` reader - RW, TMR3 end count value, only low 26 bit
        pub type TMR3_CNT_END_R = crate::FieldReader<u32>;
        ///Field `TMR3_CNT_END` writer - RW, TMR3 end count value, only low 26 bit
        pub type TMR3_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, TMR3_CNT_END_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            pub fn tmr3_cnt_end(&self) -> TMR3_CNT_END_R {
                TMR3_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn tmr3_cnt_end(&mut self) -> TMR3_CNT_END_W<0> {
                TMR3_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_cnt_end](index.html) module
        pub struct TMR3_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR3_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_cnt_end::R](R) reader structure
        impl crate::Readable for TMR3_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_cnt_end::W](W) writer structure
        impl crate::Writable for TMR3_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_CNT_END to value 0
        impl crate::Resettable for TMR3_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_FIFO (rw) register accessor: an alias for `Reg<TMR3_FIFO_SPEC>`
    pub type TMR3_FIFO = crate::Reg<tmr3_fifo::TMR3_FIFO_SPEC>;
    ///RO/WO, TMR3 FIFO register, only low 26 bit
    pub mod tmr3_fifo {
        ///Register `TMR3_FIFO` reader
        pub struct R(crate::R<TMR3_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_FIFO` writer
        pub struct W(crate::W<TMR3_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR3_FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type TMR3_FIFO_R = crate::FieldReader<u32>;
        ///Field `TMR3_FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type TMR3_FIFO_W<'a, const O: u8> = crate::FieldWriter<'a, TMR3_FIFO_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            pub fn tmr3_fifo(&self) -> TMR3_FIFO_R {
                TMR3_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn tmr3_fifo(&mut self) -> TMR3_FIFO_W<0> {
                TMR3_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, TMR3 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_fifo](index.html) module
        pub struct TMR3_FIFO_SPEC;
        impl crate::RegisterSpec for TMR3_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_fifo::R](R) reader structure
        impl crate::Readable for TMR3_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_fifo::W](W) writer structure
        impl crate::Writable for TMR3_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_FIFO to value 0
        impl crate::Resettable for TMR3_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART0 modem control
        pub mcr: MCR,
        ///0x01 - RW, UART0 interrupt enable
        pub ier: IER,
        ///0x02 - RW, UART0 FIFO control
        pub fcr: FCR,
        ///0x03 - RW, UART0 line control
        pub lcr: LCR,
        ///0x04 - RO, UART0 interrupt identification
        pub iir: IIR,
        ///0x05 - RO, UART0 line status
        pub lsr: LSR,
        ///0x06 - RO, UART0 modem status
        pub msr: MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_rbr: [u8; 0x01],
        _reserved8: [u8; 0x01],
        ///0x0a - RO, UART0 receiver FIFO count
        pub rfc: RFC,
        ///0x0b - RO, UART0 transmitter FIFO count
        pub tfc: TFC,
        ///0x0c - RW, UART0 divisor latch
        pub dl: DL,
        ///0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub div: DIV,
        ///0x0f - RW, UART0 slave address: 0xFF=disable, other=enable
        pub adr: ADR,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART0 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART0 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///MCR (rw) register accessor: an alias for `Reg<MCR_SPEC>`
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART0 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub struct R(crate::R<MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MCR` writer
        pub struct W(crate::W<MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DTR` reader - RW, UART0 control DTR
        pub type DTR_R = crate::BitReader;
        ///Field `DTR` writer - RW, UART0 control DTR
        pub type DTR_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `RTS` reader - RW, UART0 control RTS
        pub type RTS_R = crate::BitReader;
        ///Field `RTS` writer - RW, UART0 control RTS
        pub type RTS_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `OUT1` reader - RW, UART0 control OUT1
        pub type OUT1_R = crate::BitReader;
        ///Field `OUT1` writer - RW, UART0 control OUT1
        pub type OUT1_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `OUT2_RB_MCR_INT_OE` reader - RW, UART control OUT2/ UART interrupt output enable
        pub type OUT2_RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `OUT2_RB_MCR_INT_OE` writer - RW, UART control OUT2/ UART interrupt output enable
        pub type OUT2_RB_MCR_INT_OE_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `LOOP` reader - RW, UART0 enable local loop back
        pub type LOOP_R = crate::BitReader;
        ///Field `LOOP` writer - RW, UART0 enable local loop back
        pub type LOOP_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `AU_FLOW_EN` reader - RW, UART0 enable autoflow control
        pub type AU_FLOW_EN_R = crate::BitReader;
        ///Field `AU_FLOW_EN` writer - RW, UART0 enable autoflow control
        pub type AU_FLOW_EN_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `TNOW` reader - RW, UART0 enable TNOW output on DTR pin
        pub type TNOW_R = crate::BitReader;
        ///Field `TNOW` writer - RW, UART0 enable TNOW output on DTR pin
        pub type TNOW_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        ///Field `HALF` reader - RW, UART0 enable half-duplex
        pub type HALF_R = crate::BitReader;
        ///Field `HALF` writer - RW, UART0 enable half-duplex
        pub type HALF_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        impl R {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            pub fn dtr(&self) -> DTR_R {
                DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            pub fn out1(&self) -> OUT1_R {
                OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            pub fn out2_rb_mcr_int_oe(&self) -> OUT2_RB_MCR_INT_OE_R {
                OUT2_RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            pub fn loop_(&self) -> LOOP_R {
                LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            pub fn au_flow_en(&self) -> AU_FLOW_EN_R {
                AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn tnow(&self) -> TNOW_R {
                TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            pub fn half(&self) -> HALF_R {
                HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn dtr(&mut self) -> DTR_W<0> {
                DTR_W::new(self)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<1> {
                RTS_W::new(self)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn out1(&mut self) -> OUT1_W<2> {
                OUT1_W::new(self)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn out2_rb_mcr_int_oe(&mut self) -> OUT2_RB_MCR_INT_OE_W<3> {
                OUT2_RB_MCR_INT_OE_W::new(self)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn loop_(&mut self) -> LOOP_W<4> {
                LOOP_W::new(self)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn au_flow_en(&mut self) -> AU_FLOW_EN_W<5> {
                AU_FLOW_EN_W::new(self)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn tnow(&mut self) -> TNOW_W<6> {
                TNOW_W::new(self)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn half(&mut self) -> HALF_W<7> {
                HALF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [mcr](index.html) module
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [mcr::R](R) reader structure
        impl crate::Readable for MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [mcr::W](W) writer structure
        impl crate::Writable for MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IER (rw) register accessor: an alias for `Reg<IER_SPEC>`
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART0 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub struct R(crate::R<IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IER` writer
        pub struct W(crate::W<IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_R = crate::BitReader;
        ///Field `RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_R = crate::BitReader;
        ///Field `THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_R = crate::BitReader;
        ///Field `LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change
        pub type MODEM_CHG_R = crate::BitReader;
        ///Field `MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change
        pub type MODEM_CHG_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable
        pub type DTR_EN_R = crate::BitReader;
        ///Field `DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable
        pub type DTR_EN_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `RTS_EN` reader - RW, UART0 RTS output pin enable
        pub type RTS_EN_R = crate::BitReader;
        ///Field `RTS_EN` writer - RW, UART0 RTS output pin enable
        pub type RTS_EN_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `TXD_EN` reader - RW, UART TXD pin enable
        pub type TXD_EN_R = crate::BitReader;
        ///Field `TXD_EN` writer - RW, UART TXD pin enable
        pub type TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RESET_R = crate::BitReader;
        ///Field `RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn recv_rdy(&self) -> RECV_RDY_R {
                RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn thr_empty(&self) -> THR_EMPTY_R {
                THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn line_stat(&self) -> LINE_STAT_R {
                LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn modem_chg(&self) -> MODEM_CHG_R {
                MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn dtr_en(&self) -> DTR_EN_R {
                DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            pub fn rts_en(&self) -> RTS_EN_R {
                RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn txd_en(&self) -> TXD_EN_R {
                TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn recv_rdy(&mut self) -> RECV_RDY_W<0> {
                RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn thr_empty(&mut self) -> THR_EMPTY_W<1> {
                THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn line_stat(&mut self) -> LINE_STAT_W<2> {
                LINE_STAT_W::new(self)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn modem_chg(&mut self) -> MODEM_CHG_W<3> {
                MODEM_CHG_W::new(self)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn dtr_en(&mut self) -> DTR_EN_W<4> {
                DTR_EN_W::new(self)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn rts_en(&mut self) -> RTS_EN_W<5> {
                RTS_EN_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn txd_en(&mut self) -> TXD_EN_W<6> {
                TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<7> {
                RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ier](index.html) module
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ier::R](R) reader structure
        impl crate::Readable for IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ier::W](W) writer structure
        impl crate::Writable for IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FCR (rw) register accessor: an alias for `Reg<FCR_SPEC>`
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART0 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub struct R(crate::R<FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FCR` writer
        pub struct W(crate::W<FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FIFO_EN` reader - RW, UART FIFO enable
        pub type FIFO_EN_R = crate::BitReader;
        ///Field `FIFO_EN` writer - RW, UART FIFO enable
        pub type FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_R = crate::BitReader;
        ///Field `RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_R = crate::BitReader;
        ///Field `TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_R = crate::FieldReader;
        ///Field `FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_W<'a, const O: u8> = crate::FieldWriter<'a, FCR_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fifo_en(&self) -> FIFO_EN_R {
                FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rx_fifo_clr(&self) -> RX_FIFO_CLR_R {
                RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn tx_fifo_clr(&self) -> TX_FIFO_CLR_R {
                TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fifo_trig(&self) -> FIFO_TRIG_R {
                FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fifo_en(&mut self) -> FIFO_EN_W<0> {
                FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rx_fifo_clr(&mut self) -> RX_FIFO_CLR_W<1> {
                RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn tx_fifo_clr(&mut self) -> TX_FIFO_CLR_W<2> {
                TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fifo_trig(&mut self) -> FIFO_TRIG_W<6> {
                FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fcr](index.html) module
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [fcr::R](R) reader structure
        impl crate::Readable for FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fcr::W](W) writer structure
        impl crate::Writable for FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///LCR (rw) register accessor: an alias for `Reg<LCR_SPEC>`
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART0 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub struct R(crate::R<LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LCR` writer
        pub struct W(crate::W<LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_R = crate::FieldReader;
        ///Field `WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_W<'a, const O: u8> = crate::FieldWriter<'a, LCR_SPEC, 2, O>;
        ///Field `STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_R = crate::BitReader;
        ///Field `STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `PAR_EN` reader - RW, UART parity enable
        pub type PAR_EN_R = crate::BitReader;
        ///Field `PAR_EN` writer - RW, UART parity enable
        pub type PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_R = crate::FieldReader;
        ///Field `PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_W<'a, const O: u8> = crate::FieldWriter<'a, LCR_SPEC, 2, O>;
        ///Field `BREAK_EN` reader - RW, UART break control enable
        pub type BREAK_EN_R = crate::BitReader;
        ///Field `BREAK_EN` writer - RW, UART break control enable
        pub type BREAK_EN_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `GP_BIT_RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT_RB_LCR_DLAB_R = crate::BitReader;
        ///Field `GP_BIT_RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT_RB_LCR_DLAB_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn word_sz(&self) -> WORD_SZ_R {
                WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn stop_bit(&self) -> STOP_BIT_R {
                STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn par_en(&self) -> PAR_EN_R {
                PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn par_mod(&self) -> PAR_MOD_R {
                PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn break_en(&self) -> BREAK_EN_R {
                BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn gp_bit_rb_lcr_dlab(&self) -> GP_BIT_RB_LCR_DLAB_R {
                GP_BIT_RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn word_sz(&mut self) -> WORD_SZ_W<0> {
                WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn stop_bit(&mut self) -> STOP_BIT_W<2> {
                STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn par_en(&mut self) -> PAR_EN_W<3> {
                PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn par_mod(&mut self) -> PAR_MOD_W<4> {
                PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn break_en(&mut self) -> BREAK_EN_W<6> {
                BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn gp_bit_rb_lcr_dlab(&mut self) -> GP_BIT_RB_LCR_DLAB_W<7> {
                GP_BIT_RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lcr](index.html) module
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [lcr::R](R) reader structure
        impl crate::Readable for LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [lcr::W](W) writer structure
        impl crate::Writable for LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IIR (r) register accessor: an alias for `Reg<IIR_SPEC>`
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART0 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub struct R(crate::R<IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type NO_INT_R = crate::BitReader;
        ///Field `INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type INT_MASK_R = crate::FieldReader;
        ///Field `FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn no_int(&self) -> NO_INT_R {
                NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn int_mask(&self) -> INT_MASK_R {
                INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn fifo_id(&self) -> FIFO_ID_R {
                FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART0 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iir](index.html) module
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iir::R](R) reader structure
        impl crate::Readable for IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///LSR (r) register accessor: an alias for `Reg<LSR_SPEC>`
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART0 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub struct R(crate::R<LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type DATA_RDY_R = crate::BitReader;
        ///Field `OVER_ERR` reader - RZ, UART receiver overrun error
        pub type OVER_ERR_R = crate::BitReader;
        ///Field `PAR_ERR` reader - RZ, UART receiver parity error
        pub type PAR_ERR_R = crate::BitReader;
        ///Field `FRAME_ERR` reader - RZ, UART receiver frame error
        pub type FRAME_ERR_R = crate::BitReader;
        ///Field `BREAK_ERR` reader - RZ, UART receiver break error
        pub type BREAK_ERR_R = crate::BitReader;
        ///Field `TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type TX_FIFO_EMP_R = crate::BitReader;
        ///Field `TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type TX_ALL_EMP_R = crate::BitReader;
        ///Field `ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn data_rdy(&self) -> DATA_RDY_R {
                DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn over_err(&self) -> OVER_ERR_R {
                OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn par_err(&self) -> PAR_ERR_R {
                PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn frame_err(&self) -> FRAME_ERR_R {
                FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn break_err(&self) -> BREAK_ERR_R {
                BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn tx_fifo_emp(&self) -> TX_FIFO_EMP_R {
                TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn tx_all_emp(&self) -> TX_ALL_EMP_R {
                TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn err_rx_fifo(&self) -> ERR_RX_FIFO_R {
                ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lsr](index.html) module
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [lsr::R](R) reader structure
        impl crate::Readable for LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///MSR (r) register accessor: an alias for `Reg<MSR_SPEC>`
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    ///RO, UART0 modem status
    pub mod msr {
        ///Register `MSR` reader
        pub struct R(crate::R<MSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CTS_CHG` reader - RZ, UART0 CTS changed status, high action
        pub type CTS_CHG_R = crate::BitReader;
        ///Field `DSR_CHG` reader - RZ, UART0 DSR changed status, high action
        pub type DSR_CHG_R = crate::BitReader;
        ///Field `RI_CHG` reader - RZ, UART0 RI changed status, high action
        pub type RI_CHG_R = crate::BitReader;
        ///Field `DCD_CHG` reader - RZ, UART0 DCD changed status, high action
        pub type DCD_CHG_R = crate::BitReader;
        ///Field `CTS` reader - RO, UART0 CTS action status
        pub type CTS_R = crate::BitReader;
        ///Field `DSR` reader - RO, UART0 DSR action statusv
        pub type DSR_R = crate::BitReader;
        ///Field `RI` reader - RO, UART0 RI action status
        pub type RI_R = crate::BitReader;
        ///Field `DCD` reader - RO, UART0 DCD action status
        pub type DCD_R = crate::BitReader;
        impl R {
            ///Bit 0 - RZ, UART0 CTS changed status, high action
            #[inline(always)]
            pub fn cts_chg(&self) -> CTS_CHG_R {
                CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART0 DSR changed status, high action
            #[inline(always)]
            pub fn dsr_chg(&self) -> DSR_CHG_R {
                DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART0 RI changed status, high action
            #[inline(always)]
            pub fn ri_chg(&self) -> RI_CHG_R {
                RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART0 DCD changed status, high action
            #[inline(always)]
            pub fn dcd_chg(&self) -> DCD_CHG_R {
                DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, UART0 CTS action status
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART0 DSR action statusv
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART0 RI action status
            #[inline(always)]
            pub fn ri(&self) -> RI_R {
                RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, UART0 DCD action status
            #[inline(always)]
            pub fn dcd(&self) -> DCD_R {
                DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 modem status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [msr](index.html) module
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [msr::R](R) reader structure
        impl crate::Readable for MSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets MSR to value 0
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RBR (r) register accessor: an alias for `Reg<RBR_SPEC>`
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART0 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub struct R(crate::R<RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RBR` reader - RO, UART0 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rbr](index.html) module
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rbr::R](R) reader structure
        impl crate::Readable for RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///THR (w) register accessor: an alias for `Reg<THR_SPEC>`
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART0 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub struct W(crate::W<THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THR` writer - RO, UART0 transmitter holding, transmittal byte
        pub type THR_W<'a, const O: u8> = crate::FieldWriter<'a, THR_SPEC, 8, O>;
        impl W {
            ///Bits 0:7 - RO, UART0 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<0> {
                THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART0 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [thr](index.html) module
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [thr::W](W) writer structure
        impl crate::Writable for THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RFC (r) register accessor: an alias for `Reg<RFC_SPEC>`
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART0 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub struct R(crate::R<RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RFC` reader - RO, UART0 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rfc](index.html) module
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rfc::R](R) reader structure
        impl crate::Readable for RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TFC (r) register accessor: an alias for `Reg<TFC_SPEC>`
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART0 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub struct R(crate::R<TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TFC` reader - RO, UART0 transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART0 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tfc](index.html) module
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tfc::R](R) reader structure
        impl crate::Readable for TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DL (rw) register accessor: an alias for `Reg<DL_SPEC>`
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART0 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub struct R(crate::R<DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DL` writer
        pub struct W(crate::W<DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DL` reader - RW, UART0 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART0 divisor latch
        pub type DL_W<'a, const O: u8> = crate::FieldWriter<'a, DL_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<0> {
                DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dl](index.html) module
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dl::R](R) reader structure
        impl crate::Readable for DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dl::W](W) writer structure
        impl crate::Writable for DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DIV (rw) register accessor: an alias for `Reg<DIV_SPEC>`
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    pub mod div {
        ///Register `DIV` reader
        pub struct R(crate::R<DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIV` writer
        pub struct W(crate::W<DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_W<'a, const O: u8> = crate::FieldWriter<'a, DIV_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<0> {
                DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [div](index.html) module
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [div::R](R) reader structure
        impl crate::Readable for DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [div::W](W) writer structure
        impl crate::Writable for DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADR (rw) register accessor: an alias for `Reg<ADR_SPEC>`
    pub type ADR = crate::Reg<adr::ADR_SPEC>;
    ///RW, UART0 slave address: 0xFF=disable, other=enable
    pub mod adr {
        ///Register `ADR` reader
        pub struct R(crate::R<ADR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADR` writer
        pub struct W(crate::W<ADR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_R = crate::FieldReader;
        ///Field `ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_W<'a, const O: u8> = crate::FieldWriter<'a, ADR_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            pub fn adr(&self) -> ADR_R {
                ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            #[must_use]
            pub fn adr(&mut self) -> ADR_W<0> {
                ADR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 slave address: 0xFF=disable, other=enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adr](index.html) module
        pub struct ADR_SPEC;
        impl crate::RegisterSpec for ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adr::R](R) reader structure
        impl crate::Readable for ADR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adr::W](W) writer structure
        impl crate::Writable for ADR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADR to value 0xff
        impl crate::Resettable for ADR_SPEC {
            const RESET_VALUE: Self::Ux = 0xff;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub mod uart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART1 modem control
        pub mcr: MCR,
        ///0x01 - RW, UART1 interrupt enable
        pub ier: IER,
        ///0x02 - RW, UART1 FIFO control
        pub fcr: FCR,
        ///0x03 - RW, UART1 line control
        pub lcr: LCR,
        ///0x04 - RO, UART1 interrupt identification
        pub iir: IIR,
        ///0x05 - RO, UART1 line status
        pub lsr: LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART1 receiver FIFO count
        pub rfc: RFC,
        ///0x0b - RO, UART1 transmitter FIFO count
        pub tfc: TFC,
        ///0x0c - RW, UART1 divisor latch
        pub dl: DL,
        ///0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub div: DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART1 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART1 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///MCR (rw) register accessor: an alias for `Reg<MCR_SPEC>`
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART1 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub struct R(crate::R<MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MCR` writer
        pub struct W(crate::W<MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OUT2_RB_MCR_INT_OE` reader - RW, UART control OUT2/UART interrupt output enable
        pub type OUT2_RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `OUT2_RB_MCR_INT_OE` writer - RW, UART control OUT2/UART interrupt output enable
        pub type OUT2_RB_MCR_INT_OE_W<'a, const O: u8> = crate::BitWriter<'a, MCR_SPEC, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            pub fn out2_rb_mcr_int_oe(&self) -> OUT2_RB_MCR_INT_OE_R {
                OUT2_RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn out2_rb_mcr_int_oe(&mut self) -> OUT2_RB_MCR_INT_OE_W<3> {
                OUT2_RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [mcr](index.html) module
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [mcr::R](R) reader structure
        impl crate::Readable for MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [mcr::W](W) writer structure
        impl crate::Writable for MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IER (rw) register accessor: an alias for `Reg<IER_SPEC>`
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART1 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub struct R(crate::R<IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IER` writer
        pub struct W(crate::W<IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_R = crate::BitReader;
        ///Field `RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_R = crate::BitReader;
        ///Field `THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_R = crate::BitReader;
        ///Field `LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `TXD_EN` reader - RW, UART TXD pin enable
        pub type TXD_EN_R = crate::BitReader;
        ///Field `TXD_EN` writer - RW, UART TXD pin enable
        pub type TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        ///Field `RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RESET_R = crate::BitReader;
        ///Field `RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, IER_SPEC, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn recv_rdy(&self) -> RECV_RDY_R {
                RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn thr_empty(&self) -> THR_EMPTY_R {
                THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn line_stat(&self) -> LINE_STAT_R {
                LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn txd_en(&self) -> TXD_EN_R {
                TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn recv_rdy(&mut self) -> RECV_RDY_W<0> {
                RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn thr_empty(&mut self) -> THR_EMPTY_W<1> {
                THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn line_stat(&mut self) -> LINE_STAT_W<2> {
                LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn txd_en(&mut self) -> TXD_EN_W<6> {
                TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<7> {
                RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ier](index.html) module
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ier::R](R) reader structure
        impl crate::Readable for IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ier::W](W) writer structure
        impl crate::Writable for IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FCR (rw) register accessor: an alias for `Reg<FCR_SPEC>`
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART1 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub struct R(crate::R<FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FCR` writer
        pub struct W(crate::W<FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FIFO_EN` reader - RW, UART FIFO enable
        pub type FIFO_EN_R = crate::BitReader;
        ///Field `FIFO_EN` writer - RW, UART FIFO enable
        pub type FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_R = crate::BitReader;
        ///Field `RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_R = crate::BitReader;
        ///Field `TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_W<'a, const O: u8> = crate::BitWriter<'a, FCR_SPEC, O>;
        ///Field `FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_R = crate::FieldReader;
        ///Field `FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_W<'a, const O: u8> = crate::FieldWriter<'a, FCR_SPEC, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fifo_en(&self) -> FIFO_EN_R {
                FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rx_fifo_clr(&self) -> RX_FIFO_CLR_R {
                RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn tx_fifo_clr(&self) -> TX_FIFO_CLR_R {
                TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fifo_trig(&self) -> FIFO_TRIG_R {
                FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fifo_en(&mut self) -> FIFO_EN_W<0> {
                FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rx_fifo_clr(&mut self) -> RX_FIFO_CLR_W<1> {
                RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn tx_fifo_clr(&mut self) -> TX_FIFO_CLR_W<2> {
                TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fifo_trig(&mut self) -> FIFO_TRIG_W<6> {
                FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fcr](index.html) module
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [fcr::R](R) reader structure
        impl crate::Readable for FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fcr::W](W) writer structure
        impl crate::Writable for FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///LCR (rw) register accessor: an alias for `Reg<LCR_SPEC>`
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART1 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub struct R(crate::R<LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LCR` writer
        pub struct W(crate::W<LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_R = crate::FieldReader;
        ///Field `WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_W<'a, const O: u8> = crate::FieldWriter<'a, LCR_SPEC, 2, O>;
        ///Field `STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_R = crate::BitReader;
        ///Field `STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `PAR_EN` reader - RW, UART parity enable
        pub type PAR_EN_R = crate::BitReader;
        ///Field `PAR_EN` writer - RW, UART parity enable
        pub type PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_R = crate::FieldReader;
        ///Field `PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_W<'a, const O: u8> = crate::FieldWriter<'a, LCR_SPEC, 2, O>;
        ///Field `BREAK_EN` reader - RW, UART break control enable
        pub type BREAK_EN_R = crate::BitReader;
        ///Field `BREAK_EN` writer - RW, UART break control enable
        pub type BREAK_EN_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        ///Field `GP_BIT_RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT_RB_LCR_DLAB_R = crate::BitReader;
        ///Field `GP_BIT_RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT_RB_LCR_DLAB_W<'a, const O: u8> = crate::BitWriter<'a, LCR_SPEC, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn word_sz(&self) -> WORD_SZ_R {
                WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn stop_bit(&self) -> STOP_BIT_R {
                STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn par_en(&self) -> PAR_EN_R {
                PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn par_mod(&self) -> PAR_MOD_R {
                PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn break_en(&self) -> BREAK_EN_R {
                BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn gp_bit_rb_lcr_dlab(&self) -> GP_BIT_RB_LCR_DLAB_R {
                GP_BIT_RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn word_sz(&mut self) -> WORD_SZ_W<0> {
                WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn stop_bit(&mut self) -> STOP_BIT_W<2> {
                STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn par_en(&mut self) -> PAR_EN_W<3> {
                PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn par_mod(&mut self) -> PAR_MOD_W<4> {
                PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn break_en(&mut self) -> BREAK_EN_W<6> {
                BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn gp_bit_rb_lcr_dlab(&mut self) -> GP_BIT_RB_LCR_DLAB_W<7> {
                GP_BIT_RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lcr](index.html) module
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [lcr::R](R) reader structure
        impl crate::Readable for LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [lcr::W](W) writer structure
        impl crate::Writable for LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IIR (r) register accessor: an alias for `Reg<IIR_SPEC>`
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART1 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub struct R(crate::R<IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type NO_INT_R = crate::BitReader;
        ///Field `INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type INT_MASK_R = crate::FieldReader;
        ///Field `FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn no_int(&self) -> NO_INT_R {
                NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn int_mask(&self) -> INT_MASK_R {
                INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn fifo_id(&self) -> FIFO_ID_R {
                FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART1 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iir](index.html) module
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iir::R](R) reader structure
        impl crate::Readable for IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///LSR (r) register accessor: an alias for `Reg<LSR_SPEC>`
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART1 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub struct R(crate::R<LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type DATA_RDY_R = crate::BitReader;
        ///Field `OVER_ERR` reader - RZ, UART receiver overrun error
        pub type OVER_ERR_R = crate::BitReader;
        ///Field `PAR_ERR` reader - RZ, UART receiver parity error
        pub type PAR_ERR_R = crate::BitReader;
        ///Field `FRAME_ERR` reader - RZ, UART receiver frame error
        pub type FRAME_ERR_R = crate::BitReader;
        ///Field `BREAK_ERR` reader - RZ, UART receiver break error
        pub type BREAK_ERR_R = crate::BitReader;
        ///Field `TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type TX_FIFO_EMP_R = crate::BitReader;
        ///Field `TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type TX_ALL_EMP_R = crate::BitReader;
        ///Field `ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn data_rdy(&self) -> DATA_RDY_R {
                DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn over_err(&self) -> OVER_ERR_R {
                OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn par_err(&self) -> PAR_ERR_R {
                PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn frame_err(&self) -> FRAME_ERR_R {
                FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn break_err(&self) -> BREAK_ERR_R {
                BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn tx_fifo_emp(&self) -> TX_FIFO_EMP_R {
                TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn tx_all_emp(&self) -> TX_ALL_EMP_R {
                TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn err_rx_fifo(&self) -> ERR_RX_FIFO_R {
                ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lsr](index.html) module
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [lsr::R](R) reader structure
        impl crate::Readable for LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///RBR (r) register accessor: an alias for `Reg<RBR_SPEC>`
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART1 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub struct R(crate::R<RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RBR` reader - RO, UART1 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rbr](index.html) module
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rbr::R](R) reader structure
        impl crate::Readable for RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///THR (w) register accessor: an alias for `Reg<THR_SPEC>`
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART1 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub struct W(crate::W<THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RBR` writer - WO, UART1 transmitter holding, transmittal byte
        pub type RBR_W<'a, const O: u8> = crate::FieldWriter<'a, THR_SPEC, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART1 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn rbr(&mut self) -> RBR_W<0> {
                RBR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART1 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [thr](index.html) module
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [thr::W](W) writer structure
        impl crate::Writable for THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RFC (r) register accessor: an alias for `Reg<RFC_SPEC>`
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART1 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub struct R(crate::R<RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RFC` reader - RO, UART1 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rfc](index.html) module
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rfc::R](R) reader structure
        impl crate::Readable for RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TFC (r) register accessor: an alias for `Reg<TFC_SPEC>`
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART1 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub struct R(crate::R<TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TFC` reader - RO, UART1 receiver FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART1 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tfc](index.html) module
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tfc::R](R) reader structure
        impl crate::Readable for TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DL (rw) register accessor: an alias for `Reg<DL_SPEC>`
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART1 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub struct R(crate::R<DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DL` writer
        pub struct W(crate::W<DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DL` reader - RW, UART1 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART1 divisor latch
        pub type DL_W<'a, const O: u8> = crate::FieldWriter<'a, DL_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<0> {
                DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dl](index.html) module
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dl::R](R) reader structure
        impl crate::Readable for DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dl::W](W) writer structure
        impl crate::Writable for DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DIV (rw) register accessor: an alias for `Reg<DIV_SPEC>`
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod div {
        ///Register `DIV` reader
        pub struct R(crate::R<DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIV` writer
        pub struct W(crate::W<DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_W<'a, const O: u8> = crate::FieldWriter<'a, DIV_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<0> {
                DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [div](index.html) module
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [div::R](R) reader structure
        impl crate::Readable for DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [div::W](W) writer structure
        impl crate::Writable for DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub use self::uart1 as uart2;
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub use self::uart1 as uart3;
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, SPI0 mode control
        pub spi0_ctrl_mod: SPI0_CTRL_MOD,
        ///0x01 - RW, SPI0 configuration control
        pub spi0_ctrl_cfg: SPI0_CTRL_CFG,
        ///0x02 - RW, SPI0 interrupt enable
        pub spi0_inter_en: SPI0_INTER_EN,
        ///0x03 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub spi0_clock_div_r8_spi0_slave_pre: SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE,
        ///0x04 - RW, SPI0 data buffer
        pub spi0_buffer: SPI0_BUFFER,
        ///0x05 - RO, SPI0 work flag
        pub spi0_run_flag: SPI0_RUN_FLAG,
        ///0x06 - RW1, SPI0 interrupt flag
        pub spi0_int_flag: SPI0_INT_FLAG,
        ///0x07 - RW, SPI0 FIFO count status
        pub spi0_fifo_count: SPI0_FIFO_COUNT,
        _reserved8: [u8; 0x04],
        ///0x0c - RW, SPI0 total byte count, only low 12 bit
        pub spi0_total_cnt: SPI0_TOTAL_CNT,
        _reserved9: [u8; 0x02],
        ///0x10 - RO/WO, SPI0 FIFO register
        pub spi0_fifo: SPI0_FIFO,
        _reserved10: [u8; 0x02],
        ///0x13 - RO, SPI0 FIFO count status
        pub spi0_fifo_count1: SPI0_FIFO_COUNT1,
        ///0x14 - RW, SPI0 DMA current address
        pub spi0_dma_now: SPI0_DMA_NOW,
        _reserved12: [u8; 0x02],
        ///0x18 - RW, SPI0 DMA begin address
        pub spi0_dma_beg: SPI0_DMA_BEG,
        _reserved13: [u8; 0x02],
        ///0x1c - RW, SPI0 DMA end address
        pub spi0_dma_end: SPI0_DMA_END,
    }
    ///SPI0_CTRL_MOD (rw) register accessor: an alias for `Reg<SPI0_CTRL_MOD_SPEC>`
    pub type SPI0_CTRL_MOD = crate::Reg<spi0_ctrl_mod::SPI0_CTRL_MOD_SPEC>;
    ///RW, SPI0 mode control
    pub mod spi0_ctrl_mod {
        ///Register `SPI0_CTRL_MOD` reader
        pub struct R(crate::R<SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CTRL_MOD` writer
        pub struct W(crate::W<SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_R = crate::BitReader;
        ///Field `SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_R = crate::BitReader;
        ///Field `SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_R = crate::BitReader;
        ///Field `SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R = crate::BitReader;
        ///Field `SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_R = crate::BitReader;
        ///Field `SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type SPI_SCK_OE_R = crate::BitReader;
        ///Field `SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type SPI_SCK_OE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_R = crate::BitReader;
        ///Field `SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        ///Field `SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type SPI_MISO_OE_R = crate::BitReader;
        ///Field `SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type SPI_MISO_OE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_MOD_SPEC, O>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn spi_mode_slave(&self) -> SPI_MODE_SLAVE_R {
                SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn spi_all_clear(&self) -> SPI_ALL_CLEAR_R {
                SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn spi_2wire_mod(&self) -> SPI_2WIRE_MOD_R {
                SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn spi_mst_sck_mod_rb_spi_slv_cmd_mod(
                &self,
            ) -> SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R {
                SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn spi_fifo_dir(&self) -> SPI_FIFO_DIR_R {
                SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn spi_sck_oe(&self) -> SPI_SCK_OE_R {
                SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn spi_mosi_oe(&self) -> SPI_MOSI_OE_R {
                SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn spi_miso_oe(&self) -> SPI_MISO_OE_R {
                SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn spi_mode_slave(&mut self) -> SPI_MODE_SLAVE_W<0> {
                SPI_MODE_SLAVE_W::new(self)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn spi_all_clear(&mut self) -> SPI_ALL_CLEAR_W<1> {
                SPI_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn spi_2wire_mod(&mut self) -> SPI_2WIRE_MOD_W<2> {
                SPI_2WIRE_MOD_W::new(self)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_sck_mod_rb_spi_slv_cmd_mod(
                &mut self,
            ) -> SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W<3> {
                SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W::new(self)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn spi_fifo_dir(&mut self) -> SPI_FIFO_DIR_W<4> {
                SPI_FIFO_DIR_W::new(self)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_sck_oe(&mut self) -> SPI_SCK_OE_W<5> {
                SPI_SCK_OE_W::new(self)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mosi_oe(&mut self) -> SPI_MOSI_OE_W<6> {
                SPI_MOSI_OE_W::new(self)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_miso_oe(&mut self) -> SPI_MISO_OE_W<7> {
                SPI_MISO_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_ctrl_mod](index.html) module
        pub struct SPI0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for SPI0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_ctrl_mod::R](R) reader structure
        impl crate::Readable for SPI0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_ctrl_mod::W](W) writer structure
        impl crate::Writable for SPI0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CTRL_MOD to value 0x02
        impl crate::Resettable for SPI0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///SPI0_CTRL_CFG (rw) register accessor: an alias for `Reg<SPI0_CTRL_CFG_SPEC>`
    pub type SPI0_CTRL_CFG = crate::Reg<spi0_ctrl_cfg::SPI0_CTRL_CFG_SPEC>;
    ///RW, SPI0 configuration control
    pub mod spi0_ctrl_cfg {
        ///Register `SPI0_CTRL_CFG` reader
        pub struct R(crate::R<SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CTRL_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CTRL_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CTRL_CFG` writer
        pub struct W(crate::W<SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CTRL_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CTRL_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_R = crate::BitReader;
        ///Field `SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_CFG_SPEC, O>;
        ///Field `SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_R = crate::BitReader;
        ///Field `SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_CFG_SPEC, O>;
        ///Field `SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_R = crate::BitReader;
        ///Field `SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_CFG_SPEC, O>;
        ///Field `SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_R = crate::BitReader;
        ///Field `SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_CFG_SPEC, O>;
        ///Field `SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_R = crate::BitReader;
        ///Field `SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_CTRL_CFG_SPEC, O>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn spi_dma_enable(&self) -> SPI_DMA_ENABLE_R {
                SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn spi_dma_loop(&self) -> SPI_DMA_LOOP_R {
                SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn spi_auto_if(&self) -> SPI_AUTO_IF_R {
                SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn spi_bit_order(&self) -> SPI_BIT_ORDER_R {
                SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn spi_mst_dly_en(&self) -> SPI_MST_DLY_EN_R {
                SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_enable(&mut self) -> SPI_DMA_ENABLE_W<0> {
                SPI_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_loop(&mut self) -> SPI_DMA_LOOP_W<2> {
                SPI_DMA_LOOP_W::new(self)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn spi_auto_if(&mut self) -> SPI_AUTO_IF_W<4> {
                SPI_AUTO_IF_W::new(self)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn spi_bit_order(&mut self) -> SPI_BIT_ORDER_W<5> {
                SPI_BIT_ORDER_W::new(self)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_dly_en(&mut self) -> SPI_MST_DLY_EN_W<6> {
                SPI_MST_DLY_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 configuration control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_ctrl_cfg](index.html) module
        pub struct SPI0_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for SPI0_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_ctrl_cfg::R](R) reader structure
        impl crate::Readable for SPI0_CTRL_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_ctrl_cfg::W](W) writer structure
        impl crate::Writable for SPI0_CTRL_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CTRL_CFG to value 0
        impl crate::Resettable for SPI0_CTRL_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_INTER_EN (rw) register accessor: an alias for `Reg<SPI0_INTER_EN_SPEC>`
    pub type SPI0_INTER_EN = crate::Reg<spi0_inter_en::SPI0_INTER_EN_SPEC>;
    ///RW, SPI0 interrupt enable
    pub mod spi0_inter_en {
        ///Register `SPI0_INTER_EN` reader
        pub struct R(crate::R<SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_INTER_EN` writer
        pub struct W(crate::W<SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_R = crate::BitReader;
        ///Field `SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        ///Field `SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        ///Field `SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        ///Field `SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_R = crate::BitReader;
        ///Field `SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        ///Field `SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        ///Field `SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INTER_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn spi_ie_cnt_end(&self) -> SPI_IE_CNT_END_R {
                SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn spi_ie_byte_end(&self) -> SPI_IE_BYTE_END_R {
                SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn spi_ie_fifo_hf(&self) -> SPI_IE_FIFO_HF_R {
                SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_ie_dma_end(&self) -> SPI_IE_DMA_END_R {
                SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_ie_fifo_ov(&self) -> SPI_IE_FIFO_OV_R {
                SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_ie_fst_byte(&self) -> SPI_IE_FST_BYTE_R {
                SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_cnt_end(&mut self) -> SPI_IE_CNT_END_W<0> {
                SPI_IE_CNT_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_byte_end(&mut self) -> SPI_IE_BYTE_END_W<1> {
                SPI_IE_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_hf(&mut self) -> SPI_IE_FIFO_HF_W<2> {
                SPI_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_dma_end(&mut self) -> SPI_IE_DMA_END_W<3> {
                SPI_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_ov(&mut self) -> SPI_IE_FIFO_OV_W<4> {
                SPI_IE_FIFO_OV_W::new(self)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fst_byte(&mut self) -> SPI_IE_FST_BYTE_W<7> {
                SPI_IE_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_inter_en](index.html) module
        pub struct SPI0_INTER_EN_SPEC;
        impl crate::RegisterSpec for SPI0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_inter_en::R](R) reader structure
        impl crate::Readable for SPI0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_inter_en::W](W) writer structure
        impl crate::Writable for SPI0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_INTER_EN to value 0
        impl crate::Resettable for SPI0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE (rw) register accessor: an alias for `Reg<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>`
    pub type SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE =
        crate::Reg<spi0_clock_div_r8_spi0_slave_pre::SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>;
    ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
    pub mod spi0_clock_div_r8_spi0_slave_pre {
        ///Register `SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE` reader
        pub struct R(crate::R<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE` writer
        pub struct W(crate::W<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_R = crate::FieldReader;
        ///Field `SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn spi0_clock_div_r8_spi0_slave_pre(&self) -> SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_R {
                SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn spi0_clock_div_r8_spi0_slave_pre(
                &mut self,
            ) -> SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_W<0> {
                SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_clock_div_r8_spi0_slave_pre](index.html) module
        pub struct SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_clock_div_r8_spi0_slave_pre::R](R) reader structure
        impl crate::Readable for SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_clock_div_r8_spi0_slave_pre::W](W) writer structure
        impl crate::Writable for SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE to value 0x10
        impl crate::Resettable for SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    ///SPI0_BUFFER (rw) register accessor: an alias for `Reg<SPI0_BUFFER_SPEC>`
    pub type SPI0_BUFFER = crate::Reg<spi0_buffer::SPI0_BUFFER_SPEC>;
    ///RW, SPI0 data buffer
    pub mod spi0_buffer {
        ///Register `SPI0_BUFFER` reader
        pub struct R(crate::R<SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_BUFFER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_BUFFER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_BUFFER` writer
        pub struct W(crate::W<SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_BUFFER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_BUFFER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_BUFFER` reader - RW, SPI0 data buffer
        pub type SPI0_BUFFER_R = crate::FieldReader;
        ///Field `SPI0_BUFFER` writer - RW, SPI0 data buffer
        pub type SPI0_BUFFER_W<'a, const O: u8> = crate::FieldWriter<'a, SPI0_BUFFER_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            pub fn spi0_buffer(&self) -> SPI0_BUFFER_R {
                SPI0_BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            #[must_use]
            pub fn spi0_buffer(&mut self) -> SPI0_BUFFER_W<0> {
                SPI0_BUFFER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 data buffer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_buffer](index.html) module
        pub struct SPI0_BUFFER_SPEC;
        impl crate::RegisterSpec for SPI0_BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_buffer::R](R) reader structure
        impl crate::Readable for SPI0_BUFFER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_buffer::W](W) writer structure
        impl crate::Writable for SPI0_BUFFER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_BUFFER to value 0
        impl crate::Resettable for SPI0_BUFFER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_RUN_FLAG (r) register accessor: an alias for `Reg<SPI0_RUN_FLAG_SPEC>`
    pub type SPI0_RUN_FLAG = crate::Reg<spi0_run_flag::SPI0_RUN_FLAG_SPEC>;
    ///RO, SPI0 work flag
    pub mod spi0_run_flag {
        ///Register `SPI0_RUN_FLAG` reader
        pub struct R(crate::R<SPI0_RUN_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_RUN_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_RUN_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_RUN_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SPI_SLV_CMD_ACT_R = crate::BitReader;
        ///Field `SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type SPI_FIFO_READY_R = crate::BitReader;
        ///Field `SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SPI_SLV_CS_LOAD_R = crate::BitReader;
        ///Field `SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SPI_SLV_SELECT_R = crate::BitReader;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn spi_slv_cmd_act(&self) -> SPI_SLV_CMD_ACT_R {
                SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn spi_fifo_ready(&self) -> SPI_FIFO_READY_R {
                SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn spi_slv_cs_load(&self) -> SPI_SLV_CS_LOAD_R {
                SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn spi_slv_select(&self) -> SPI_SLV_SELECT_R {
                SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI0 work flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_run_flag](index.html) module
        pub struct SPI0_RUN_FLAG_SPEC;
        impl crate::RegisterSpec for SPI0_RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_run_flag::R](R) reader structure
        impl crate::Readable for SPI0_RUN_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI0_RUN_FLAG to value 0
        impl crate::Resettable for SPI0_RUN_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_INT_FLAG (rw) register accessor: an alias for `Reg<SPI0_INT_FLAG_SPEC>`
    pub type SPI0_INT_FLAG = crate::Reg<spi0_int_flag::SPI0_INT_FLAG_SPEC>;
    ///RW1, SPI0 interrupt flag
    pub mod spi0_int_flag {
        ///Register `SPI0_INT_FLAG` reader
        pub struct R(crate::R<SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_INT_FLAG` writer
        pub struct W(crate::W<SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_R = crate::BitReader;
        ///Field `SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_R = crate::BitReader;
        ///Field `SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_FREE` reader - RO, current SPI free status
        pub type SPI_FREE_R = crate::BitReader;
        ///Field `SPI_FREE` writer - RO, current SPI free status
        pub type SPI_FREE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        ///Field `SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_W<'a, const O: u8> = crate::BitWriter<'a, SPI0_INT_FLAG_SPEC, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn spi_if_cnt_end(&self) -> SPI_IF_CNT_END_R {
                SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn spi_if_byte_end(&self) -> SPI_IF_BYTE_END_R {
                SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn spi_if_fifo_hf(&self) -> SPI_IF_FIFO_HF_R {
                SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_if_dma_end(&self) -> SPI_IF_DMA_END_R {
                SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_if_fifo_ov(&self) -> SPI_IF_FIFO_OV_R {
                SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn spi_free(&self) -> SPI_FREE_R {
                SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_if_fst_byte(&self) -> SPI_IF_FST_BYTE_R {
                SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_if_cnt_end(&mut self) -> SPI_IF_CNT_END_W<0> {
                SPI_IF_CNT_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_if_byte_end(&mut self) -> SPI_IF_BYTE_END_W<1> {
                SPI_IF_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_hf(&mut self) -> SPI_IF_FIFO_HF_W<2> {
                SPI_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_if_dma_end(&mut self) -> SPI_IF_DMA_END_W<3> {
                SPI_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_ov(&mut self) -> SPI_IF_FIFO_OV_W<4> {
                SPI_IF_FIFO_OV_W::new(self)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn spi_free(&mut self) -> SPI_FREE_W<6> {
                SPI_FREE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fst_byte(&mut self) -> SPI_IF_FST_BYTE_W<7> {
                SPI_IF_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, SPI0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_int_flag](index.html) module
        pub struct SPI0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for SPI0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_int_flag::R](R) reader structure
        impl crate::Readable for SPI0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_int_flag::W](W) writer structure
        impl crate::Writable for SPI0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_INT_FLAG to value 0x40
        impl crate::Resettable for SPI0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///SPI0_FIFO_COUNT (rw) register accessor: an alias for `Reg<SPI0_FIFO_COUNT_SPEC>`
    pub type SPI0_FIFO_COUNT = crate::Reg<spi0_fifo_count::SPI0_FIFO_COUNT_SPEC>;
    ///RW, SPI0 FIFO count status
    pub mod spi0_fifo_count {
        ///Register `SPI0_FIFO_COUNT` reader
        pub struct R(crate::R<SPI0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_FIFO_COUNT` writer
        pub struct W(crate::W<SPI0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_FIFO_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_FIFO_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_FIFO_COUNT` reader - RW, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT_R = crate::FieldReader;
        ///Field `SPI0_FIFO_COUNT` writer - RW, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_FIFO_COUNT_SPEC, 4, O>;
        impl R {
            ///Bits 0:3 - RW, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi0_fifo_count(&self) -> SPI0_FIFO_COUNT_R {
                SPI0_FIFO_COUNT_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, SPI0 FIFO count status
            #[inline(always)]
            #[must_use]
            pub fn spi0_fifo_count(&mut self) -> SPI0_FIFO_COUNT_W<0> {
                SPI0_FIFO_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo_count](index.html) module
        pub struct SPI0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo_count::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_fifo_count::W](W) writer structure
        impl crate::Writable for SPI0_FIFO_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_FIFO_COUNT to value 0
        impl crate::Resettable for SPI0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_TOTAL_CNT (rw) register accessor: an alias for `Reg<SPI0_TOTAL_CNT_SPEC>`
    pub type SPI0_TOTAL_CNT = crate::Reg<spi0_total_cnt::SPI0_TOTAL_CNT_SPEC>;
    ///RW, SPI0 total byte count, only low 12 bit
    pub mod spi0_total_cnt {
        ///Register `SPI0_TOTAL_CNT` reader
        pub struct R(crate::R<SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_TOTAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_TOTAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_TOTAL_CNT` writer
        pub struct W(crate::W<SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_TOTAL_CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_TOTAL_CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit
        pub type SPI0_TOTAL_CNT_R = crate::FieldReader<u16>;
        ///Field `SPI0_TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit
        pub type SPI0_TOTAL_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_TOTAL_CNT_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            pub fn spi0_total_cnt(&self) -> SPI0_TOTAL_CNT_R {
                SPI0_TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn spi0_total_cnt(&mut self) -> SPI0_TOTAL_CNT_W<0> {
                SPI0_TOTAL_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 total byte count, only low 12 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_total_cnt](index.html) module
        pub struct SPI0_TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for SPI0_TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_total_cnt::R](R) reader structure
        impl crate::Readable for SPI0_TOTAL_CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_total_cnt::W](W) writer structure
        impl crate::Writable for SPI0_TOTAL_CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_TOTAL_CNT to value 0
        impl crate::Resettable for SPI0_TOTAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_FIFO (rw) register accessor: an alias for `Reg<SPI0_FIFO_SPEC>`
    pub type SPI0_FIFO = crate::Reg<spi0_fifo::SPI0_FIFO_SPEC>;
    ///RO/WO, SPI0 FIFO register
    pub mod spi0_fifo {
        ///Register `SPI0_FIFO` reader
        pub struct R(crate::R<SPI0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_FIFO` writer
        pub struct W(crate::W<SPI0_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_FIFO` reader - RO/WO, SPI0 FIFO register
        pub type SPI0_FIFO_R = crate::FieldReader;
        ///Field `SPI0_FIFO` writer - RO/WO, SPI0 FIFO register
        pub type SPI0_FIFO_W<'a, const O: u8> = crate::FieldWriter<'a, SPI0_FIFO_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            pub fn spi0_fifo(&self) -> SPI0_FIFO_R {
                SPI0_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn spi0_fifo(&mut self) -> SPI0_FIFO_W<0> {
                SPI0_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, SPI0 FIFO register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo](index.html) module
        pub struct SPI0_FIFO_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_fifo::W](W) writer structure
        impl crate::Writable for SPI0_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_FIFO to value 0
        impl crate::Resettable for SPI0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_FIFO_COUNT1 (r) register accessor: an alias for `Reg<SPI0_FIFO_COUNT1_SPEC>`
    pub type SPI0_FIFO_COUNT1 = crate::Reg<spi0_fifo_count1::SPI0_FIFO_COUNT1_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod spi0_fifo_count1 {
        ///Register `SPI0_FIFO_COUNT1` reader
        pub struct R(crate::R<SPI0_FIFO_COUNT1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_COUNT1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_COUNT1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_COUNT1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI0_FIFO_COUNT1` reader - RO, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi0_fifo_count1(&self) -> SPI0_FIFO_COUNT1_R {
                SPI0_FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo_count1](index.html) module
        pub struct SPI0_FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo_count1::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_COUNT1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI0_FIFO_COUNT1 to value 0
        impl crate::Resettable for SPI0_FIFO_COUNT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_NOW (rw) register accessor: an alias for `Reg<SPI0_DMA_NOW_SPEC>`
    pub type SPI0_DMA_NOW = crate::Reg<spi0_dma_now::SPI0_DMA_NOW_SPEC>;
    ///RW, SPI0 DMA current address
    pub mod spi0_dma_now {
        ///Register `SPI0_DMA_NOW` reader
        pub struct R(crate::R<SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_NOW` writer
        pub struct W(crate::W<SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_NOW_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_NOW_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_NOW` reader - RW, SPI0 DMA current address
        pub type SPI0_DMA_NOW_R = crate::FieldReader<u16>;
        ///Field `SPI0_DMA_NOW` writer - RW, SPI0 DMA current address
        pub type SPI0_DMA_NOW_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_DMA_NOW_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            pub fn spi0_dma_now(&self) -> SPI0_DMA_NOW_R {
                SPI0_DMA_NOW_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_now(&mut self) -> SPI0_DMA_NOW_W<0> {
                SPI0_DMA_NOW_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_now](index.html) module
        pub struct SPI0_DMA_NOW_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_now::R](R) reader structure
        impl crate::Readable for SPI0_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_now::W](W) writer structure
        impl crate::Writable for SPI0_DMA_NOW_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_NOW to value 0
        impl crate::Resettable for SPI0_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_BEG (rw) register accessor: an alias for `Reg<SPI0_DMA_BEG_SPEC>`
    pub type SPI0_DMA_BEG = crate::Reg<spi0_dma_beg::SPI0_DMA_BEG_SPEC>;
    ///RW, SPI0 DMA begin address
    pub mod spi0_dma_beg {
        ///Register `SPI0_DMA_BEG` reader
        pub struct R(crate::R<SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_BEG` writer
        pub struct W(crate::W<SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_BEG` reader - RW, SPI0 DMA begin address
        pub type SPI0_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `SPI0_DMA_BEG` writer - RW, SPI0 DMA begin address
        pub type SPI0_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_DMA_BEG_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            pub fn spi0_dma_beg(&self) -> SPI0_DMA_BEG_R {
                SPI0_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_beg(&mut self) -> SPI0_DMA_BEG_W<0> {
                SPI0_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_beg](index.html) module
        pub struct SPI0_DMA_BEG_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_beg::R](R) reader structure
        impl crate::Readable for SPI0_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_beg::W](W) writer structure
        impl crate::Writable for SPI0_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_BEG to value 0
        impl crate::Resettable for SPI0_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_END (rw) register accessor: an alias for `Reg<SPI0_DMA_END_SPEC>`
    pub type SPI0_DMA_END = crate::Reg<spi0_dma_end::SPI0_DMA_END_SPEC>;
    ///RW, SPI0 DMA end address
    pub mod spi0_dma_end {
        ///Register `SPI0_DMA_END` reader
        pub struct R(crate::R<SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_END` writer
        pub struct W(crate::W<SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_END` reader - RW, SPI0 DMA end address
        pub type SPI0_DMA_END_R = crate::FieldReader<u16>;
        ///Field `SPI0_DMA_END` writer - RW, SPI0 DMA end address
        pub type SPI0_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, SPI0_DMA_END_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            pub fn spi0_dma_end(&self) -> SPI0_DMA_END_R {
                SPI0_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_end(&mut self) -> SPI0_DMA_END_W<0> {
                SPI0_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_end](index.html) module
        pub struct SPI0_DMA_END_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_end::R](R) reader structure
        impl crate::Readable for SPI0_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_end::W](W) writer structure
        impl crate::Writable for SPI0_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_END to value 0
        impl crate::Resettable for SPI0_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///I2C register
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    ///Pointer to the register block
    pub const PTR: *const i2c::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
///I2C register
pub mod i2c {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, I2C control 1
        pub i2c_ctrl1: I2C_CTRL1,
        _reserved1: [u8; 0x02],
        ///0x04 - RW, I2C control 2
        pub i2c_ctrl2: I2C_CTRL2,
        _reserved2: [u8; 0x02],
        ///0x08 - RW, I2C own address register 1
        pub i2c_oaddr1: I2C_OADDR1,
        _reserved3: [u8; 0x02],
        ///0x0c - RW, I2C own address register 2
        pub i2c_oaddr2: I2C_OADDR2,
        _reserved4: [u8; 0x02],
        ///0x10 - RW, I2C data register
        pub i2c_datar: I2C_DATAR,
        _reserved5: [u8; 0x02],
        ///0x14 - RO, I2C stauts register 1
        pub i2c_star1: I2C_STAR1,
        _reserved6: [u8; 0x02],
        ///0x18 - RO, I2C status register 2
        pub i2c_star2: I2C_STAR2,
        _reserved7: [u8; 0x02],
        ///0x1c - RW, I2C clock control register
        pub i2c_ckcfgr: I2C_CKCFGR,
        _reserved8: [u8; 0x02],
        ///0x20 - RW, I2C trise register
        pub i2c_rtr: I2C_RTR,
    }
    ///I2C_CTRL1 (rw) register accessor: an alias for `Reg<I2C_CTRL1_SPEC>`
    pub type I2C_CTRL1 = crate::Reg<i2c_ctrl1::I2C_CTRL1_SPEC>;
    ///RW, I2C control 1
    pub mod i2c_ctrl1 {
        ///Register `I2C_CTRL1` reader
        pub struct R(crate::R<I2C_CTRL1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CTRL1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CTRL1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CTRL1` writer
        pub struct W(crate::W<I2C_CTRL1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CTRL1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CTRL1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_PE` reader - RW, Peripheral enable
        pub type I2C_PE_R = crate::BitReader;
        ///Field `I2C_PE` writer - RW, Peripheral enable
        pub type I2C_PE_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type I2C_SMBUS_R = crate::BitReader;
        ///Field `I2C_SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type I2C_SMBUS_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host
        pub type I2C_SMBTYPE_R = crate::BitReader;
        ///Field `I2C_SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host
        pub type I2C_SMBTYPE_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_EBARP` reader - RW, ARP enable
        pub type I2C_EBARP_R = crate::BitReader;
        ///Field `I2C_EBARP` writer - RW, ARP enable
        pub type I2C_EBARP_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_ENPEC` reader - RW, PEC ebable
        pub type I2C_ENPEC_R = crate::BitReader;
        ///Field `I2C_ENPEC` writer - RW, PEC ebable
        pub type I2C_ENPEC_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_ENGC` reader - RW, General call enable
        pub type I2C_ENGC_R = crate::BitReader;
        ///Field `I2C_ENGC` writer - RW, General call enable
        pub type I2C_ENGC_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)
        pub type I2C_NOSTRETCH_R = crate::BitReader;
        ///Field `I2C_NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)
        pub type I2C_NOSTRETCH_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type I2C_START_R = crate::BitReader;
        ///Field `I2C_START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type I2C_START_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type I2C_STOP_R = crate::BitReader;
        ///Field `I2C_STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type I2C_STOP_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_ACK` reader - RW, Acknowledge enable
        pub type I2C_ACK_R = crate::BitReader;
        ///Field `I2C_ACK` writer - RW, Acknowledge enable
        pub type I2C_ACK_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_POS` reader - RW, Acknowledge/PEC Position (for data reception)
        pub type I2C_POS_R = crate::BitReader;
        ///Field `I2C_POS` writer - RW, Acknowledge/PEC Position (for data reception)
        pub type I2C_POS_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type I2C_PEC_R = crate::BitReader;
        ///Field `I2C_PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type I2C_PEC_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type I2C_ALERT_R = crate::BitReader;
        ///Field `I2C_ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type I2C_ALERT_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        ///Field `I2C_SWRST` reader - RW, Software reset
        pub type I2C_SWRST_R = crate::BitReader;
        ///Field `I2C_SWRST` writer - RW, Software reset
        pub type I2C_SWRST_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL1_SPEC, O>;
        impl R {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            pub fn i2c_pe(&self) -> I2C_PE_R {
                I2C_PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            pub fn i2c_smbus(&self) -> I2C_SMBUS_R {
                I2C_SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            pub fn i2c_smbtype(&self) -> I2C_SMBTYPE_R {
                I2C_SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            pub fn i2c_ebarp(&self) -> I2C_EBARP_R {
                I2C_EBARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            pub fn i2c_enpec(&self) -> I2C_ENPEC_R {
                I2C_ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            pub fn i2c_engc(&self) -> I2C_ENGC_R {
                I2C_ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn i2c_nostretch(&self) -> I2C_NOSTRETCH_R {
                I2C_NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            pub fn i2c_start(&self) -> I2C_START_R {
                I2C_START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            pub fn i2c_stop(&self) -> I2C_STOP_R {
                I2C_STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            pub fn i2c_ack(&self) -> I2C_ACK_R {
                I2C_ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn i2c_pos(&self) -> I2C_POS_R {
                I2C_POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            pub fn i2c_pec(&self) -> I2C_PEC_R {
                I2C_PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            pub fn i2c_alert(&self) -> I2C_ALERT_R {
                I2C_ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            pub fn i2c_swrst(&self) -> I2C_SWRST_R {
                I2C_SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_pe(&mut self) -> I2C_PE_W<0> {
                I2C_PE_W::new(self)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_smbus(&mut self) -> I2C_SMBUS_W<1> {
                I2C_SMBUS_W::new(self)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            #[must_use]
            pub fn i2c_smbtype(&mut self) -> I2C_SMBTYPE_W<3> {
                I2C_SMBTYPE_W::new(self)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_ebarp(&mut self) -> I2C_EBARP_W<4> {
                I2C_EBARP_W::new(self)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            #[must_use]
            pub fn i2c_enpec(&mut self) -> I2C_ENPEC_W<5> {
                I2C_ENPEC_W::new(self)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_engc(&mut self) -> I2C_ENGC_W<6> {
                I2C_ENGC_W::new(self)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_nostretch(&mut self) -> I2C_NOSTRETCH_W<7> {
                I2C_NOSTRETCH_W::new(self)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            #[must_use]
            pub fn i2c_start(&mut self) -> I2C_START_W<8> {
                I2C_START_W::new(self)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            #[must_use]
            pub fn i2c_stop(&mut self) -> I2C_STOP_W<9> {
                I2C_STOP_W::new(self)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_ack(&mut self) -> I2C_ACK_W<10> {
                I2C_ACK_W::new(self)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn i2c_pos(&mut self) -> I2C_POS_W<11> {
                I2C_POS_W::new(self)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_pec(&mut self) -> I2C_PEC_W<12> {
                I2C_PEC_W::new(self)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            #[must_use]
            pub fn i2c_alert(&mut self) -> I2C_ALERT_W<13> {
                I2C_ALERT_W::new(self)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            #[must_use]
            pub fn i2c_swrst(&mut self) -> I2C_SWRST_W<15> {
                I2C_SWRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ctrl1](index.html) module
        pub struct I2C_CTRL1_SPEC;
        impl crate::RegisterSpec for I2C_CTRL1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ctrl1::R](R) reader structure
        impl crate::Readable for I2C_CTRL1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ctrl1::W](W) writer structure
        impl crate::Writable for I2C_CTRL1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CTRL1 to value 0
        impl crate::Resettable for I2C_CTRL1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_CTRL2 (rw) register accessor: an alias for `Reg<I2C_CTRL2_SPEC>`
    pub type I2C_CTRL2 = crate::Reg<i2c_ctrl2::I2C_CTRL2_SPEC>;
    ///RW, I2C control 2
    pub mod i2c_ctrl2 {
        ///Register `I2C_CTRL2` reader
        pub struct R(crate::R<I2C_CTRL2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CTRL2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CTRL2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CTRL2` writer
        pub struct W(crate::W<I2C_CTRL2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CTRL2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CTRL2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type I2C_FREQ_R = crate::FieldReader;
        ///Field `I2C_FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type I2C_FREQ_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_CTRL2_SPEC, 6, O>;
        ///Field `I2C_ITERREN` reader - RW, Error interrupt enable
        pub type I2C_ITERREN_R = crate::BitReader;
        ///Field `I2C_ITERREN` writer - RW, Error interrupt enable
        pub type I2C_ITERREN_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL2_SPEC, O>;
        ///Field `I2C_ITEVTEN` reader - RW, Event interrupt enable
        pub type I2C_ITEVTEN_R = crate::BitReader;
        ///Field `I2C_ITEVTEN` writer - RW, Event interrupt enable
        pub type I2C_ITEVTEN_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL2_SPEC, O>;
        ///Field `I2C_ITBUFEN` reader - RW, Buffer interrupt enable
        pub type I2C_ITBUFEN_R = crate::BitReader;
        ///Field `I2C_ITBUFEN` writer - RW, Buffer interrupt enable
        pub type I2C_ITBUFEN_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CTRL2_SPEC, O>;
        impl R {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            pub fn i2c_freq(&self) -> I2C_FREQ_R {
                I2C_FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            pub fn i2c_iterren(&self) -> I2C_ITERREN_R {
                I2C_ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            pub fn i2c_itevten(&self) -> I2C_ITEVTEN_R {
                I2C_ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            pub fn i2c_itbufen(&self) -> I2C_ITBUFEN_R {
                I2C_ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            #[must_use]
            pub fn i2c_freq(&mut self) -> I2C_FREQ_W<0> {
                I2C_FREQ_W::new(self)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_iterren(&mut self) -> I2C_ITERREN_W<8> {
                I2C_ITERREN_W::new(self)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_itevten(&mut self) -> I2C_ITEVTEN_W<9> {
                I2C_ITEVTEN_W::new(self)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_itbufen(&mut self) -> I2C_ITBUFEN_W<10> {
                I2C_ITBUFEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ctrl2](index.html) module
        pub struct I2C_CTRL2_SPEC;
        impl crate::RegisterSpec for I2C_CTRL2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ctrl2::R](R) reader structure
        impl crate::Readable for I2C_CTRL2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ctrl2::W](W) writer structure
        impl crate::Writable for I2C_CTRL2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CTRL2 to value 0
        impl crate::Resettable for I2C_CTRL2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_OADDR1 (rw) register accessor: an alias for `Reg<I2C_OADDR1_SPEC>`
    pub type I2C_OADDR1 = crate::Reg<i2c_oaddr1::I2C_OADDR1_SPEC>;
    ///RW, I2C own address register 1
    pub mod i2c_oaddr1 {
        ///Register `I2C_OADDR1` reader
        pub struct R(crate::R<I2C_OADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_OADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_OADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_OADDR1` writer
        pub struct W(crate::W<I2C_OADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_OADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_OADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_ADD0` reader - RW, bit0 of address in 10-bit addressing mode
        pub type I2C_ADD0_R = crate::BitReader;
        ///Field `I2C_ADD0` writer - RW, bit0 of address in 10-bit addressing mode
        pub type I2C_ADD0_W<'a, const O: u8> = crate::BitWriter<'a, I2C_OADDR1_SPEC, O>;
        ///Field `I2C_ADD7_1` reader - RW, bit\[7:1\]
        ///of address
        pub type I2C_ADD7_1_R = crate::FieldReader;
        ///Field `I2C_ADD7_1` writer - RW, bit\[7:1\]
        ///of address
        pub type I2C_ADD7_1_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_OADDR1_SPEC, 7, O>;
        ///Field `I2C_ADD9_8` reader - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type I2C_ADD9_8_R = crate::FieldReader;
        ///Field `I2C_ADD9_8` writer - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type I2C_ADD9_8_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_OADDR1_SPEC, 2, O>;
        ///Field `I2C_ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type I2C_ADDMODE_R = crate::BitReader;
        ///Field `I2C_ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type I2C_ADDMODE_W<'a, const O: u8> = crate::BitWriter<'a, I2C_OADDR1_SPEC, O>;
        impl R {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            pub fn i2c_add0(&self) -> I2C_ADD0_R {
                I2C_ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            pub fn i2c_add7_1(&self) -> I2C_ADD7_1_R {
                I2C_ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            pub fn i2c_add9_8(&self) -> I2C_ADD9_8_R {
                I2C_ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            pub fn i2c_addmode(&self) -> I2C_ADDMODE_R {
                I2C_ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_add0(&mut self) -> I2C_ADD0_W<0> {
                I2C_ADD0_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            #[must_use]
            pub fn i2c_add7_1(&mut self) -> I2C_ADD7_1_W<1> {
                I2C_ADD7_1_W::new(self)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_add9_8(&mut self) -> I2C_ADD9_8_W<8> {
                I2C_ADD9_8_W::new(self)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            #[must_use]
            pub fn i2c_addmode(&mut self) -> I2C_ADDMODE_W<15> {
                I2C_ADDMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_oaddr1](index.html) module
        pub struct I2C_OADDR1_SPEC;
        impl crate::RegisterSpec for I2C_OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_oaddr1::R](R) reader structure
        impl crate::Readable for I2C_OADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_oaddr1::W](W) writer structure
        impl crate::Writable for I2C_OADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_OADDR1 to value 0
        impl crate::Resettable for I2C_OADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_OADDR2 (rw) register accessor: an alias for `Reg<I2C_OADDR2_SPEC>`
    pub type I2C_OADDR2 = crate::Reg<i2c_oaddr2::I2C_OADDR2_SPEC>;
    ///RW, I2C own address register 2
    pub mod i2c_oaddr2 {
        ///Register `I2C_OADDR2` reader
        pub struct R(crate::R<I2C_OADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_OADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_OADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_OADDR2` writer
        pub struct W(crate::W<I2C_OADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_OADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_OADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_ENDUAL` reader - RW, Dual addressing mode enable
        pub type I2C_ENDUAL_R = crate::BitReader;
        ///Field `I2C_ENDUAL` writer - RW, Dual addressing mode enable
        pub type I2C_ENDUAL_W<'a, const O: u8> = crate::BitWriter<'a, I2C_OADDR2_SPEC, O>;
        ///Field `I2C_ADD2` reader - RW, bit\[7:1\]
        ///of address2
        pub type I2C_ADD2_R = crate::FieldReader;
        ///Field `I2C_ADD2` writer - RW, bit\[7:1\]
        ///of address2
        pub type I2C_ADD2_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_OADDR2_SPEC, 7, O>;
        impl R {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            pub fn i2c_endual(&self) -> I2C_ENDUAL_R {
                I2C_ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            pub fn i2c_add2(&self) -> I2C_ADD2_R {
                I2C_ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_endual(&mut self) -> I2C_ENDUAL_W<0> {
                I2C_ENDUAL_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            #[must_use]
            pub fn i2c_add2(&mut self) -> I2C_ADD2_W<1> {
                I2C_ADD2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_oaddr2](index.html) module
        pub struct I2C_OADDR2_SPEC;
        impl crate::RegisterSpec for I2C_OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_oaddr2::R](R) reader structure
        impl crate::Readable for I2C_OADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_oaddr2::W](W) writer structure
        impl crate::Writable for I2C_OADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_OADDR2 to value 0
        impl crate::Resettable for I2C_OADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_DATAR (rw) register accessor: an alias for `Reg<I2C_DATAR_SPEC>`
    pub type I2C_DATAR = crate::Reg<i2c_datar::I2C_DATAR_SPEC>;
    ///RW, I2C data register
    pub mod i2c_datar {
        ///Register `I2C_DATAR` reader
        pub struct R(crate::R<I2C_DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_DATAR` writer
        pub struct W(crate::W<I2C_DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_DATAR` reader - RW, I2C data register
        pub type I2C_DATAR_R = crate::FieldReader;
        ///Field `I2C_DATAR` writer - RW, I2C data register
        pub type I2C_DATAR_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_DATAR_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            pub fn i2c_datar(&self) -> I2C_DATAR_R {
                I2C_DATAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            #[must_use]
            pub fn i2c_datar(&mut self) -> I2C_DATAR_W<0> {
                I2C_DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_datar](index.html) module
        pub struct I2C_DATAR_SPEC;
        impl crate::RegisterSpec for I2C_DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_datar::R](R) reader structure
        impl crate::Readable for I2C_DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_datar::W](W) writer structure
        impl crate::Writable for I2C_DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_DATAR to value 0
        impl crate::Resettable for I2C_DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_STAR1 (r) register accessor: an alias for `Reg<I2C_STAR1_SPEC>`
    pub type I2C_STAR1 = crate::Reg<i2c_star1::I2C_STAR1_SPEC>;
    ///RO, I2C stauts register 1
    pub mod i2c_star1 {
        ///Register `I2C_STAR1` reader
        pub struct R(crate::R<I2C_STAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_STAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_STAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `I2C_SB` reader - RW0, Start bit flag (Master mode)
        pub type I2C_SB_R = crate::BitReader;
        ///Field `I2C_ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag
        pub type I2C_ADDR_R = crate::BitReader;
        ///Field `I2C_BTF` reader - RO, Byte transfer finished flag
        pub type I2C_BTF_R = crate::BitReader;
        ///Field `I2C_ADD10` reader - RO, 10-bit header sent flag (Master mode)
        pub type I2C_ADD10_R = crate::BitReader;
        ///Field `I2C_STOPF` reader - RO, Stop detection flag (slave mode)
        pub type I2C_STOPF_R = crate::BitReader;
        ///Field `I2C_RxNE` reader - RO, Data register not empty flag (receivers)
        pub type I2C_RX_NE_R = crate::BitReader;
        ///Field `I2C_TxE` reader - RO, Data register empty flag (transmitters)
        pub type I2C_TX_E_R = crate::BitReader;
        ///Field `I2C_BERR` reader - RW0, Bus error flag
        pub type I2C_BERR_R = crate::BitReader;
        ///Field `I2C_ARLO` reader - RW0, Arbitration lost flag (master mode)
        pub type I2C_ARLO_R = crate::BitReader;
        ///Field `I2C_AF` reader - RW0, Acknowledge failure flag
        pub type I2C_AF_R = crate::BitReader;
        ///Field `I2C_OVR` reader - RW0, Overrun/Underrun flag
        pub type I2C_OVR_R = crate::BitReader;
        ///Field `I2C_PECERR` reader - RW0, PEC Error flag in reception
        pub type I2C_PECERR_R = crate::BitReader;
        ///Field `I2C_TIMEOUT` reader - RW0, Timeout or Tlow error flag
        pub type I2C_TIMEOUT_R = crate::BitReader;
        ///Field `I2C_SMBALERT` reader - RW0, SMBus alert flag
        pub type I2C_SMBALERT_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW0, Start bit flag (Master mode)
            #[inline(always)]
            pub fn i2c_sb(&self) -> I2C_SB_R {
                I2C_SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag
            #[inline(always)]
            pub fn i2c_addr(&self) -> I2C_ADDR_R {
                I2C_ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Byte transfer finished flag
            #[inline(always)]
            pub fn i2c_btf(&self) -> I2C_BTF_R {
                I2C_BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, 10-bit header sent flag (Master mode)
            #[inline(always)]
            pub fn i2c_add10(&self) -> I2C_ADD10_R {
                I2C_ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, Stop detection flag (slave mode)
            #[inline(always)]
            pub fn i2c_stopf(&self) -> I2C_STOPF_R {
                I2C_STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, Data register not empty flag (receivers)
            #[inline(always)]
            pub fn i2c_rx_ne(&self) -> I2C_RX_NE_R {
                I2C_RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Data register empty flag (transmitters)
            #[inline(always)]
            pub fn i2c_tx_e(&self) -> I2C_TX_E_R {
                I2C_TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW0, Bus error flag
            #[inline(always)]
            pub fn i2c_berr(&self) -> I2C_BERR_R {
                I2C_BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW0, Arbitration lost flag (master mode)
            #[inline(always)]
            pub fn i2c_arlo(&self) -> I2C_ARLO_R {
                I2C_ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW0, Acknowledge failure flag
            #[inline(always)]
            pub fn i2c_af(&self) -> I2C_AF_R {
                I2C_AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW0, Overrun/Underrun flag
            #[inline(always)]
            pub fn i2c_ovr(&self) -> I2C_OVR_R {
                I2C_OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW0, PEC Error flag in reception
            #[inline(always)]
            pub fn i2c_pecerr(&self) -> I2C_PECERR_R {
                I2C_PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW0, Timeout or Tlow error flag
            #[inline(always)]
            pub fn i2c_timeout(&self) -> I2C_TIMEOUT_R {
                I2C_TIMEOUT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW0, SMBus alert flag
            #[inline(always)]
            pub fn i2c_smbalert(&self) -> I2C_SMBALERT_R {
                I2C_SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///RO, I2C stauts register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_star1](index.html) module
        pub struct I2C_STAR1_SPEC;
        impl crate::RegisterSpec for I2C_STAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_star1::R](R) reader structure
        impl crate::Readable for I2C_STAR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets I2C_STAR1 to value 0
        impl crate::Resettable for I2C_STAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_STAR2 (r) register accessor: an alias for `Reg<I2C_STAR2_SPEC>`
    pub type I2C_STAR2 = crate::Reg<i2c_star2::I2C_STAR2_SPEC>;
    ///RO, I2C status register 2
    pub mod i2c_star2 {
        ///Register `I2C_STAR2` reader
        pub struct R(crate::R<I2C_STAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_STAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_STAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_STAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `I2C_MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode
        pub type I2C_MSL_R = crate::BitReader;
        ///Field `I2C_BUSY` reader - RO, Bus busy flag
        pub type I2C_BUSY_R = crate::BitReader;
        ///Field `I2C_TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
        pub type I2C_TRA_R = crate::BitReader;
        ///Field `I2C_GENCALL` reader - RO, General call address (Slave mode) received flag
        pub type I2C_GENCALL_R = crate::BitReader;
        ///Field `I2C_SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag
        pub type I2C_SMBDEFAULT_R = crate::BitReader;
        ///Field `I2C_SMBHOST` reader - RO, SMBus host header (Slave mode) received flag
        pub type I2C_SMBHOST_R = crate::BitReader;
        ///Field `I2C_DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
        pub type I2C_DUALF_R = crate::BitReader;
        ///Field `I2C_PECX` reader - RO, Packet error checking register
        pub type I2C_PECX_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode
            #[inline(always)]
            pub fn i2c_msl(&self) -> I2C_MSL_R {
                I2C_MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, Bus busy flag
            #[inline(always)]
            pub fn i2c_busy(&self) -> I2C_BUSY_R {
                I2C_BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
            #[inline(always)]
            pub fn i2c_tra(&self) -> I2C_TRA_R {
                I2C_TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RO, General call address (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_gencall(&self) -> I2C_GENCALL_R {
                I2C_GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SMBus device default address (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_smbdefault(&self) -> I2C_SMBDEFAULT_R {
                I2C_SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SMBus host header (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_smbhost(&self) -> I2C_SMBHOST_R {
                I2C_SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
            #[inline(always)]
            pub fn i2c_dualf(&self) -> I2C_DUALF_R {
                I2C_DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - RO, Packet error checking register
            #[inline(always)]
            pub fn i2c_pecx(&self) -> I2C_PECX_R {
                I2C_PECX_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///RO, I2C status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_star2](index.html) module
        pub struct I2C_STAR2_SPEC;
        impl crate::RegisterSpec for I2C_STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_star2::R](R) reader structure
        impl crate::Readable for I2C_STAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets I2C_STAR2 to value 0
        impl crate::Resettable for I2C_STAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_CKCFGR (rw) register accessor: an alias for `Reg<I2C_CKCFGR_SPEC>`
    pub type I2C_CKCFGR = crate::Reg<i2c_ckcfgr::I2C_CKCFGR_SPEC>;
    ///RW, I2C clock control register
    pub mod i2c_ckcfgr {
        ///Register `I2C_CKCFGR` reader
        pub struct R(crate::R<I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CKCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CKCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CKCFGR` writer
        pub struct W(crate::W<I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CKCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CKCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type I2C_CCR_R = crate::FieldReader<u16>;
        ///Field `I2C_CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type I2C_CCR_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_CKCFGR_SPEC, 12, O, u16>;
        ///Field `I2C_DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type I2C_DUTY_R = crate::BitReader;
        ///Field `I2C_DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type I2C_DUTY_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CKCFGR_SPEC, O>;
        ///Field `I2C_FS` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type I2C_FS_R = crate::BitReader;
        ///Field `I2C_FS` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type I2C_FS_W<'a, const O: u8> = crate::BitWriter<'a, I2C_CKCFGR_SPEC, O>;
        impl R {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn i2c_ccr(&self) -> I2C_CCR_R {
                I2C_CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            pub fn i2c_duty(&self) -> I2C_DUTY_R {
                I2C_DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            pub fn i2c_fs(&self) -> I2C_FS_R {
                I2C_FS_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_ccr(&mut self) -> I2C_CCR_W<0> {
                I2C_CCR_W::new(self)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            #[must_use]
            pub fn i2c_duty(&mut self) -> I2C_DUTY_W<14> {
                I2C_DUTY_W::new(self)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_fs(&mut self) -> I2C_FS_W<15> {
                I2C_FS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ckcfgr](index.html) module
        pub struct I2C_CKCFGR_SPEC;
        impl crate::RegisterSpec for I2C_CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ckcfgr::R](R) reader structure
        impl crate::Readable for I2C_CKCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ckcfgr::W](W) writer structure
        impl crate::Writable for I2C_CKCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CKCFGR to value 0
        impl crate::Resettable for I2C_CKCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_RTR (rw) register accessor: an alias for `Reg<I2C_RTR_SPEC>`
    pub type I2C_RTR = crate::Reg<i2c_rtr::I2C_RTR_SPEC>;
    ///RW, I2C trise register
    pub mod i2c_rtr {
        ///Register `I2C_RTR` reader
        pub struct R(crate::R<I2C_RTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_RTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_RTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_RTR` writer
        pub struct W(crate::W<I2C_RTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_RTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_RTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type I2C_TRISE_R = crate::FieldReader;
        ///Field `I2C_TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type I2C_TRISE_W<'a, const O: u8> = crate::FieldWriter<'a, I2C_RTR_SPEC, 6, O>;
        impl R {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn i2c_trise(&self) -> I2C_TRISE_R {
                I2C_TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_trise(&mut self) -> I2C_TRISE_W<0> {
                I2C_TRISE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C trise register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_rtr](index.html) module
        pub struct I2C_RTR_SPEC;
        impl crate::RegisterSpec for I2C_RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_rtr::R](R) reader structure
        impl crate::Readable for I2C_RTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_rtr::W](W) writer structure
        impl crate::Writable for I2C_RTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_RTR to value 0x02
        impl crate::Resettable for I2C_RTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
}
///PWMx register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMx register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, PWM output enable control
        pub pwm_out_en: PWM_OUT_EN,
        ///0x01 - RW, PWM output polarity control
        pub pwm_polar: PWM_POLAR,
        ///0x02 - RW, PWM configuration
        pub pwm_config: PWM_CONFIG,
        ///0x03 - RW, PWM clock divisor
        pub pwm_clock_div: PWM_CLOCK_DIV,
        ///0x04 - RW, PWM4 data holding
        pub pwm4_data: PWM4_DATA,
        ///0x05 - RW, PWM5 data holding
        pub pwm5_data: PWM5_DATA,
        ///0x06 - RW, PWM6 data holding
        pub pwm6_data: PWM6_DATA,
        ///0x07 - RW, PWM7 data holding
        pub pwm7_data: PWM7_DATA,
        ///0x08 - RW, PWM8 data holding
        pub pwm8_data: PWM8_DATA,
        ///0x09 - RW, PWM9 data holding
        pub pwm9_data: PWM9_DATA,
        ///0x0a - RW, PWM10 data holding
        pub pwm10_data: PWM10_DATA,
        ///0x0b - RW, PWM11 data holding
        pub pwm11_data: PWM11_DATA,
        ///0x0c - RW, PWM interrupt control
        pub pwm_int_ctrl: PWM_INT_CTRL,
        _reserved13: [u8; 0x03],
        ///0x10 - RW, PWM8/9 data register
        pub pwm_reg_data8: PWM_REG_DATA8,
        ///0x14 - RW, PWM cycle end register
        pub pwm_reg_cycle: PWM_REG_CYCLE,
    }
    ///PWM_OUT_EN (rw) register accessor: an alias for `Reg<PWM_OUT_EN_SPEC>`
    pub type PWM_OUT_EN = crate::Reg<pwm_out_en::PWM_OUT_EN_SPEC>;
    ///RW, PWM output enable control
    pub mod pwm_out_en {
        ///Register `PWM_OUT_EN` reader
        pub struct R(crate::R<PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_OUT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_OUT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_OUT_EN` writer
        pub struct W(crate::W<PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_OUT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_OUT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_OUT_EN` reader - RW, PWM4 output enable
        pub type PWM4_OUT_EN_R = crate::BitReader;
        ///Field `PWM4_OUT_EN` writer - RW, PWM4 output enable
        pub type PWM4_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM5_OUT_EN` reader - RW, PWM5 output enable
        pub type PWM5_OUT_EN_R = crate::BitReader;
        ///Field `PWM5_OUT_EN` writer - RW, PWM5 output enable
        pub type PWM5_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM6_OUT_EN` reader - RW, PWM6 output enable
        pub type PWM6_OUT_EN_R = crate::BitReader;
        ///Field `PWM6_OUT_EN` writer - RW, PWM6 output enable
        pub type PWM6_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM7_OUT_EN` reader - RW, PWM7 output enable
        pub type PWM7_OUT_EN_R = crate::BitReader;
        ///Field `PWM7_OUT_EN` writer - RW, PWM7 output enable
        pub type PWM7_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM8_OUT_EN` reader - RW, PWM8 output enable
        pub type PWM8_OUT_EN_R = crate::BitReader;
        ///Field `PWM8_OUT_EN` writer - RW, PWM8 output enable
        pub type PWM8_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM9_OUT_EN` reader - RW, PWM9 output enable
        pub type PWM9_OUT_EN_R = crate::BitReader;
        ///Field `PWM9_OUT_EN` writer - RW, PWM9 output enable
        pub type PWM9_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM10_OUT_EN` reader - RW, PWM10 output enable
        pub type PWM10_OUT_EN_R = crate::BitReader;
        ///Field `PWM10_OUT_EN` writer - RW, PWM10 output enable
        pub type PWM10_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        ///Field `PWM11_OUT_EN` reader - RW, PWM11 output enable
        pub type PWM11_OUT_EN_R = crate::BitReader;
        ///Field `PWM11_OUT_EN` writer - RW, PWM11 output enable
        pub type PWM11_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_OUT_EN_SPEC, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            pub fn pwm4_out_en(&self) -> PWM4_OUT_EN_R {
                PWM4_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            pub fn pwm5_out_en(&self) -> PWM5_OUT_EN_R {
                PWM5_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            pub fn pwm6_out_en(&self) -> PWM6_OUT_EN_R {
                PWM6_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            pub fn pwm7_out_en(&self) -> PWM7_OUT_EN_R {
                PWM7_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            pub fn pwm8_out_en(&self) -> PWM8_OUT_EN_R {
                PWM8_OUT_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            pub fn pwm9_out_en(&self) -> PWM9_OUT_EN_R {
                PWM9_OUT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            pub fn pwm10_out_en(&self) -> PWM10_OUT_EN_R {
                PWM10_OUT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            pub fn pwm11_out_en(&self) -> PWM11_OUT_EN_R {
                PWM11_OUT_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm4_out_en(&mut self) -> PWM4_OUT_EN_W<0> {
                PWM4_OUT_EN_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm5_out_en(&mut self) -> PWM5_OUT_EN_W<1> {
                PWM5_OUT_EN_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm6_out_en(&mut self) -> PWM6_OUT_EN_W<2> {
                PWM6_OUT_EN_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm7_out_en(&mut self) -> PWM7_OUT_EN_W<3> {
                PWM7_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm8_out_en(&mut self) -> PWM8_OUT_EN_W<4> {
                PWM8_OUT_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm9_out_en(&mut self) -> PWM9_OUT_EN_W<5> {
                PWM9_OUT_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm10_out_en(&mut self) -> PWM10_OUT_EN_W<6> {
                PWM10_OUT_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm11_out_en(&mut self) -> PWM11_OUT_EN_W<7> {
                PWM11_OUT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output enable control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_out_en](index.html) module
        pub struct PWM_OUT_EN_SPEC;
        impl crate::RegisterSpec for PWM_OUT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_out_en::R](R) reader structure
        impl crate::Readable for PWM_OUT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_out_en::W](W) writer structure
        impl crate::Writable for PWM_OUT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_OUT_EN to value 0
        impl crate::Resettable for PWM_OUT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_POLAR (rw) register accessor: an alias for `Reg<PWM_POLAR_SPEC>`
    pub type PWM_POLAR = crate::Reg<pwm_polar::PWM_POLAR_SPEC>;
    ///RW, PWM output polarity control
    pub mod pwm_polar {
        ///Register `PWM_POLAR` reader
        pub struct R(crate::R<PWM_POLAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_POLAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_POLAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_POLAR` writer
        pub struct W(crate::W<PWM_POLAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_POLAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_POLAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_R = crate::BitReader;
        ///Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_R = crate::BitReader;
        ///Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_R = crate::BitReader;
        ///Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_R = crate::BitReader;
        ///Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_R = crate::BitReader;
        ///Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_R = crate::BitReader;
        ///Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_R = crate::BitReader;
        ///Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        ///Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_R = crate::BitReader;
        ///Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, PWM_POLAR_SPEC, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm4_polar(&self) -> PWM4_POLAR_R {
                PWM4_POLAR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm5_polar(&self) -> PWM5_POLAR_R {
                PWM5_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm6_polar(&self) -> PWM6_POLAR_R {
                PWM6_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm7_polar(&self) -> PWM7_POLAR_R {
                PWM7_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm8_polar(&self) -> PWM8_POLAR_R {
                PWM8_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm9_polar(&self) -> PWM9_POLAR_R {
                PWM9_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm10_polar(&self) -> PWM10_POLAR_R {
                PWM10_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm11_polar(&self) -> PWM11_POLAR_R {
                PWM11_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm4_polar(&mut self) -> PWM4_POLAR_W<0> {
                PWM4_POLAR_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm5_polar(&mut self) -> PWM5_POLAR_W<1> {
                PWM5_POLAR_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm6_polar(&mut self) -> PWM6_POLAR_W<2> {
                PWM6_POLAR_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm7_polar(&mut self) -> PWM7_POLAR_W<3> {
                PWM7_POLAR_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm8_polar(&mut self) -> PWM8_POLAR_W<4> {
                PWM8_POLAR_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm9_polar(&mut self) -> PWM9_POLAR_W<5> {
                PWM9_POLAR_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm10_polar(&mut self) -> PWM10_POLAR_W<6> {
                PWM10_POLAR_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm11_polar(&mut self) -> PWM11_POLAR_W<7> {
                PWM11_POLAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output polarity control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_polar](index.html) module
        pub struct PWM_POLAR_SPEC;
        impl crate::RegisterSpec for PWM_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_polar::R](R) reader structure
        impl crate::Readable for PWM_POLAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_polar::W](W) writer structure
        impl crate::Writable for PWM_POLAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_POLAR to value 0
        impl crate::Resettable for PWM_POLAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_CONFIG (rw) register accessor: an alias for `Reg<PWM_CONFIG_SPEC>`
    pub type PWM_CONFIG = crate::Reg<pwm_config::PWM_CONFIG_SPEC>;
    ///RW, PWM configuration
    pub mod pwm_config {
        ///Register `PWM_CONFIG` reader
        pub struct R(crate::R<PWM_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_CONFIG` writer
        pub struct W(crate::W<PWM_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_R = crate::BitReader;
        ///Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_W<'a, const O: u8> = crate::BitWriter<'a, PWM_CONFIG_SPEC, O>;
        ///Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status
        pub type PWM_STAG_ST_R = crate::BitReader;
        ///Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_R = crate::FieldReader;
        ///Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_W<'a, const O: u8> = crate::FieldWriter<'a, PWM_CONFIG_SPEC, 2, O>;
        ///Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_R = crate::BitReader;
        ///Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_CONFIG_SPEC, O>;
        ///Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_R = crate::BitReader;
        ///Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_CONFIG_SPEC, O>;
        ///Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_R = crate::BitReader;
        ///Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_CONFIG_SPEC, O>;
        ///Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_R = crate::BitReader;
        ///Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_W<'a, const O: u8> = crate::BitWriter<'a, PWM_CONFIG_SPEC, O>;
        impl R {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PWM_CYCLE_SEL_R {
                PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, PWM stagger cycle status
            #[inline(always)]
            pub fn pwm_stag_st(&self) -> PWM_STAG_ST_R {
                PWM_STAG_ST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            pub fn pwm_cyc_mod(&self) -> PWM_CYC_MOD_R {
                PWM_CYC_MOD_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm4_5_stag_en(&self) -> PWM4_5_STAG_EN_R {
                PWM4_5_STAG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm6_7_stag_en(&self) -> PWM6_7_STAG_EN_R {
                PWM6_7_STAG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm8_9_stag_en(&self) -> PWM8_9_STAG_EN_R {
                PWM8_9_STAG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm10_11_stag_en(&self) -> PWM10_11_STAG_EN_R {
                PWM10_11_STAG_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            #[must_use]
            pub fn pwm_cycle_sel(&mut self) -> PWM_CYCLE_SEL_W<0> {
                PWM_CYCLE_SEL_W::new(self)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_mod(&mut self) -> PWM_CYC_MOD_W<2> {
                PWM_CYC_MOD_W::new(self)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm4_5_stag_en(&mut self) -> PWM4_5_STAG_EN_W<4> {
                PWM4_5_STAG_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm6_7_stag_en(&mut self) -> PWM6_7_STAG_EN_W<5> {
                PWM6_7_STAG_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm8_9_stag_en(&mut self) -> PWM8_9_STAG_EN_W<6> {
                PWM8_9_STAG_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm10_11_stag_en(&mut self) -> PWM10_11_STAG_EN_W<7> {
                PWM10_11_STAG_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_config](index.html) module
        pub struct PWM_CONFIG_SPEC;
        impl crate::RegisterSpec for PWM_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_config::R](R) reader structure
        impl crate::Readable for PWM_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_config::W](W) writer structure
        impl crate::Writable for PWM_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_CONFIG to value 0
        impl crate::Resettable for PWM_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_CLOCK_DIV (rw) register accessor: an alias for `Reg<PWM_CLOCK_DIV_SPEC>`
    pub type PWM_CLOCK_DIV = crate::Reg<pwm_clock_div::PWM_CLOCK_DIV_SPEC>;
    ///RW, PWM clock divisor
    pub mod pwm_clock_div {
        ///Register `PWM_CLOCK_DIV` reader
        pub struct R(crate::R<PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_CLOCK_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_CLOCK_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_CLOCK_DIV` writer
        pub struct W(crate::W<PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_CLOCK_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_CLOCK_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_R = crate::FieldReader;
        ///Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, PWM_CLOCK_DIV_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PWM_CLOCK_DIV_R {
                PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn pwm_clock_div(&mut self) -> PWM_CLOCK_DIV_W<0> {
                PWM_CLOCK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM clock divisor
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_clock_div](index.html) module
        pub struct PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_clock_div::R](R) reader structure
        impl crate::Readable for PWM_CLOCK_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_clock_div::W](W) writer structure
        impl crate::Writable for PWM_CLOCK_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_CLOCK_DIV to value 0
        impl crate::Resettable for PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM4_DATA (rw) register accessor: an alias for `Reg<PWM4_DATA_SPEC>`
    pub type PWM4_DATA = crate::Reg<pwm4_data::PWM4_DATA_SPEC>;
    ///RW, PWM4 data holding
    pub mod pwm4_data {
        ///Register `PWM4_DATA` reader
        pub struct R(crate::R<PWM4_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM4_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM4_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM4_DATA` writer
        pub struct W(crate::W<PWM4_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM4_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM4_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_DATA` reader - RW, PWM4 data holding
        pub type PWM4_DATA_R = crate::FieldReader;
        ///Field `PWM4_DATA` writer - RW, PWM4 data holding
        pub type PWM4_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM4_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            pub fn pwm4_data(&self) -> PWM4_DATA_R {
                PWM4_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm4_data(&mut self) -> PWM4_DATA_W<0> {
                PWM4_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM4 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm4_data](index.html) module
        pub struct PWM4_DATA_SPEC;
        impl crate::RegisterSpec for PWM4_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm4_data::R](R) reader structure
        impl crate::Readable for PWM4_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm4_data::W](W) writer structure
        impl crate::Writable for PWM4_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM4_DATA to value 0
        impl crate::Resettable for PWM4_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM5_DATA (rw) register accessor: an alias for `Reg<PWM5_DATA_SPEC>`
    pub type PWM5_DATA = crate::Reg<pwm5_data::PWM5_DATA_SPEC>;
    ///RW, PWM5 data holding
    pub mod pwm5_data {
        ///Register `PWM5_DATA` reader
        pub struct R(crate::R<PWM5_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM5_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM5_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM5_DATA` writer
        pub struct W(crate::W<PWM5_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM5_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM5_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM5_DATA` reader - RW, PWM5 data holding
        pub type PWM5_DATA_R = crate::FieldReader;
        ///Field `PWM5_DATA` writer - RW, PWM5 data holding
        pub type PWM5_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM5_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            pub fn pwm5_data(&self) -> PWM5_DATA_R {
                PWM5_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm5_data(&mut self) -> PWM5_DATA_W<0> {
                PWM5_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM5 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm5_data](index.html) module
        pub struct PWM5_DATA_SPEC;
        impl crate::RegisterSpec for PWM5_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm5_data::R](R) reader structure
        impl crate::Readable for PWM5_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm5_data::W](W) writer structure
        impl crate::Writable for PWM5_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM5_DATA to value 0
        impl crate::Resettable for PWM5_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM6_DATA (rw) register accessor: an alias for `Reg<PWM6_DATA_SPEC>`
    pub type PWM6_DATA = crate::Reg<pwm6_data::PWM6_DATA_SPEC>;
    ///RW, PWM6 data holding
    pub mod pwm6_data {
        ///Register `PWM6_DATA` reader
        pub struct R(crate::R<PWM6_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM6_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM6_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM6_DATA` writer
        pub struct W(crate::W<PWM6_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM6_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM6_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM6_DATA` reader - RW, PWM6 data holding
        pub type PWM6_DATA_R = crate::FieldReader;
        ///Field `PWM6_DATA` writer - RW, PWM6 data holding
        pub type PWM6_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM6_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            pub fn pwm6_data(&self) -> PWM6_DATA_R {
                PWM6_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm6_data(&mut self) -> PWM6_DATA_W<0> {
                PWM6_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM6 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm6_data](index.html) module
        pub struct PWM6_DATA_SPEC;
        impl crate::RegisterSpec for PWM6_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm6_data::R](R) reader structure
        impl crate::Readable for PWM6_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm6_data::W](W) writer structure
        impl crate::Writable for PWM6_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM6_DATA to value 0
        impl crate::Resettable for PWM6_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM7_DATA (rw) register accessor: an alias for `Reg<PWM7_DATA_SPEC>`
    pub type PWM7_DATA = crate::Reg<pwm7_data::PWM7_DATA_SPEC>;
    ///RW, PWM7 data holding
    pub mod pwm7_data {
        ///Register `PWM7_DATA` reader
        pub struct R(crate::R<PWM7_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM7_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM7_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM7_DATA` writer
        pub struct W(crate::W<PWM7_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM7_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM7_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM7_DATA` reader - RW, PWM7 data holding
        pub type PWM7_DATA_R = crate::FieldReader;
        ///Field `PWM7_DATA` writer - RW, PWM7 data holding
        pub type PWM7_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM7_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            pub fn pwm7_data(&self) -> PWM7_DATA_R {
                PWM7_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm7_data(&mut self) -> PWM7_DATA_W<0> {
                PWM7_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM7 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm7_data](index.html) module
        pub struct PWM7_DATA_SPEC;
        impl crate::RegisterSpec for PWM7_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm7_data::R](R) reader structure
        impl crate::Readable for PWM7_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm7_data::W](W) writer structure
        impl crate::Writable for PWM7_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM7_DATA to value 0
        impl crate::Resettable for PWM7_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM8_DATA (rw) register accessor: an alias for `Reg<PWM8_DATA_SPEC>`
    pub type PWM8_DATA = crate::Reg<pwm8_data::PWM8_DATA_SPEC>;
    ///RW, PWM8 data holding
    pub mod pwm8_data {
        ///Register `PWM8_DATA` reader
        pub struct R(crate::R<PWM8_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM8_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM8_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM8_DATA` writer
        pub struct W(crate::W<PWM8_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM8_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM8_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM8_DATA` reader - RW, PWM8 data holding
        pub type PWM8_DATA_R = crate::FieldReader;
        ///Field `PWM8_DATA` writer - RW, PWM8 data holding
        pub type PWM8_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM8_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            pub fn pwm8_data(&self) -> PWM8_DATA_R {
                PWM8_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm8_data(&mut self) -> PWM8_DATA_W<0> {
                PWM8_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM8 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm8_data](index.html) module
        pub struct PWM8_DATA_SPEC;
        impl crate::RegisterSpec for PWM8_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm8_data::R](R) reader structure
        impl crate::Readable for PWM8_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm8_data::W](W) writer structure
        impl crate::Writable for PWM8_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM8_DATA to value 0
        impl crate::Resettable for PWM8_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM9_DATA (rw) register accessor: an alias for `Reg<PWM9_DATA_SPEC>`
    pub type PWM9_DATA = crate::Reg<pwm9_data::PWM9_DATA_SPEC>;
    ///RW, PWM9 data holding
    pub mod pwm9_data {
        ///Register `PWM9_DATA` reader
        pub struct R(crate::R<PWM9_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM9_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM9_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM9_DATA` writer
        pub struct W(crate::W<PWM9_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM9_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM9_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM9_DATA` reader - RW, PWM9 data holding
        pub type PWM9_DATA_R = crate::FieldReader;
        ///Field `PWM9_DATA` writer - RW, PWM9 data holding
        pub type PWM9_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM9_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            pub fn pwm9_data(&self) -> PWM9_DATA_R {
                PWM9_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm9_data(&mut self) -> PWM9_DATA_W<0> {
                PWM9_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM9 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm9_data](index.html) module
        pub struct PWM9_DATA_SPEC;
        impl crate::RegisterSpec for PWM9_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm9_data::R](R) reader structure
        impl crate::Readable for PWM9_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm9_data::W](W) writer structure
        impl crate::Writable for PWM9_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM9_DATA to value 0
        impl crate::Resettable for PWM9_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM10_DATA (rw) register accessor: an alias for `Reg<PWM10_DATA_SPEC>`
    pub type PWM10_DATA = crate::Reg<pwm10_data::PWM10_DATA_SPEC>;
    ///RW, PWM10 data holding
    pub mod pwm10_data {
        ///Register `PWM10_DATA` reader
        pub struct R(crate::R<PWM10_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM10_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM10_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM10_DATA` writer
        pub struct W(crate::W<PWM10_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM10_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM10_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM10_DATA` reader - RW, PWM10 data holding
        pub type PWM10_DATA_R = crate::FieldReader;
        ///Field `PWM10_DATA` writer - RW, PWM10 data holding
        pub type PWM10_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM10_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            pub fn pwm10_data(&self) -> PWM10_DATA_R {
                PWM10_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm10_data(&mut self) -> PWM10_DATA_W<0> {
                PWM10_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM10 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm10_data](index.html) module
        pub struct PWM10_DATA_SPEC;
        impl crate::RegisterSpec for PWM10_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm10_data::R](R) reader structure
        impl crate::Readable for PWM10_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm10_data::W](W) writer structure
        impl crate::Writable for PWM10_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM10_DATA to value 0
        impl crate::Resettable for PWM10_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM11_DATA (rw) register accessor: an alias for `Reg<PWM11_DATA_SPEC>`
    pub type PWM11_DATA = crate::Reg<pwm11_data::PWM11_DATA_SPEC>;
    ///RW, PWM11 data holding
    pub mod pwm11_data {
        ///Register `PWM11_DATA` reader
        pub struct R(crate::R<PWM11_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM11_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM11_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM11_DATA` writer
        pub struct W(crate::W<PWM11_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM11_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM11_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM11_DATA` reader - RW, PWM11 data holding
        pub type PWM11_DATA_R = crate::FieldReader;
        ///Field `PWM11_DATA` writer - RW, PWM11 data holding
        pub type PWM11_DATA_W<'a, const O: u8> = crate::FieldWriter<'a, PWM11_DATA_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            pub fn pwm11_data(&self) -> PWM11_DATA_R {
                PWM11_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm11_data(&mut self) -> PWM11_DATA_W<0> {
                PWM11_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM11 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm11_data](index.html) module
        pub struct PWM11_DATA_SPEC;
        impl crate::RegisterSpec for PWM11_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm11_data::R](R) reader structure
        impl crate::Readable for PWM11_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm11_data::W](W) writer structure
        impl crate::Writable for PWM11_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM11_DATA to value 0
        impl crate::Resettable for PWM11_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_INT_CTRL (rw) register accessor: an alias for `Reg<PWM_INT_CTRL_SPEC>`
    pub type PWM_INT_CTRL = crate::Reg<pwm_int_ctrl::PWM_INT_CTRL_SPEC>;
    ///RW, PWM interrupt control
    pub mod pwm_int_ctrl {
        ///Register `PWM_INT_CTRL` reader
        pub struct R(crate::R<PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_INT_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_INT_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_INT_CTRL` writer
        pub struct W(crate::W<PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_INT_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_INT_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_R = crate::BitReader;
        ///Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_W<'a, const O: u8> = crate::BitWriter<'a, PWM_INT_CTRL_SPEC, O>;
        ///Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_R = crate::BitReader;
        ///Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_W<'a, const O: u8> = crate::BitWriter<'a, PWM_INT_CTRL_SPEC, O>;
        ///Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_R = crate::BitReader;
        ///Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_W<'a, const O: u8> = crate::BitWriter<'a, PWM_INT_CTRL_SPEC, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            pub fn pwm_ie_cyc(&self) -> PWM_IE_CYC_R {
                PWM_IE_CYC_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            pub fn pwm_cyc_pre(&self) -> PWM_CYC_PRE_R {
                PWM_CYC_PRE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            pub fn pwm_if_cyc(&self) -> PWM_IF_CYC_R {
                PWM_IF_CYC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_ie_cyc(&mut self) -> PWM_IE_CYC_W<0> {
                PWM_IE_CYC_W::new(self)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_pre(&mut self) -> PWM_CYC_PRE_W<1> {
                PWM_CYC_PRE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_if_cyc(&mut self) -> PWM_IF_CYC_W<7> {
                PWM_IF_CYC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM interrupt control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_int_ctrl](index.html) module
        pub struct PWM_INT_CTRL_SPEC;
        impl crate::RegisterSpec for PWM_INT_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_int_ctrl::R](R) reader structure
        impl crate::Readable for PWM_INT_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_int_ctrl::W](W) writer structure
        impl crate::Writable for PWM_INT_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_INT_CTRL to value 0
        impl crate::Resettable for PWM_INT_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_REG_DATA8 (rw) register accessor: an alias for `Reg<PWM_REG_DATA8_SPEC>`
    pub type PWM_REG_DATA8 = crate::Reg<pwm_reg_data8::PWM_REG_DATA8_SPEC>;
    ///RW, PWM8/9 data register
    pub mod pwm_reg_data8 {
        ///Register `PWM_REG_DATA8` reader
        pub struct R(crate::R<PWM_REG_DATA8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_REG_DATA8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_REG_DATA8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_REG_DATA8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_REG_DATA8` writer
        pub struct W(crate::W<PWM_REG_DATA8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_REG_DATA8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_REG_DATA8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_REG_DATA8_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM8_REG_DATA` reader - RW, 16 bit data of PWM8 channel
        pub type PWM8_REG_DATA_R = crate::FieldReader<u16>;
        ///Field `PWM8_REG_DATA` writer - RW, 16 bit data of PWM8 channel
        pub type PWM8_REG_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, PWM_REG_DATA8_SPEC, 16, O, u16>;
        ///Field `PWM9_REG_DATA` reader - RW, 16 bit data of PWM9 channel
        pub type PWM9_REG_DATA_R = crate::FieldReader<u16>;
        ///Field `PWM9_REG_DATA` writer - RW, 16 bit data of PWM9 channel
        pub type PWM9_REG_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, PWM_REG_DATA8_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, 16 bit data of PWM8 channel
            #[inline(always)]
            pub fn pwm8_reg_data(&self) -> PWM8_REG_DATA_R {
                PWM8_REG_DATA_R::new((self.bits & 0xffff) as u16)
            }
            ///Bits 16:31 - RW, 16 bit data of PWM9 channel
            #[inline(always)]
            pub fn pwm9_reg_data(&self) -> PWM9_REG_DATA_R {
                PWM9_REG_DATA_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - RW, 16 bit data of PWM8 channel
            #[inline(always)]
            #[must_use]
            pub fn pwm8_reg_data(&mut self) -> PWM8_REG_DATA_W<0> {
                PWM8_REG_DATA_W::new(self)
            }
            ///Bits 16:31 - RW, 16 bit data of PWM9 channel
            #[inline(always)]
            #[must_use]
            pub fn pwm9_reg_data(&mut self) -> PWM9_REG_DATA_W<16> {
                PWM9_REG_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM8/9 data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_reg_data8](index.html) module
        pub struct PWM_REG_DATA8_SPEC;
        impl crate::RegisterSpec for PWM_REG_DATA8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pwm_reg_data8::R](R) reader structure
        impl crate::Readable for PWM_REG_DATA8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_reg_data8::W](W) writer structure
        impl crate::Writable for PWM_REG_DATA8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_REG_DATA8 to value 0
        impl crate::Resettable for PWM_REG_DATA8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_REG_CYCLE (rw) register accessor: an alias for `Reg<PWM_REG_CYCLE_SPEC>`
    pub type PWM_REG_CYCLE = crate::Reg<pwm_reg_cycle::PWM_REG_CYCLE_SPEC>;
    ///RW, PWM cycle end register
    pub mod pwm_reg_cycle {
        ///Register `PWM_REG_CYCLE` reader
        pub struct R(crate::R<PWM_REG_CYCLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_REG_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_REG_CYCLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_REG_CYCLE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_REG_CYCLE` writer
        pub struct W(crate::W<PWM_REG_CYCLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_REG_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_REG_CYCLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_REG_CYCLE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_CYC_VALUE` reader - RW, PWM End Cycles
        pub type PWM_CYC_VALUE_R = crate::FieldReader<u16>;
        ///Field `PWM_CYC_VALUE` writer - RW, PWM End Cycles
        pub type PWM_CYC_VALUE_W<'a, const O: u8> =
            crate::FieldWriter<'a, PWM_REG_CYCLE_SPEC, 16, O, u16>;
        impl R {
            ///Bits 0:15 - RW, PWM End Cycles
            #[inline(always)]
            pub fn pwm_cyc_value(&self) -> PWM_CYC_VALUE_R {
                PWM_CYC_VALUE_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - RW, PWM End Cycles
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_value(&mut self) -> PWM_CYC_VALUE_W<0> {
                PWM_CYC_VALUE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM cycle end register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_reg_cycle](index.html) module
        pub struct PWM_REG_CYCLE_SPEC;
        impl crate::RegisterSpec for PWM_REG_CYCLE_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pwm_reg_cycle::R](R) reader structure
        impl crate::Readable for PWM_REG_CYCLE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_reg_cycle::W](W) writer structure
        impl crate::Writable for PWM_REG_CYCLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_REG_CYCLE to value 0
        impl crate::Resettable for PWM_REG_CYCLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///LCD register
pub struct LCD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LCD {}
impl LCD {
    ///Pointer to the register block
    pub const PTR: *const lcd::RegisterBlock = 0x4000_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lcd::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LCD {
    type Target = lcd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LCD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LCD").finish()
    }
}
///LCD register
pub mod lcd {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, LCD Command Register
        pub cmd: CMD,
        ///0x04 - RW, LCD RAM0 register
        pub ram0: RAM0,
        ///0x08 - RW, LCD RAM1 register
        pub ram1: RAM1,
        ///0x0c - RW, LCD RAM2 register
        pub ram2: RAM2,
    }
    ///CMD (rw) register accessor: an alias for `Reg<CMD_SPEC>`
    pub type CMD = crate::Reg<cmd::CMD_SPEC>;
    ///RW, LCD Command Register
    pub mod cmd {
        ///Register `CMD` reader
        pub struct R(crate::R<CMD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CMD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CMD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CMD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CMD` writer
        pub struct W(crate::W<CMD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CMD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CMD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CMD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SYS_EN` reader - RW, System Enable
        pub type SYS_EN_R = crate::BitReader;
        ///Field `SYS_EN` writer - RW, System Enable
        pub type SYS_EN_W<'a, const O: u8> = crate::BitWriter<'a, CMD_SPEC, O>;
        ///Field `ON` reader - RW, LCD switch
        pub type ON_R = crate::BitReader;
        ///Field `ON` writer - RW, LCD switch
        pub type ON_W<'a, const O: u8> = crate::BitWriter<'a, CMD_SPEC, O>;
        ///Field `BIAS` reader - RW, PWM6 Bias ratio selection enable
        pub type BIAS_R = crate::BitReader;
        ///Field `BIAS` writer - RW, PWM6 Bias ratio selection enable
        pub type BIAS_W<'a, const O: u8> = crate::BitWriter<'a, CMD_SPEC, O>;
        ///Field `DUTY` reader - RW, LCD duty cycle selection
        pub type DUTY_R = crate::FieldReader;
        ///Field `DUTY` writer - RW, LCD duty cycle selection
        pub type DUTY_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 2, O>;
        ///Field `SCAN_CLK_SEL` reader - RW, Scan clock selection
        pub type SCAN_CLK_SEL_R = crate::FieldReader;
        ///Field `SCAN_CLK_SEL` writer - RW, Scan clock selection
        pub type SCAN_CLK_SEL_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 2, O>;
        ///Field `VLCD_SEL` reader - RW, LCD driver voltage selection
        pub type VLCD_SEL_R = crate::BitReader;
        ///Field `VLCD_SEL` writer - RW, LCD driver voltage selection
        pub type VLCD_SEL_W<'a, const O: u8> = crate::BitWriter<'a, CMD_SPEC, O>;
        ///Field `SEG_0_7_EN` reader - RW, Enabling SEG0-SEG7 segments
        pub type SEG_0_7_EN_R = crate::FieldReader;
        ///Field `SEG_0_7_EN` writer - RW, Enabling SEG0-SEG7 segments
        pub type SEG_0_7_EN_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 8, O>;
        ///Field `SEG_EN` reader - LCD segment enable, SEG0~SEG23
        pub type SEG_EN_R = crate::FieldReader<u32>;
        ///Field `SEG_EN` writer - LCD segment enable, SEG0~SEG23
        pub type SEG_EN_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 20, O, u32>;
        ///Field `SEG_8_15_EN` reader - RW, Enabling SEG8-SEG15 segments
        pub type SEG_8_15_EN_R = crate::FieldReader;
        ///Field `SEG_8_15_EN` writer - RW, Enabling SEG8-SEG15 segments
        pub type SEG_8_15_EN_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 8, O>;
        ///Field `SEG_16_19_EN` reader - RW, Enabling SEG16-SEG19 segments
        pub type SEG_16_19_EN_R = crate::FieldReader;
        ///Field `SEG_16_19_EN` writer - RW, Enabling SEG16-SEG19 segments
        pub type SEG_16_19_EN_W<'a, const O: u8> = crate::FieldWriter<'a, CMD_SPEC, 4, O>;
        impl R {
            ///Bit 0 - RW, System Enable
            #[inline(always)]
            pub fn sys_en(&self) -> SYS_EN_R {
                SYS_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, LCD switch
            #[inline(always)]
            pub fn on(&self) -> ON_R {
                ON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 Bias ratio selection enable
            #[inline(always)]
            pub fn bias(&self) -> BIAS_R {
                BIAS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - RW, LCD duty cycle selection
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 3) & 3) as u8)
            }
            ///Bits 5:6 - RW, Scan clock selection
            #[inline(always)]
            pub fn scan_clk_sel(&self) -> SCAN_CLK_SEL_R {
                SCAN_CLK_SEL_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - RW, LCD driver voltage selection
            #[inline(always)]
            pub fn vlcd_sel(&self) -> VLCD_SEL_R {
                VLCD_SEL_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - RW, Enabling SEG0-SEG7 segments
            #[inline(always)]
            pub fn seg_0_7_en(&self) -> SEG_0_7_EN_R {
                SEG_0_7_EN_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 8:27 - LCD segment enable, SEG0~SEG23
            #[inline(always)]
            pub fn seg_en(&self) -> SEG_EN_R {
                SEG_EN_R::new((self.bits >> 8) & 0x000f_ffff)
            }
            ///Bits 16:23 - RW, Enabling SEG8-SEG15 segments
            #[inline(always)]
            pub fn seg_8_15_en(&self) -> SEG_8_15_EN_R {
                SEG_8_15_EN_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:27 - RW, Enabling SEG16-SEG19 segments
            #[inline(always)]
            pub fn seg_16_19_en(&self) -> SEG_16_19_EN_R {
                SEG_16_19_EN_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bit 0 - RW, System Enable
            #[inline(always)]
            #[must_use]
            pub fn sys_en(&mut self) -> SYS_EN_W<0> {
                SYS_EN_W::new(self)
            }
            ///Bit 1 - RW, LCD switch
            #[inline(always)]
            #[must_use]
            pub fn on(&mut self) -> ON_W<1> {
                ON_W::new(self)
            }
            ///Bit 2 - RW, PWM6 Bias ratio selection enable
            #[inline(always)]
            #[must_use]
            pub fn bias(&mut self) -> BIAS_W<2> {
                BIAS_W::new(self)
            }
            ///Bits 3:4 - RW, LCD duty cycle selection
            #[inline(always)]
            #[must_use]
            pub fn duty(&mut self) -> DUTY_W<3> {
                DUTY_W::new(self)
            }
            ///Bits 5:6 - RW, Scan clock selection
            #[inline(always)]
            #[must_use]
            pub fn scan_clk_sel(&mut self) -> SCAN_CLK_SEL_W<5> {
                SCAN_CLK_SEL_W::new(self)
            }
            ///Bit 7 - RW, LCD driver voltage selection
            #[inline(always)]
            #[must_use]
            pub fn vlcd_sel(&mut self) -> VLCD_SEL_W<7> {
                VLCD_SEL_W::new(self)
            }
            ///Bits 8:15 - RW, Enabling SEG0-SEG7 segments
            #[inline(always)]
            #[must_use]
            pub fn seg_0_7_en(&mut self) -> SEG_0_7_EN_W<8> {
                SEG_0_7_EN_W::new(self)
            }
            ///Bits 8:27 - LCD segment enable, SEG0~SEG23
            #[inline(always)]
            #[must_use]
            pub fn seg_en(&mut self) -> SEG_EN_W<8> {
                SEG_EN_W::new(self)
            }
            ///Bits 16:23 - RW, Enabling SEG8-SEG15 segments
            #[inline(always)]
            #[must_use]
            pub fn seg_8_15_en(&mut self) -> SEG_8_15_EN_W<16> {
                SEG_8_15_EN_W::new(self)
            }
            ///Bits 24:27 - RW, Enabling SEG16-SEG19 segments
            #[inline(always)]
            #[must_use]
            pub fn seg_16_19_en(&mut self) -> SEG_16_19_EN_W<24> {
                SEG_16_19_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, LCD Command Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cmd](index.html) module
        pub struct CMD_SPEC;
        impl crate::RegisterSpec for CMD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cmd::R](R) reader structure
        impl crate::Readable for CMD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cmd::W](W) writer structure
        impl crate::Writable for CMD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CMD to value 0
        impl crate::Resettable for CMD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RAM0 (rw) register accessor: an alias for `Reg<RAM0_SPEC>`
    pub type RAM0 = crate::Reg<ram0::RAM0_SPEC>;
    ///RW, LCD RAM0 register
    pub mod ram0 {
        ///Register `RAM0` reader
        pub struct R(crate::R<RAM0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RAM0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RAM0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RAM0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RAM0` writer
        pub struct W(crate::W<RAM0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RAM0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RAM0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RAM0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SEG[0-7]` reader - RW, SEG%s segment data
        pub type SEG_R = crate::FieldReader;
        ///Field `SEG[0-7]` writer - RW, SEG%s segment data
        pub type SEG_W<'a, const O: u8> = crate::FieldWriter<'a, RAM0_SPEC, 4, O>;
        impl R {
            ///RW, SEG[0-7]
            ///segment data
            #[inline(always)]
            pub unsafe fn seg(&self, n: u8) -> SEG_R {
                SEG_R::new(((self.bits >> (n * 4)) & 0x0f) as u8)
            }
            ///Bits 0:3 - RW, SEG0 segment data
            #[inline(always)]
            pub fn seg0(&self) -> SEG_R {
                SEG_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - RW, SEG1 segment data
            #[inline(always)]
            pub fn seg1(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - RW, SEG2 segment data
            #[inline(always)]
            pub fn seg2(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - RW, SEG3 segment data
            #[inline(always)]
            pub fn seg3(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 16:19 - RW, SEG4 segment data
            #[inline(always)]
            pub fn seg4(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            ///Bits 20:23 - RW, SEG5 segment data
            #[inline(always)]
            pub fn seg5(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 24:27 - RW, SEG6 segment data
            #[inline(always)]
            pub fn seg6(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bits 28:31 - RW, SEG7 segment data
            #[inline(always)]
            pub fn seg7(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            ///RW, SEG[0-7]
            ///segment data
            #[inline(always)]
            #[must_use]
            pub unsafe fn seg<const O: u8>(&mut self) -> SEG_W<O> {
                SEG_W::new(self)
            }
            ///Bits 0:3 - RW, SEG0 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg0(&mut self) -> SEG_W<0> {
                SEG_W::new(self)
            }
            ///Bits 4:7 - RW, SEG1 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg1(&mut self) -> SEG_W<4> {
                SEG_W::new(self)
            }
            ///Bits 8:11 - RW, SEG2 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg2(&mut self) -> SEG_W<8> {
                SEG_W::new(self)
            }
            ///Bits 12:15 - RW, SEG3 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg3(&mut self) -> SEG_W<12> {
                SEG_W::new(self)
            }
            ///Bits 16:19 - RW, SEG4 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg4(&mut self) -> SEG_W<16> {
                SEG_W::new(self)
            }
            ///Bits 20:23 - RW, SEG5 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg5(&mut self) -> SEG_W<20> {
                SEG_W::new(self)
            }
            ///Bits 24:27 - RW, SEG6 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg6(&mut self) -> SEG_W<24> {
                SEG_W::new(self)
            }
            ///Bits 28:31 - RW, SEG7 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg7(&mut self) -> SEG_W<28> {
                SEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, LCD RAM0 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ram0](index.html) module
        pub struct RAM0_SPEC;
        impl crate::RegisterSpec for RAM0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ram0::R](R) reader structure
        impl crate::Readable for RAM0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ram0::W](W) writer structure
        impl crate::Writable for RAM0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RAM0 to value 0
        impl crate::Resettable for RAM0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RAM1 (rw) register accessor: an alias for `Reg<RAM1_SPEC>`
    pub type RAM1 = crate::Reg<ram1::RAM1_SPEC>;
    ///RW, LCD RAM1 register
    pub mod ram1 {
        ///Register `RAM1` reader
        pub struct R(crate::R<RAM1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RAM1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RAM1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RAM1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RAM1` writer
        pub struct W(crate::W<RAM1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RAM1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RAM1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RAM1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SEG[8-15]` reader - RW, SEG8 segment data
        pub type SEG_R = crate::FieldReader;
        ///Field `SEG[8-15]` writer - RW, SEG8 segment data
        pub type SEG_W<'a, const O: u8> = crate::FieldWriter<'a, RAM1_SPEC, 4, O>;
        impl R {
            ///RW, SEG8 segment data
            #[inline(always)]
            pub unsafe fn seg(&self, n: u8) -> SEG_R {
                SEG_R::new(((self.bits >> ((n - 8) * 4)) & 0x0f) as u8)
            }
            ///Bits 0:3 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg8(&self) -> SEG_R {
                SEG_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg9(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg10(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg11(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 16:19 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg12(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            ///Bits 20:23 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg13(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 24:27 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg14(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bits 28:31 - RW, SEG8 segment data
            #[inline(always)]
            pub fn seg15(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            ///RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub unsafe fn seg<const O: u8>(&mut self) -> SEG_W<O> {
                SEG_W::new(self)
            }
            ///Bits 0:3 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg8(&mut self) -> SEG_W<0> {
                SEG_W::new(self)
            }
            ///Bits 4:7 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg9(&mut self) -> SEG_W<4> {
                SEG_W::new(self)
            }
            ///Bits 8:11 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg10(&mut self) -> SEG_W<8> {
                SEG_W::new(self)
            }
            ///Bits 12:15 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg11(&mut self) -> SEG_W<12> {
                SEG_W::new(self)
            }
            ///Bits 16:19 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg12(&mut self) -> SEG_W<16> {
                SEG_W::new(self)
            }
            ///Bits 20:23 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg13(&mut self) -> SEG_W<20> {
                SEG_W::new(self)
            }
            ///Bits 24:27 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg14(&mut self) -> SEG_W<24> {
                SEG_W::new(self)
            }
            ///Bits 28:31 - RW, SEG8 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg15(&mut self) -> SEG_W<28> {
                SEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, LCD RAM1 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ram1](index.html) module
        pub struct RAM1_SPEC;
        impl crate::RegisterSpec for RAM1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ram1::R](R) reader structure
        impl crate::Readable for RAM1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ram1::W](W) writer structure
        impl crate::Writable for RAM1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RAM1 to value 0
        impl crate::Resettable for RAM1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RAM2 (rw) register accessor: an alias for `Reg<RAM2_SPEC>`
    pub type RAM2 = crate::Reg<ram2::RAM2_SPEC>;
    ///RW, LCD RAM2 register
    pub mod ram2 {
        ///Register `RAM2` reader
        pub struct R(crate::R<RAM2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RAM2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RAM2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RAM2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RAM2` writer
        pub struct W(crate::W<RAM2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RAM2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RAM2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RAM2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SEG[16-19]` reader - RW, SEG16 segment data
        pub type SEG_R = crate::FieldReader;
        ///Field `SEG[16-19]` writer - RW, SEG16 segment data
        pub type SEG_W<'a, const O: u8> = crate::FieldWriter<'a, RAM2_SPEC, 4, O>;
        impl R {
            ///RW, SEG16 segment data
            #[inline(always)]
            pub unsafe fn seg(&self, n: u8) -> SEG_R {
                SEG_R::new(((self.bits >> ((n - 16) * 4)) & 0x0f) as u8)
            }
            ///Bits 0:3 - RW, SEG16 segment data
            #[inline(always)]
            pub fn seg16(&self) -> SEG_R {
                SEG_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - RW, SEG16 segment data
            #[inline(always)]
            pub fn seg17(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - RW, SEG16 segment data
            #[inline(always)]
            pub fn seg18(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - RW, SEG16 segment data
            #[inline(always)]
            pub fn seg19(&self) -> SEG_R {
                SEG_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///RW, SEG16 segment data
            #[inline(always)]
            #[must_use]
            pub unsafe fn seg<const O: u8>(&mut self) -> SEG_W<O> {
                SEG_W::new(self)
            }
            ///Bits 0:3 - RW, SEG16 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg16(&mut self) -> SEG_W<0> {
                SEG_W::new(self)
            }
            ///Bits 4:7 - RW, SEG16 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg17(&mut self) -> SEG_W<4> {
                SEG_W::new(self)
            }
            ///Bits 8:11 - RW, SEG16 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg18(&mut self) -> SEG_W<8> {
                SEG_W::new(self)
            }
            ///Bits 12:15 - RW, SEG16 segment data
            #[inline(always)]
            #[must_use]
            pub fn seg19(&mut self) -> SEG_W<12> {
                SEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, LCD RAM2 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ram2](index.html) module
        pub struct RAM2_SPEC;
        impl crate::RegisterSpec for RAM2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ram2::R](R) reader structure
        impl crate::Readable for RAM2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ram2::W](W) writer structure
        impl crate::Writable for RAM2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RAM2 to value 0
        impl crate::Resettable for RAM2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB register
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    ///Pointer to the register block
    pub const PTR: *const usb::RegisterBlock = 0x4000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
///USB register
pub mod usb {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB base control
        pub usb_ctrl: USB_CTRL,
        ///0x01 - USB device physical prot control
        pub udev_ctrl: UDEV_CTRL,
        ///0x02 - USB interrupt enable
        pub usb_int_en: USB_INT_EN,
        ///0x03 - USB device address
        pub usb_dev_ad: USB_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB miscellaneous status
        pub usb_mis_st: USB_MIS_ST,
        ///0x06 - USB interrupt flag
        pub usb_int_fg: USB_INT_FG,
        ///0x07 - USB interrupt status
        pub usb_int_st: USB_INT_ST,
        ///0x08 - USB receiving length
        pub usb_rx_len: USB_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 1/4 mode
        pub uep4_1_mod: UEP4_1_MOD,
        ///0x0d - endpoint 2/3 mode;host endpoint mode
        pub uep2_3_mod: UEP2_3_MOD,
        ///0x0e - endpoint 5/6/7 mode
        pub uep567_mod: UEP567_MOD,
        _reserved11: [u8; 0x01],
        ///0x10 - endpoint 0 DMA buffer address
        pub uep0_dma: UEP0_DMA,
        _reserved12: [u8; 0x02],
        ///0x14 - endpoint 1 DMA buffer address
        pub uep1_dma: UEP1_DMA,
        _reserved13: [u8; 0x02],
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub uep2_dma: UEP2_DMA,
        _reserved14: [u8; 0x02],
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub uep3_dma: UEP3_DMA,
        _reserved15: [u8; 0x02],
        ///0x20 - endpoint 0 transmittal length
        pub uep0_t_len: UEP0_T_LEN,
        _reserved16: [u8; 0x01],
        ///0x22 - endpoint 0 control
        pub uep0_ctrl: UEP0_CTRL,
        _reserved17: [u8; 0x01],
        ///0x24 - endpoint 1 transmittal length
        pub uep1_t_len: UEP1_T_LEN,
        _reserved18: [u8; 0x01],
        ///0x26 - endpoint 1 control;host aux setup
        pub uep1_ctrl: UEP1_CTRL,
        _reserved19: [u8; 0x01],
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        pub uep2_t_len: UEP2_T_LEN,
        _reserved20: [u8; 0x01],
        ///0x2a - endpoint 2 control;host receiver endpoint control
        pub uep2_ctrl: UEP2_CTRL,
        _reserved21: [u8; 0x01],
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub uep3_t_len: UEP3_T_LEN,
        _reserved22: [u8; 0x01],
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        pub uep3_ctrl: UEP3_CTRL,
        _reserved23: [u8; 0x01],
        ///0x30 - endpoint 4 transmittal length
        pub uep4_t_len: UEP4_T_LEN,
        _reserved24: [u8; 0x01],
        ///0x32 - endpoint 4 control
        pub uep4_ctrl: UEP4_CTRL,
        _reserved25: [u8; 0x21],
        ///0x54 - endpoint 5 DMA buffer address
        pub uep5_dma: UEP5_DMA,
        _reserved26: [u8; 0x02],
        ///0x58 - endpoint 6 DMA buffer address
        pub uep6_dma: UEP6_DMA,
        _reserved27: [u8; 0x02],
        ///0x5c - endpoint 7 DMA buffer address
        pub uep7_dma: UEP7_DMA,
        _reserved28: [u8; 0x06],
        ///0x64 - endpoint 5 transmittal length
        pub uep5_t_len: UEP5_T_LEN,
        _reserved29: [u8; 0x01],
        ///0x66 - endpoint 5 control
        pub uep5_ctrl: UEP5_CTRL,
        _reserved30: [u8; 0x01],
        ///0x68 - endpoint 6 transmittal length
        pub uep6_t_len: UEP6_T_LEN,
        _reserved31: [u8; 0x01],
        ///0x6a - endpoint 6 control
        pub uep6_ctrl: UEP6_CTRL,
        _reserved32: [u8; 0x01],
        ///0x6c - endpoint 7 transmittal length
        pub uep7_t_len: UEP7_T_LEN,
        _reserved33: [u8; 0x01],
        ///0x6e - endpoint 7 control
        pub uep7_ctrl: UEP7_CTRL,
    }
    ///USB_CTRL (rw) register accessor: an alias for `Reg<USB_CTRL_SPEC>`
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub struct R(crate::R<USB_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_CTRL` writer
        pub struct W(crate::W<USB_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> = crate::FieldWriter<'a, USB_CTRL_SPEC, 2, O>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, const O: u8> = crate::BitWriter<'a, USB_CTRL_SPEC, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<0> {
                UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<1> {
                UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<2> {
                UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<3> {
                UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<5> {
                UC_DEV_PU_EN_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<6> {
                UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<7> {
                UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_ctrl](index.html) module
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_ctrl::R](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_ctrl::W](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0x06
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x06;
        }
    }
    ///UDEV_CTRL (rw) register accessor: an alias for `Reg<UDEV_CTRL_SPEC>`
    pub type UDEV_CTRL = crate::Reg<udev_ctrl::UDEV_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod udev_ctrl {
        ///Register `UDEV_CTRL` reader
        pub struct R(crate::R<UDEV_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UDEV_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UDEV_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UDEV_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UDEV_CTRL` writer
        pub struct W(crate::W<UDEV_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UDEV_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UDEV_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UDEV_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UD_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN_R = crate::BitReader;
        ///Field `UD_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN_W<'a, const O: u8> = crate::BitWriter<'a, UDEV_CTRL_SPEC, O>;
        ///Field `UD_HUB0_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_HUB0_RESET_R = crate::BitReader;
        ///Field `UD_HUB0_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_HUB0_RESET_W<'a, const O: u8> = crate::BitWriter<'a, UDEV_CTRL_SPEC, O>;
        ///Field `UD_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED_R = crate::BitReader;
        ///Field `UD_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED_W<'a, const O: u8> = crate::BitWriter<'a, UDEV_CTRL_SPEC, O>;
        ///Field `UD_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN_R = crate::BitReader;
        ///Field `UD_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN_R = crate::BitReader;
        ///Field `UD_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS_R = crate::BitReader;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en(&self) -> UD_PORT_EN_R {
                UD_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_hub0_reset(&self) -> UD_HUB0_RESET_R {
                UD_HUB0_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed(&self) -> UD_LOW_SPEED_R {
                UD_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin(&self) -> UD_DM_PIN_R {
                UD_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin(&self) -> UD_DP_PIN_R {
                UD_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis(&self) -> UD_PD_DIS_R {
                UD_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en(&mut self) -> UD_PORT_EN_W<0> {
                UD_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_hub0_reset(&mut self) -> UD_HUB0_RESET_W<1> {
                UD_HUB0_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed(&mut self) -> UD_LOW_SPEED_W<2> {
                UD_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [udev_ctrl](index.html) module
        pub struct UDEV_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [udev_ctrl::R](R) reader structure
        impl crate::Readable for UDEV_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [udev_ctrl::W](W) writer structure
        impl crate::Writable for UDEV_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UDEV_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_EN (rw) register accessor: an alias for `Reg<USB_INT_EN_SPEC>`
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub struct R(crate::R<USB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_EN` writer
        pub struct W(crate::W<USB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `MOD_1_WIRE` reader - enable USB single line mode
        pub type MOD_1_WIRE_R = crate::BitReader;
        ///Field `MOD_1_WIRE` writer - enable USB single line mode
        pub type MOD_1_WIRE_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_EN_SPEC, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB single line mode
            #[inline(always)]
            pub fn mod_1_wire(&self) -> MOD_1_WIRE_R {
                MOD_1_WIRE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(&mut self) -> UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<1> {
                UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<2> {
                UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<3> {
                UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<4> {
                UIE_FIFO_OV_W::new(self)
            }
            ///Bit 5 - enable USB single line mode
            #[inline(always)]
            #[must_use]
            pub fn mod_1_wire(&mut self) -> MOD_1_WIRE_W<5> {
                MOD_1_WIRE_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<6> {
                UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<7> {
                UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_en](index.html) module
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_en::R](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_en::W](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: an alias for `Reg<USB_DEV_AD_SPEC>`
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub struct R(crate::R<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_DEV_AD` writer
        pub struct W(crate::W<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> = crate::FieldWriter<'a, USB_DEV_AD_SPEC, 7, O>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, const O: u8> = crate::BitWriter<'a, USB_DEV_AD_SPEC, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<7> {
                UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_dev_ad](index.html) module
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_dev_ad::R](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_dev_ad::W](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_MIS_ST (r) register accessor: an alias for `Reg<USB_MIS_ST_SPEC>`
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub struct R(crate::R<USB_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_mis_st](index.html) module
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_mis_st::R](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_MIS_ST to value 0
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_FG (rw) register accessor: an alias for `Reg<USB_INT_FG_SPEC>`
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub struct R(crate::R<USB_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_FG` writer
        pub struct W(crate::W<USB_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF_BUS_RST_RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST_RB_UIF_DETECT_R = crate::BitReader;
        ///Field `UIF_BUS_RST_RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST_RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, USB_INT_FG_SPEC, O>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_FG_SPEC, O>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_FG_SPEC, O>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_FG_SPEC, O>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, const O: u8> = crate::BitWriter<'a, USB_INT_FG_SPEC, O>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst_rb_uif_detect(&self) -> UIF_BUS_RST_RB_UIF_DETECT_R {
                UIF_BUS_RST_RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst_rb_uif_detect(&mut self) -> UIF_BUS_RST_RB_UIF_DETECT_W<0> {
                UIF_BUS_RST_RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<1> {
                UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<2> {
                UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<3> {
                UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<4> {
                UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_fg](index.html) module
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_fg::R](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_fg::W](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0x20
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///USB_INT_ST (r) register accessor: an alias for `Reg<USB_INT_ST_SPEC>`
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub struct R(crate::R<USB_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_st](index.html) module
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_st::R](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_RX_LEN (r) register accessor: an alias for `Reg<USB_RX_LEN_SPEC>`
    pub type USB_RX_LEN = crate::Reg<usb_rx_len::USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod usb_rx_len {
        ///Register `USB_RX_LEN` reader
        pub struct R(crate::R<USB_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader;
        impl R {
            ///Bits 0:6 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits & 0x7f)
            }
        }
        ///USB receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_rx_len](index.html) module
        pub struct USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_rx_len::R](R) reader structure
        impl crate::Readable for USB_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_RX_LEN to value 0
        impl crate::Resettable for USB_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: an alias for `Reg<UEP4_1_MOD_SPEC>`
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 1/4 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub struct R(crate::R<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_1_MOD` writer
        pub struct W(crate::W<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_1_MOD_SPEC, O>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_1_MOD_SPEC, O>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_1_MOD_SPEC, O>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_1_MOD_SPEC, O>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_1_MOD_SPEC, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<2> {
                UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<3> {
                UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<4> {
                UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<6> {
                UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<7> {
                UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1/4 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_1_mod](index.html) module
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_1_mod::R](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_1_mod::W](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_3_MOD (rw) register accessor: an alias for `Reg<UEP2_3_MOD_SPEC>`
    pub type UEP2_3_MOD = crate::Reg<uep2_3_mod::UEP2_3_MOD_SPEC>;
    ///endpoint 2/3 mode;host endpoint mode
    pub mod uep2_3_mod {
        ///Register `UEP2_3_MOD` reader
        pub struct R(crate::R<UEP2_3_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_3_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_3_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_3_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_3_MOD` writer
        pub struct W(crate::W<UEP2_3_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_3_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_3_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_3_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_BUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        ///Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        ///Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        ///Field `UEP3_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_3_MOD_SPEC, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod(&self) -> UEP2_BUF_MOD_R {
                UEP2_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en(&self) -> UEP2_RX_EN_R {
                UEP2_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod(&self) -> UEP3_BUF_MOD_R {
                UEP3_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en(&self) -> UEP3_TX_EN_R {
                UEP3_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod(&mut self) -> UEP2_BUF_MOD_W<0> {
                UEP2_BUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<2> {
                UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en(&mut self) -> UEP2_RX_EN_W<3> {
                UEP2_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod(&mut self) -> UEP3_BUF_MOD_W<4> {
                UEP3_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en(&mut self) -> UEP3_TX_EN_W<6> {
                UEP3_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<7> {
                UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2/3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_3_mod](index.html) module
        pub struct UEP2_3_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_3_mod::R](R) reader structure
        impl crate::Readable for UEP2_3_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_3_mod::W](W) writer structure
        impl crate::Writable for UEP2_3_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_3_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP567_MOD (rw) register accessor: an alias for `Reg<UEP567_MOD_SPEC>`
    pub type UEP567_MOD = crate::Reg<uep567_mod::UEP567_MOD_SPEC>;
    ///endpoint 5/6/7 mode
    pub mod uep567_mod {
        ///Register `UEP567_MOD` reader
        pub struct R(crate::R<UEP567_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP567_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP567_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP567_MOD` writer
        pub struct W(crate::W<UEP567_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP567_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP567_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, UEP567_MOD_SPEC, O>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<0> {
                UEP5_TX_EN_W::new(self)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<1> {
                UEP5_RX_EN_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<2> {
                UEP6_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<3> {
                UEP6_RX_EN_W::new(self)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<4> {
                UEP7_TX_EN_W::new(self)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<5> {
                UEP7_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5/6/7 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep567_mod](index.html) module
        pub struct UEP567_MOD_SPEC;
        impl crate::RegisterSpec for UEP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep567_mod::R](R) reader structure
        impl crate::Readable for UEP567_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep567_mod::W](W) writer structure
        impl crate::Writable for UEP567_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP567_MOD to value 0
        impl crate::Resettable for UEP567_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: an alias for `Reg<UEP0_DMA_SPEC>`
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub struct R(crate::R<UEP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_DMA` writer
        pub struct W(crate::W<UEP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP0_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<2> {
                UEP0_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_dma](index.html) module
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep0_dma::R](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_dma::W](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: an alias for `Reg<UEP1_DMA_SPEC>`
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub struct R(crate::R<UEP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_DMA` writer
        pub struct W(crate::W<UEP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP1_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<2> {
                UEP1_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_dma](index.html) module
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep1_dma::R](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_dma::W](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_DMA (rw) register accessor: an alias for `Reg<UEP2_DMA_SPEC>`
    pub type UEP2_DMA = crate::Reg<uep2_dma::UEP2_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod uep2_dma {
        ///Register `UEP2_DMA` reader
        pub struct R(crate::R<UEP2_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_DMA` writer
        pub struct W(crate::W<UEP2_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP2_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<2> {
                UEP2_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_dma](index.html) module
        pub struct UEP2_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep2_dma::R](R) reader structure
        impl crate::Readable for UEP2_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_dma::W](W) writer structure
        impl crate::Writable for UEP2_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_DMA to value 0
        impl crate::Resettable for UEP2_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_DMA (rw) register accessor: an alias for `Reg<UEP3_DMA_SPEC>`
    pub type UEP3_DMA = crate::Reg<uep3_dma::UEP3_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_dma {
        ///Register `UEP3_DMA` reader
        pub struct R(crate::R<UEP3_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_DMA` writer
        pub struct W(crate::W<UEP3_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP3_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep3_dma(&self) -> UEP3_DMA_R {
                UEP3_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma(&mut self) -> UEP3_DMA_W<2> {
                UEP3_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_dma](index.html) module
        pub struct UEP3_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep3_dma::R](R) reader structure
        impl crate::Readable for UEP3_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_dma::W](W) writer structure
        impl crate::Writable for UEP3_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_DMA to value 0
        impl crate::Resettable for UEP3_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_DMA (rw) register accessor: an alias for `Reg<UEP5_DMA_SPEC>`
    pub type UEP5_DMA = crate::Reg<uep5_dma::UEP5_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod uep5_dma {
        ///Register `UEP5_DMA` reader
        pub struct R(crate::R<UEP5_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_DMA` writer
        pub struct W(crate::W<UEP5_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP5_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<2> {
                UEP5_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_dma](index.html) module
        pub struct UEP5_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep5_dma::R](R) reader structure
        impl crate::Readable for UEP5_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_dma::W](W) writer structure
        impl crate::Writable for UEP5_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_DMA to value 0
        impl crate::Resettable for UEP5_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_DMA (rw) register accessor: an alias for `Reg<UEP6_DMA_SPEC>`
    pub type UEP6_DMA = crate::Reg<uep6_dma::UEP6_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod uep6_dma {
        ///Register `UEP6_DMA` reader
        pub struct R(crate::R<UEP6_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_DMA` writer
        pub struct W(crate::W<UEP6_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP6_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<2> {
                UEP6_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_dma](index.html) module
        pub struct UEP6_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep6_dma::R](R) reader structure
        impl crate::Readable for UEP6_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_dma::W](W) writer structure
        impl crate::Writable for UEP6_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_DMA to value 0
        impl crate::Resettable for UEP6_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_DMA (rw) register accessor: an alias for `Reg<UEP7_DMA_SPEC>`
    pub type UEP7_DMA = crate::Reg<uep7_dma::UEP7_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod uep7_dma {
        ///Register `UEP7_DMA` reader
        pub struct R(crate::R<UEP7_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_DMA` writer
        pub struct W(crate::W<UEP7_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_W<'a, const O: u8> = crate::FieldWriter<'a, UEP7_DMA_SPEC, 13, O, u16>;
        impl R {
            ///Bits 2:14 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new((self.bits >> 2) & 0x1fff)
            }
        }
        impl W {
            ///Bits 2:14 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<2> {
                UEP7_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_dma](index.html) module
        pub struct UEP7_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep7_dma::R](R) reader structure
        impl crate::Readable for UEP7_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_dma::W](W) writer structure
        impl crate::Writable for UEP7_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_DMA to value 0
        impl crate::Resettable for UEP7_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: an alias for `Reg<UEP0_T_LEN_SPEC>`
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub struct R(crate::R<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_T_LEN` writer
        pub struct W(crate::W<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP0_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<0> {
                UEP0_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_t_len](index.html) module
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_t_len::R](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_t_len::W](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: an alias for `Reg<UEP0_CTRL_SPEC>`
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub struct R(crate::R<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_CTRL` writer
        pub struct W(crate::W<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP0_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP0_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP0_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP0_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP0_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_ctrl](index.html) module
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_ctrl::R](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_ctrl::W](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: an alias for `Reg<UEP1_T_LEN_SPEC>`
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub struct R(crate::R<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_T_LEN` writer
        pub struct W(crate::W<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP1_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<0> {
                UEP1_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_t_len](index.html) module
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_t_len::R](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_t_len::W](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_CTRL (rw) register accessor: an alias for `Reg<UEP1_CTRL_SPEC>`
    pub type UEP1_CTRL = crate::Reg<uep1_ctrl::UEP1_CTRL_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod uep1_ctrl {
        ///Register `UEP1_CTRL` reader
        pub struct R(crate::R<UEP1_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_CTRL` writer
        pub struct W(crate::W<UEP1_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP1_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP1_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP1_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP1_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP1_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_ctrl](index.html) module
        pub struct UEP1_CTRL_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_ctrl::R](R) reader structure
        impl crate::Readable for UEP1_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_ctrl::W](W) writer structure
        impl crate::Writable for UEP1_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_CTRL to value 0
        impl crate::Resettable for UEP1_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_T_LEN (rw) register accessor: an alias for `Reg<UEP2_T_LEN_SPEC>`
    pub type UEP2_T_LEN = crate::Reg<uep2_t_len::UEP2_T_LEN_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod uep2_t_len {
        ///Register `UEP2_T_LEN` reader
        pub struct R(crate::R<UEP2_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_T_LEN` writer
        pub struct W(crate::W<UEP2_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_T_LEN` reader - Set the number of data bytes to be sent by USB endpoint n
        pub type UEP2_T_LEN_R = crate::FieldReader;
        ///Field `UEP2_T_LEN` writer - Set the number of data bytes to be sent by USB endpoint n
        pub type UEP2_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP2_T_LEN_SPEC, 7, O>;
        ///Field `UEP2_HOST_PID3` reader - The token in host mode identifies the bit3 of the PID
        pub type UEP2_HOST_PID3_R = crate::BitReader;
        ///Field `UEP2_HOST_PID3` writer - The token in host mode identifies the bit3 of the PID
        pub type UEP2_HOST_PID3_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_T_LEN_SPEC, O>;
        impl R {
            ///Bits 0:6 - Set the number of data bytes to be sent by USB endpoint n
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - The token in host mode identifies the bit3 of the PID
            #[inline(always)]
            pub fn uep2_host_pid3(&self) -> UEP2_HOST_PID3_R {
                UEP2_HOST_PID3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - Set the number of data bytes to be sent by USB endpoint n
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<0> {
                UEP2_T_LEN_W::new(self)
            }
            ///Bit 7 - The token in host mode identifies the bit3 of the PID
            #[inline(always)]
            #[must_use]
            pub fn uep2_host_pid3(&mut self) -> UEP2_HOST_PID3_W<7> {
                UEP2_HOST_PID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_t_len](index.html) module
        pub struct UEP2_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_t_len::R](R) reader structure
        impl crate::Readable for UEP2_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_t_len::W](W) writer structure
        impl crate::Writable for UEP2_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_T_LEN to value 0
        impl crate::Resettable for UEP2_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_CTRL (rw) register accessor: an alias for `Reg<UEP2_CTRL_SPEC>`
    pub type UEP2_CTRL = crate::Reg<uep2_ctrl::UEP2_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod uep2_ctrl {
        ///Register `UEP2_CTRL` reader
        pub struct R(crate::R<UEP2_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_CTRL` writer
        pub struct W(crate::W<UEP2_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP2_CTRL_SPEC, 2, O>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_CTRL_SPEC, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP2_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP2_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<2> {
                MASK_UH_R_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_ctrl](index.html) module
        pub struct UEP2_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_ctrl::R](R) reader structure
        impl crate::Readable for UEP2_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_ctrl::W](W) writer structure
        impl crate::Writable for UEP2_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_T_LEN (rw) register accessor: an alias for `Reg<UEP3_T_LEN_SPEC>`
    pub type UEP3_T_LEN = crate::Reg<uep3_t_len::UEP3_T_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod uep3_t_len {
        ///Register `UEP3_T_LEN` reader
        pub struct R(crate::R<UEP3_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_T_LEN` writer
        pub struct W(crate::W<UEP3_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN_R = crate::FieldReader;
        ///Field `UEP3_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP3_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len(&self) -> UEP3_T_LEN_R {
                UEP3_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len(&mut self) -> UEP3_T_LEN_W<0> {
                UEP3_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_t_len](index.html) module
        pub struct UEP3_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_t_len::R](R) reader structure
        impl crate::Readable for UEP3_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_t_len::W](W) writer structure
        impl crate::Writable for UEP3_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_T_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_CTRL (rw) register accessor: an alias for `Reg<UEP3_CTRL_SPEC>`
    pub type UEP3_CTRL = crate::Reg<uep3_ctrl::UEP3_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod uep3_ctrl {
        ///Register `UEP3_CTRL` reader
        pub struct R(crate::R<UEP3_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_CTRL` writer
        pub struct W(crate::W<UEP3_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP3_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP3_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP3_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP3_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP3_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_ctrl](index.html) module
        pub struct UEP3_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_ctrl::R](R) reader structure
        impl crate::Readable for UEP3_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_ctrl::W](W) writer structure
        impl crate::Writable for UEP3_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: an alias for `Reg<UEP4_T_LEN_SPEC>`
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub struct R(crate::R<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_T_LEN` writer
        pub struct W(crate::W<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader;
        ///Field `UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type UEP4_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP4_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<0> {
                UEP4_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_t_len](index.html) module
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_t_len::R](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_t_len::W](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: an alias for `Reg<UEP4_CTRL_SPEC>`
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub struct R(crate::R<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_CTRL` writer
        pub struct W(crate::W<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP4_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP4_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP4_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_ctrl](index.html) module
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_ctrl::R](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_ctrl::W](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_T_LEN (rw) register accessor: an alias for `Reg<UEP5_T_LEN_SPEC>`
    pub type UEP5_T_LEN = crate::Reg<uep5_t_len::UEP5_T_LEN_SPEC>;
    ///endpoint 5 transmittal length
    pub mod uep5_t_len {
        ///Register `UEP5_T_LEN` reader
        pub struct R(crate::R<UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_T_LEN` writer
        pub struct W(crate::W<UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP5_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<0> {
                UEP5_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_t_len](index.html) module
        pub struct UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep5_t_len::R](R) reader structure
        impl crate::Readable for UEP5_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_t_len::W](W) writer structure
        impl crate::Writable for UEP5_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_T_LEN to value 0
        impl crate::Resettable for UEP5_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_CTRL (rw) register accessor: an alias for `Reg<UEP5_CTRL_SPEC>`
    pub type UEP5_CTRL = crate::Reg<uep5_ctrl::UEP5_CTRL_SPEC>;
    ///endpoint 5 control
    pub mod uep5_ctrl {
        ///Register `UEP5_CTRL` reader
        pub struct R(crate::R<UEP5_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_CTRL` writer
        pub struct W(crate::W<UEP5_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP5_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP5_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP5_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP5_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP5_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_ctrl](index.html) module
        pub struct UEP5_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep5_ctrl::R](R) reader structure
        impl crate::Readable for UEP5_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_ctrl::W](W) writer structure
        impl crate::Writable for UEP5_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_CTRL to value 0
        impl crate::Resettable for UEP5_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_T_LEN (rw) register accessor: an alias for `Reg<UEP6_T_LEN_SPEC>`
    pub type UEP6_T_LEN = crate::Reg<uep6_t_len::UEP6_T_LEN_SPEC>;
    ///endpoint 6 transmittal length
    pub mod uep6_t_len {
        ///Register `UEP6_T_LEN` reader
        pub struct R(crate::R<UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_T_LEN` writer
        pub struct W(crate::W<UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP6_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<0> {
                UEP6_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_t_len](index.html) module
        pub struct UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep6_t_len::R](R) reader structure
        impl crate::Readable for UEP6_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_t_len::W](W) writer structure
        impl crate::Writable for UEP6_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_T_LEN to value 0
        impl crate::Resettable for UEP6_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_CTRL (rw) register accessor: an alias for `Reg<UEP6_CTRL_SPEC>`
    pub type UEP6_CTRL = crate::Reg<uep6_ctrl::UEP6_CTRL_SPEC>;
    ///endpoint 6 control
    pub mod uep6_ctrl {
        ///Register `UEP6_CTRL` reader
        pub struct R(crate::R<UEP6_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_CTRL` writer
        pub struct W(crate::W<UEP6_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP6_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP6_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP6_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP6_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP6_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_ctrl](index.html) module
        pub struct UEP6_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep6_ctrl::R](R) reader structure
        impl crate::Readable for UEP6_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_ctrl::W](W) writer structure
        impl crate::Writable for UEP6_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_CTRL to value 0
        impl crate::Resettable for UEP6_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_T_LEN (rw) register accessor: an alias for `Reg<UEP7_T_LEN_SPEC>`
    pub type UEP7_T_LEN = crate::Reg<uep7_t_len::UEP7_T_LEN_SPEC>;
    ///endpoint 7 transmittal length
    pub mod uep7_t_len {
        ///Register `UEP7_T_LEN` reader
        pub struct R(crate::R<UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_T_LEN` writer
        pub struct W(crate::W<UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, const O: u8> = crate::FieldWriter<'a, UEP7_T_LEN_SPEC, 7, O>;
        impl R {
            ///Bits 0:6 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<0> {
                UEP7_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_t_len](index.html) module
        pub struct UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep7_t_len::R](R) reader structure
        impl crate::Readable for UEP7_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_t_len::W](W) writer structure
        impl crate::Writable for UEP7_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_T_LEN to value 0
        impl crate::Resettable for UEP7_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_CTRL (rw) register accessor: an alias for `Reg<UEP7_CTRL_SPEC>`
    pub type UEP7_CTRL = crate::Reg<uep7_ctrl::UEP7_CTRL_SPEC>;
    ///endpoint 7 control
    pub mod uep7_ctrl {
        ///Register `UEP7_CTRL` reader
        pub struct R(crate::R<UEP7_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_CTRL` writer
        pub struct W(crate::W<UEP7_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP7_CTRL_SPEC, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> = crate::FieldWriter<'a, UEP7_CTRL_SPEC, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP7_CTRL_SPEC, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP7_CTRL_SPEC, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, UEP7_CTRL_SPEC, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_ctrl](index.html) module
        pub struct UEP7_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep7_ctrl::R](R) reader structure
        impl crate::Readable for UEP7_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_ctrl::W](W) writer structure
        impl crate::Writable for UEP7_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_CTRL to value 0
        impl crate::Resettable for UEP7_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RO,Interrupt Status Register 1
        pub isr1: ISR1,
        ///0x04 - RO,Interrupt Status Register 2
        pub isr2: ISR2,
        _reserved2: [u8; 0x18],
        ///0x20 - RO,Interrupt Pending Register 1
        pub ipr1: IPR1,
        ///0x24 - RO,Interrupt Pending Register 2
        pub ipr2: IPR2,
        _reserved4: [u8; 0x18],
        ///0x40 - RW,Interrupt Priority Register
        pub ithresdr: ITHRESDR,
        _reserved5: [u8; 0x04],
        ///0x48 - Interrupt Config Register
        pub cfgr: CFGR,
        ///0x4c - Interrupt Global Register
        pub gisr: GISR,
        ///0x50 - RW,Interrupt Fast ID Config Register
        pub idcfgr: IDCFGR,
        _reserved8: [u8; 0x0c],
        ///0x60 - Interrupt 0 address Register
        pub fiaddrr0: FIADDRR0,
        ///0x64 - Interrupt 1 address Register
        pub fiaddrr1: FIADDRR1,
        ///0x68 - Interrupt 2 address Register
        pub fiaddrr2: FIADDRR2,
        ///0x6c - Interrupt 3 address Register
        pub fiaddrr3: FIADDRR3,
        _reserved12: [u8; 0x90],
        ///0x100 - Interrupt Setting Register
        pub ienr1: IENR1,
        ///0x104 - Interrupt Setting Register
        pub ienr2: IENR2,
        _reserved14: [u8; 0x78],
        ///0x180 - Interrupt Clear Register
        pub irer1: IRER1,
        ///0x184 - Interrupt Clear Register
        pub irer2: IRER2,
        _reserved16: [u8; 0x78],
        ///0x200 - Interrupt Pending Register
        pub ipsr1: IPSR1,
        ///0x204 - Interrupt Pending Register
        pub ipsr2: IPSR2,
        _reserved18: [u8; 0x78],
        ///0x280 - Interrupt Pending Clear Register
        pub iprr1: IPRR1,
        ///0x284 - Interrupt Pending Clear Register
        pub iprr2: IPRR2,
        _reserved20: [u8; 0x78],
        ///0x300 - Interrupt ACTIVE Register
        pub iactr1: IACTR1,
        ///0x304 - Interrupt ACTIVE Register
        pub iactr2: IACTR2,
        _reserved22: [u8; 0xf8],
        ///0x400 - Interrupt Priority configuration Register 0
        pub iprior0: IPRIOR0,
        _reserved23: [u8; 0x1c],
        ///0x420 - Interrupt Priority configuration Register 1
        pub iprior1: IPRIOR1,
        _reserved24: [u8; 0x1c],
        ///0x440 - Interrupt Priority configuration Register 2
        pub iprior2: IPRIOR2,
        _reserved25: [u8; 0x1c],
        ///0x460 - Interrupt Priority configuration Register 3
        pub iprior3: IPRIOR3,
        _reserved26: [u8; 0x1c],
        ///0x480 - Interrupt Priority configuration Register 4
        pub iprior4: IPRIOR4,
        _reserved27: [u8; 0x1c],
        ///0x4a0 - Interrupt Priority configuration Register 5
        pub iprior5: IPRIOR5,
        _reserved28: [u8; 0x1c],
        ///0x4c0 - Interrupt Priority configuration Register 6
        pub iprior6: IPRIOR6,
        _reserved29: [u8; 0x1c],
        ///0x4e0 - Interrupt Priority configuration Register 7
        pub iprior7: IPRIOR7,
        _reserved30: [u8; 0x1c],
        ///0x500 - Interrupt Priority configuration Register 8
        pub iprior8: IPRIOR8,
        _reserved31: [u8; 0x1c],
        ///0x520 - Interrupt Priority configuration Register 9
        pub iprior9: IPRIOR9,
        _reserved32: [u8; 0x1c],
        ///0x540 - Interrupt Priority configuration Register 10
        pub iprior10: IPRIOR10,
        _reserved33: [u8; 0x1c],
        ///0x560 - Interrupt Priority configuration Register 11
        pub iprior11: IPRIOR11,
        _reserved34: [u8; 0x1c],
        ///0x580 - Interrupt Priority configuration Register 12
        pub iprior12: IPRIOR12,
        _reserved35: [u8; 0x1c],
        ///0x5a0 - Interrupt Priority configuration Register 13
        pub iprior13: IPRIOR13,
        _reserved36: [u8; 0x1c],
        ///0x5c0 - Interrupt Priority configuration Register 14
        pub iprior14: IPRIOR14,
        _reserved37: [u8; 0x1c],
        ///0x5e0 - Interrupt Priority configuration Register 15
        pub iprior15: IPRIOR15,
        _reserved38: [u8; 0x1c],
        ///0x600 - Interrupt Priority configuration Register 16
        pub iprior16: IPRIOR16,
        _reserved39: [u8; 0x1c],
        ///0x620 - Interrupt Priority configuration Register 17
        pub iprior17: IPRIOR17,
        _reserved40: [u8; 0x1c],
        ///0x640 - Interrupt Priority configuration Register 18
        pub iprior18: IPRIOR18,
        _reserved41: [u8; 0x1c],
        ///0x660 - Interrupt Priority configuration Register 19
        pub iprior19: IPRIOR19,
        _reserved42: [u8; 0x1c],
        ///0x680 - Interrupt Priority configuration Register 20
        pub iprior20: IPRIOR20,
        _reserved43: [u8; 0x1c],
        ///0x6a0 - Interrupt Priority configuration Register 21
        pub iprior21: IPRIOR21,
        _reserved44: [u8; 0x1c],
        ///0x6c0 - Interrupt Priority configuration Register 22
        pub iprior22: IPRIOR22,
        _reserved45: [u8; 0x1c],
        ///0x6e0 - Interrupt Priority configuration Register 23
        pub iprior23: IPRIOR23,
        _reserved46: [u8; 0x1c],
        ///0x700 - Interrupt Priority configuration Register 24
        pub iprior24: IPRIOR24,
        _reserved47: [u8; 0x1c],
        ///0x720 - Interrupt Priority configuration Register 25
        pub iprior25: IPRIOR25,
        _reserved48: [u8; 0x1c],
        ///0x740 - Interrupt Priority configuration Register 26
        pub iprior26: IPRIOR26,
        _reserved49: [u8; 0x1c],
        ///0x760 - Interrupt Priority configuration Register 27
        pub iprior27: IPRIOR27,
        _reserved50: [u8; 0x1c],
        ///0x780 - Interrupt Priority configuration Register 28
        pub iprior28: IPRIOR28,
        _reserved51: [u8; 0x1c],
        ///0x7a0 - Interrupt Priority configuration Register 29
        pub iprior29: IPRIOR29,
        _reserved52: [u8; 0x1c],
        ///0x7c0 - Interrupt Priority configuration Register 30
        pub iprior30: IPRIOR30,
        _reserved53: [u8; 0x1c],
        ///0x7e0 - Interrupt Priority configuration Register 31
        pub iprior31: IPRIOR31,
        _reserved54: [u8; 0x1c],
        ///0x800 - Interrupt Priority configuration Register 32
        pub iprior32: IPRIOR32,
        _reserved55: [u8; 0x1c],
        ///0x820 - Interrupt Priority configuration Register 33
        pub iprior33: IPRIOR33,
        _reserved56: [u8; 0x1c],
        ///0x840 - Interrupt Priority configuration Register 34
        pub iprior34: IPRIOR34,
        _reserved57: [u8; 0x1c],
        ///0x860 - Interrupt Priority configuration Register 35
        pub iprior35: IPRIOR35,
        _reserved58: [u8; 0x1c],
        ///0x880 - Interrupt Priority configuration Register 36
        pub iprior36: IPRIOR36,
        _reserved59: [u8; 0x1c],
        ///0x8a0 - Interrupt Priority configuration Register 37
        pub iprior37: IPRIOR37,
        _reserved60: [u8; 0x1c],
        ///0x8c0 - Interrupt Priority configuration Register 38
        pub iprior38: IPRIOR38,
        _reserved61: [u8; 0x1c],
        ///0x8e0 - Interrupt Priority configuration Register 39
        pub iprior39: IPRIOR39,
        _reserved62: [u8; 0x1c],
        ///0x900 - Interrupt Priority configuration Register 40
        pub iprior40: IPRIOR40,
        _reserved63: [u8; 0x1c],
        ///0x920 - Interrupt Priority configuration Register 41
        pub iprior41: IPRIOR41,
        _reserved64: [u8; 0x1c],
        ///0x940 - Interrupt Priority configuration Register 42
        pub iprior42: IPRIOR42,
        _reserved65: [u8; 0x1c],
        ///0x960 - Interrupt Priority configuration Register 43
        pub iprior43: IPRIOR43,
        _reserved66: [u8; 0x1c],
        ///0x980 - Interrupt Priority configuration Register 44
        pub iprior44: IPRIOR44,
        _reserved67: [u8; 0x1c],
        ///0x9a0 - Interrupt Priority configuration Register 45
        pub iprior45: IPRIOR45,
        _reserved68: [u8; 0x1c],
        ///0x9c0 - Interrupt Priority configuration Register 46
        pub iprior46: IPRIOR46,
        _reserved69: [u8; 0x1c],
        ///0x9e0 - Interrupt Priority configuration Register 47
        pub iprior47: IPRIOR47,
        _reserved70: [u8; 0x1c],
        ///0xa00 - Interrupt Priority configuration Register 48
        pub iprior48: IPRIOR48,
        _reserved71: [u8; 0x1c],
        ///0xa20 - Interrupt Priority configuration Register 49
        pub iprior49: IPRIOR49,
        _reserved72: [u8; 0x1c],
        ///0xa40 - Interrupt Priority configuration Register 50
        pub iprior50: IPRIOR50,
        _reserved73: [u8; 0x1c],
        ///0xa60 - Interrupt Priority configuration Register 51
        pub iprior51: IPRIOR51,
        _reserved74: [u8; 0x1c],
        ///0xa80 - Interrupt Priority configuration Register 52
        pub iprior52: IPRIOR52,
        _reserved75: [u8; 0x1c],
        ///0xaa0 - Interrupt Priority configuration Register 53
        pub iprior53: IPRIOR53,
        _reserved76: [u8; 0x2c],
        ///0xad0 - Interrupt Priority configuration Register 54
        pub iprior54: IPRIOR54,
        _reserved77: [u8; 0x0c],
        ///0xae0 - Interrupt Priority configuration Register 55
        pub iprior55: IPRIOR55,
        _reserved78: [u8; 0x1c],
        ///0xb00 - Interrupt Priority configuration Register 56
        pub iprior56: IPRIOR56,
        _reserved79: [u8; 0x1c],
        ///0xb20 - Interrupt Priority configuration Register 57
        pub iprior57: IPRIOR57,
        _reserved80: [u8; 0x1c],
        ///0xb40 - Interrupt Priority configuration Register 58
        pub iprior58: IPRIOR58,
        _reserved81: [u8; 0x1c],
        ///0xb60 - Interrupt Priority configuration Register 59
        pub iprior59: IPRIOR59,
        _reserved82: [u8; 0x1c],
        ///0xb80 - Interrupt Priority configuration Register 60
        pub iprior60: IPRIOR60,
        _reserved83: [u8; 0x1c],
        ///0xba0 - Interrupt Priority configuration Register 61
        pub iprior61: IPRIOR61,
        _reserved84: [u8; 0x3c],
        ///0xbe0 - Interrupt Priority configuration Register 62
        pub iprior62: IPRIOR62,
        _reserved85: [u8; 0x1c],
        ///0xc00 - Interrupt Priority configuration Register 63
        pub iprior63: IPRIOR63,
        _reserved86: [u8; 0x010c],
        ///0xd10 - System Control Register
        pub sctlr: SCTLR,
    }
    ///ISR1 (r) register accessor: an alias for `Reg<ISR1_SPEC>`
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///RO,Interrupt Status Register 1
    pub mod isr1 {
        ///Register `ISR1` reader
        pub struct R(crate::R<ISR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Status Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr1](index.html) module
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr1::R](R) reader structure
        impl crate::Readable for ISR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR1 to value 0x0c
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c;
        }
    }
    ///ISR2 (r) register accessor: an alias for `Reg<ISR2_SPEC>`
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///RO,Interrupt Status Register 2
    pub mod isr2 {
        ///Register `ISR2` reader
        pub struct R(crate::R<ISR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Status Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr2](index.html) module
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr2::R](R) reader structure
        impl crate::Readable for ISR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR1 (r) register accessor: an alias for `Reg<IPR1_SPEC>`
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///RO,Interrupt Pending Register 1
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub struct R(crate::R<IPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Pending Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr1](index.html) module
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr1::R](R) reader structure
        impl crate::Readable for IPR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR2 (r) register accessor: an alias for `Reg<IPR2_SPEC>`
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///RO,Interrupt Pending Register 2
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub struct R(crate::R<IPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Pending Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr2](index.html) module
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr2::R](R) reader structure
        impl crate::Readable for IPR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: an alias for `Reg<ITHRESDR_SPEC>`
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///RW,Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub struct R(crate::R<ITHRESDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ITHRESDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ITHRESDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ITHRESDR` writer
        pub struct W(crate::W<ITHRESDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ITHRESDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ITHRESDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THRESHOLD` reader - RW,THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader;
        ///Field `THRESHOLD` writer - RW,THRESHOLD
        pub type THRESHOLD_W<'a, const O: u8> = crate::FieldWriter<'a, ITHRESDR_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<0> {
                THRESHOLD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ithresdr](index.html) module
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ithresdr::R](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ithresdr::W](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR (w) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RESETSYS` writer - WO,RESETSYS
        pub type RESETSYS_W<'a, const O: u8> = crate::BitWriter<'a, CFGR_SPEC, O>;
        ///Field `KEYCODE` writer - WO,KEYCODE
        pub type KEYCODE_W<'a, const O: u8> = crate::FieldWriter<'a, CFGR_SPEC, 16, O, u16>;
        impl W {
            ///Bit 7 - WO,RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn resetsys(&mut self) -> RESETSYS_W<7> {
                RESETSYS_W::new(self)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<16> {
                KEYCODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GISR (r) register accessor: an alias for `Reg<GISR_SPEC>`
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub struct R(crate::R<GISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GISR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NESTSTA` reader - RO,NESTSTA
        pub type NESTSTA_R = crate::FieldReader;
        ///Field `GACTSTA` reader - RO,GACTSTA
        pub type GACTSTA_R = crate::BitReader;
        ///Field `GPENDSTA` reader - RO,GPENDSTA
        pub type GPENDSTA_R = crate::BitReader;
        impl R {
            ///Bits 0:7 - RO,NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - RO,GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RO,GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gisr](index.html) module
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gisr::R](R) reader structure
        impl crate::Readable for GISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDCFGR (rw) register accessor: an alias for `Reg<IDCFGR_SPEC>`
    pub type IDCFGR = crate::Reg<idcfgr::IDCFGR_SPEC>;
    ///RW,Interrupt Fast ID Config Register
    pub mod idcfgr {
        ///Register `IDCFGR` reader
        pub struct R(crate::R<IDCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IDCFGR` writer
        pub struct W(crate::W<IDCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IDCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IDCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FIID0` reader - RW,FIID0
        pub type FIID0_R = crate::FieldReader;
        ///Field `FIID0` writer - RW,FIID0
        pub type FIID0_W<'a, const O: u8> = crate::FieldWriter<'a, IDCFGR_SPEC, 8, O>;
        ///Field `FIID1` reader - RW,FIID1
        pub type FIID1_R = crate::FieldReader;
        ///Field `FIID1` writer - RW,FIID1
        pub type FIID1_W<'a, const O: u8> = crate::FieldWriter<'a, IDCFGR_SPEC, 8, O>;
        ///Field `FIID2` reader - RW,FIID2
        pub type FIID2_R = crate::FieldReader;
        ///Field `FIID2` writer - RW,FIID2
        pub type FIID2_W<'a, const O: u8> = crate::FieldWriter<'a, IDCFGR_SPEC, 8, O>;
        ///Field `FIID3` reader - RW,FIID3
        pub type FIID3_R = crate::FieldReader;
        ///Field `FIID3` writer - RW,FIID3
        pub type FIID3_W<'a, const O: u8> = crate::FieldWriter<'a, IDCFGR_SPEC, 8, O>;
        impl R {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            pub fn fiid0(&self) -> FIID0_R {
                FIID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            pub fn fiid1(&self) -> FIID1_R {
                FIID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            pub fn fiid2(&self) -> FIID2_R {
                FIID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            pub fn fiid3(&self) -> FIID3_R {
                FIID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            #[must_use]
            pub fn fiid0(&mut self) -> FIID0_W<0> {
                FIID0_W::new(self)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            #[must_use]
            pub fn fiid1(&mut self) -> FIID1_W<8> {
                FIID1_W::new(self)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            #[must_use]
            pub fn fiid2(&mut self) -> FIID2_W<16> {
                FIID2_W::new(self)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            #[must_use]
            pub fn fiid3(&mut self) -> FIID3_W<24> {
                FIID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Fast ID Config Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idcfgr](index.html) module
        pub struct IDCFGR_SPEC;
        impl crate::RegisterSpec for IDCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idcfgr::R](R) reader structure
        impl crate::Readable for IDCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [idcfgr::W](W) writer structure
        impl crate::Writable for IDCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IDCFGR to value 0
        impl crate::Resettable for IDCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIADDRR0 (rw) register accessor: an alias for `Reg<FIADDRR0_SPEC>`
    pub type FIADDRR0 = crate::Reg<fiaddrr0::FIADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod fiaddrr0 {
        ///Register `FIADDRR0` reader
        pub struct R(crate::R<FIADDRR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIADDRR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIADDRR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIADDRR0` writer
        pub struct W(crate::W<FIADDRR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIADDRR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIADDRR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI0EN` reader - RW,Fast interrupt channel 0 enable bit
        pub type FI0EN_R = crate::BitReader;
        ///Field `FI0EN` writer - RW,Fast interrupt channel 0 enable bit
        pub type FI0EN_W<'a, const O: u8> = crate::BitWriter<'a, FIADDRR0_SPEC, O>;
        ///Field `ADDR0` reader - RW,ADDR0
        pub type ADDR0_R = crate::FieldReader<u32>;
        ///Field `ADDR0` writer - RW,ADDR0
        pub type ADDR0_W<'a, const O: u8> = crate::FieldWriter<'a, FIADDRR0_SPEC, 31, O, u32>;
        impl R {
            ///Bit 0 - RW,Fast interrupt channel 0 enable bit
            #[inline(always)]
            pub fn fi0en(&self) -> FI0EN_R {
                FI0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,Fast interrupt channel 0 enable bit
            #[inline(always)]
            #[must_use]
            pub fn fi0en(&mut self) -> FI0EN_W<0> {
                FI0EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<1> {
                ADDR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fiaddrr0](index.html) module
        pub struct FIADDRR0_SPEC;
        impl crate::RegisterSpec for FIADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fiaddrr0::R](R) reader structure
        impl crate::Readable for FIADDRR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fiaddrr0::W](W) writer structure
        impl crate::Writable for FIADDRR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIADDRR0 to value 0
        impl crate::Resettable for FIADDRR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIADDRR1 (rw) register accessor: an alias for `Reg<FIADDRR1_SPEC>`
    pub type FIADDRR1 = crate::Reg<fiaddrr1::FIADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod fiaddrr1 {
        ///Register `FIADDRR1` reader
        pub struct R(crate::R<FIADDRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIADDRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIADDRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIADDRR1` writer
        pub struct W(crate::W<FIADDRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIADDRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIADDRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI1EN` reader - RW,Fast interrupt channel 1 enable bit
        pub type FI1EN_R = crate::BitReader;
        ///Field `FI1EN` writer - RW,Fast interrupt channel 1 enable bit
        pub type FI1EN_W<'a, const O: u8> = crate::BitWriter<'a, FIADDRR1_SPEC, O>;
        ///Field `ADDR1` reader - RW,ADDR1
        pub type ADDR1_R = crate::FieldReader<u32>;
        ///Field `ADDR1` writer - RW,ADDR1
        pub type ADDR1_W<'a, const O: u8> = crate::FieldWriter<'a, FIADDRR1_SPEC, 31, O, u32>;
        impl R {
            ///Bit 0 - RW,Fast interrupt channel 1 enable bit
            #[inline(always)]
            pub fn fi1en(&self) -> FI1EN_R {
                FI1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,Fast interrupt channel 1 enable bit
            #[inline(always)]
            #[must_use]
            pub fn fi1en(&mut self) -> FI1EN_W<0> {
                FI1EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<1> {
                ADDR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fiaddrr1](index.html) module
        pub struct FIADDRR1_SPEC;
        impl crate::RegisterSpec for FIADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fiaddrr1::R](R) reader structure
        impl crate::Readable for FIADDRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fiaddrr1::W](W) writer structure
        impl crate::Writable for FIADDRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIADDRR1 to value 0
        impl crate::Resettable for FIADDRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIADDRR2 (rw) register accessor: an alias for `Reg<FIADDRR2_SPEC>`
    pub type FIADDRR2 = crate::Reg<fiaddrr2::FIADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod fiaddrr2 {
        ///Register `FIADDRR2` reader
        pub struct R(crate::R<FIADDRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIADDRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIADDRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIADDRR2` writer
        pub struct W(crate::W<FIADDRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIADDRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIADDRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI2EN` reader - RW,Fast interrupt channel 2 enable bit
        pub type FI2EN_R = crate::BitReader;
        ///Field `FI2EN` writer - RW,Fast interrupt channel 2 enable bit
        pub type FI2EN_W<'a, const O: u8> = crate::BitWriter<'a, FIADDRR2_SPEC, O>;
        ///Field `ADDR2` reader - RW,ADDR2
        pub type ADDR2_R = crate::FieldReader<u32>;
        ///Field `ADDR2` writer - RW,ADDR2
        pub type ADDR2_W<'a, const O: u8> = crate::FieldWriter<'a, FIADDRR2_SPEC, 31, O, u32>;
        impl R {
            ///Bit 0 - RW,Fast interrupt channel 2 enable bit
            #[inline(always)]
            pub fn fi2en(&self) -> FI2EN_R {
                FI2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,Fast interrupt channel 2 enable bit
            #[inline(always)]
            #[must_use]
            pub fn fi2en(&mut self) -> FI2EN_W<0> {
                FI2EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<1> {
                ADDR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fiaddrr2](index.html) module
        pub struct FIADDRR2_SPEC;
        impl crate::RegisterSpec for FIADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fiaddrr2::R](R) reader structure
        impl crate::Readable for FIADDRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fiaddrr2::W](W) writer structure
        impl crate::Writable for FIADDRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIADDRR2 to value 0
        impl crate::Resettable for FIADDRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIADDRR3 (rw) register accessor: an alias for `Reg<FIADDRR3_SPEC>`
    pub type FIADDRR3 = crate::Reg<fiaddrr3::FIADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod fiaddrr3 {
        ///Register `FIADDRR3` reader
        pub struct R(crate::R<FIADDRR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIADDRR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIADDRR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIADDRR3` writer
        pub struct W(crate::W<FIADDRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIADDRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIADDRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI3EN` reader - RW,Fast interrupt channel 3 enable bit
        pub type FI3EN_R = crate::BitReader;
        ///Field `FI3EN` writer - RW,Fast interrupt channel 3 enable bit
        pub type FI3EN_W<'a, const O: u8> = crate::BitWriter<'a, FIADDRR3_SPEC, O>;
        ///Field `ADDR3` reader - RW,ADDR3
        pub type ADDR3_R = crate::FieldReader<u32>;
        ///Field `ADDR3` writer - RW,ADDR3
        pub type ADDR3_W<'a, const O: u8> = crate::FieldWriter<'a, FIADDRR3_SPEC, 31, O, u32>;
        impl R {
            ///Bit 0 - RW,Fast interrupt channel 3 enable bit
            #[inline(always)]
            pub fn fi3en(&self) -> FI3EN_R {
                FI3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,Fast interrupt channel 3 enable bit
            #[inline(always)]
            #[must_use]
            pub fn fi3en(&mut self) -> FI3EN_W<0> {
                FI3EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<1> {
                ADDR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fiaddrr3](index.html) module
        pub struct FIADDRR3_SPEC;
        impl crate::RegisterSpec for FIADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fiaddrr3::R](R) reader structure
        impl crate::Readable for FIADDRR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fiaddrr3::W](W) writer structure
        impl crate::Writable for FIADDRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIADDRR3 to value 0
        impl crate::Resettable for FIADDRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR1 (w) register accessor: an alias for `Reg<IENR1_SPEC>`
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` writer
        pub struct W(crate::W<IENR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> = crate::FieldWriter<'a, IENR1_SPEC, 20, O, u32>;
        impl W {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<12> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr1](index.html) module
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr1::W](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR2 (w) register accessor: an alias for `Reg<IENR2_SPEC>`
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` writer
        pub struct W(crate::W<IENR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> = crate::FieldWriter<'a, IENR2_SPEC, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr2](index.html) module
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr2::W](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER1 (w) register accessor: an alias for `Reg<IRER1_SPEC>`
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` writer
        pub struct W(crate::W<IRER1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> = crate::FieldWriter<'a, IRER1_SPEC, 20, O, u32>;
        impl W {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<12> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer1](index.html) module
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer1::W](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER2 (w) register accessor: an alias for `Reg<IRER2_SPEC>`
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` writer
        pub struct W(crate::W<IRER2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> = crate::FieldWriter<'a, IRER2_SPEC, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<0> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer2](index.html) module
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer2::W](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR1 (w) register accessor: an alias for `Reg<IPSR1_SPEC>`
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` writer
        pub struct W(crate::W<IPSR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> = crate::FieldWriter<'a, IPSR1_SPEC, 20, O, u32>;
        impl W {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<12> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr1](index.html) module
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr1::W](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR2 (w) register accessor: an alias for `Reg<IPSR2_SPEC>`
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` writer
        pub struct W(crate::W<IPSR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> = crate::FieldWriter<'a, IPSR2_SPEC, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr2](index.html) module
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr2::W](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR1 (w) register accessor: an alias for `Reg<IPRR1_SPEC>`
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` writer
        pub struct W(crate::W<IPRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> = crate::FieldWriter<'a, IPRR1_SPEC, 20, O, u32>;
        impl W {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<12> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr1](index.html) module
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr1::W](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR2 (w) register accessor: an alias for `Reg<IPRR2_SPEC>`
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` writer
        pub struct W(crate::W<IPRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> = crate::FieldWriter<'a, IPRR2_SPEC, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr2](index.html) module
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr2::W](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR1 (rw) register accessor: an alias for `Reg<IACTR1_SPEC>`
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` reader
        pub struct R(crate::R<IACTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IACTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IACTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IACTR1` writer
        pub struct W(crate::W<IACTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u32>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> = crate::FieldWriter<'a, IACTR1_SPEC, 20, O, u32>;
        impl R {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<12> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr1](index.html) module
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iactr1::R](R) reader structure
        impl crate::Readable for IACTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iactr1::W](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR2 (rw) register accessor: an alias for `Reg<IACTR2_SPEC>`
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` reader
        pub struct R(crate::R<IACTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IACTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IACTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IACTR2` writer
        pub struct W(crate::W<IACTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> = crate::FieldWriter<'a, IACTR2_SPEC, 4, O>;
        impl R {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr2](index.html) module
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iactr2::R](R) reader structure
        impl crate::Readable for IACTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iactr2::W](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: an alias for `Reg<IPRIOR0_SPEC>`
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register 0
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub struct R(crate::R<IPRIOR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR0` writer
        pub struct W(crate::W<IPRIOR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_R = crate::FieldReader<u32>;
        ///Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR0_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<0> {
                IPRIOR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 0
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior0](index.html) module
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior0::R](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior0::W](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: an alias for `Reg<IPRIOR1_SPEC>`
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register 1
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub struct R(crate::R<IPRIOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR1` writer
        pub struct W(crate::W<IPRIOR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_R = crate::FieldReader<u32>;
        ///Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR1_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<0> {
                IPRIOR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior1](index.html) module
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior1::R](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior1::W](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: an alias for `Reg<IPRIOR2_SPEC>`
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register 2
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub struct R(crate::R<IPRIOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR2` writer
        pub struct W(crate::W<IPRIOR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_R = crate::FieldReader<u32>;
        ///Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR2_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<0> {
                IPRIOR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior2](index.html) module
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior2::R](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior2::W](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: an alias for `Reg<IPRIOR3_SPEC>`
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register 3
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub struct R(crate::R<IPRIOR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR3` writer
        pub struct W(crate::W<IPRIOR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_R = crate::FieldReader<u32>;
        ///Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR3_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<0> {
                IPRIOR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior3](index.html) module
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior3::R](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior3::W](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: an alias for `Reg<IPRIOR4_SPEC>`
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register 4
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub struct R(crate::R<IPRIOR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR4` writer
        pub struct W(crate::W<IPRIOR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_R = crate::FieldReader<u32>;
        ///Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR4_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<0> {
                IPRIOR4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior4](index.html) module
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior4::R](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior4::W](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: an alias for `Reg<IPRIOR5_SPEC>`
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register 5
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub struct R(crate::R<IPRIOR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR5` writer
        pub struct W(crate::W<IPRIOR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_R = crate::FieldReader<u32>;
        ///Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR5_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<0> {
                IPRIOR5_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 5
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior5](index.html) module
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior5::R](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior5::W](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: an alias for `Reg<IPRIOR6_SPEC>`
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register 6
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub struct R(crate::R<IPRIOR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR6` writer
        pub struct W(crate::W<IPRIOR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_R = crate::FieldReader<u32>;
        ///Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR6_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<0> {
                IPRIOR6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 6
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior6](index.html) module
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior6::R](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior6::W](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: an alias for `Reg<IPRIOR7_SPEC>`
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register 7
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub struct R(crate::R<IPRIOR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR7` writer
        pub struct W(crate::W<IPRIOR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_R = crate::FieldReader<u32>;
        ///Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR7_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<0> {
                IPRIOR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 7
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior7](index.html) module
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior7::R](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior7::W](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: an alias for `Reg<IPRIOR8_SPEC>`
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register 8
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub struct R(crate::R<IPRIOR8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR8` writer
        pub struct W(crate::W<IPRIOR8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR8_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR8` reader - RW,Interrupt priority for number 32-35
        pub type IPRIOR8_R = crate::FieldReader<u32>;
        ///Field `IPRIOR8` writer - RW,Interrupt priority for number 32-35
        pub type IPRIOR8_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR8_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 32-35
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 32-35
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<0> {
                IPRIOR8_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 8
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior8](index.html) module
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior8::R](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior8::W](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: an alias for `Reg<IPRIOR9_SPEC>`
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register 9
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub struct R(crate::R<IPRIOR9_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR9_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR9_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR9` writer
        pub struct W(crate::W<IPRIOR9_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR9_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR9_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_R = crate::FieldReader<u32>;
        ///Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR9_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<0> {
                IPRIOR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 9
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior9](index.html) module
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior9::R](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior9::W](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: an alias for `Reg<IPRIOR10_SPEC>`
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register 10
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub struct R(crate::R<IPRIOR10_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR10_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR10_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR10` writer
        pub struct W(crate::W<IPRIOR10_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR10_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR10_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_R = crate::FieldReader<u32>;
        ///Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR10_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<0> {
                IPRIOR10_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 10
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior10](index.html) module
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior10::R](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior10::W](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: an alias for `Reg<IPRIOR11_SPEC>`
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register 11
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub struct R(crate::R<IPRIOR11_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR11_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR11_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR11` writer
        pub struct W(crate::W<IPRIOR11_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR11_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR11_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_R = crate::FieldReader<u32>;
        ///Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR11_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<0> {
                IPRIOR11_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 11
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior11](index.html) module
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior11::R](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior11::W](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: an alias for `Reg<IPRIOR12_SPEC>`
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register 12
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub struct R(crate::R<IPRIOR12_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR12_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR12_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR12` writer
        pub struct W(crate::W<IPRIOR12_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR12_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR12_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_R = crate::FieldReader<u32>;
        ///Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR12_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<0> {
                IPRIOR12_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 12
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior12](index.html) module
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior12::R](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior12::W](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: an alias for `Reg<IPRIOR13_SPEC>`
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register 13
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub struct R(crate::R<IPRIOR13_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR13_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR13_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR13` writer
        pub struct W(crate::W<IPRIOR13_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR13_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR13_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_R = crate::FieldReader<u32>;
        ///Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR13_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<0> {
                IPRIOR13_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 13
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior13](index.html) module
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior13::R](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior13::W](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: an alias for `Reg<IPRIOR14_SPEC>`
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register 14
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub struct R(crate::R<IPRIOR14_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR14_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR14_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR14` writer
        pub struct W(crate::W<IPRIOR14_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR14_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR14_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_R = crate::FieldReader<u32>;
        ///Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR14_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<0> {
                IPRIOR14_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 14
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior14](index.html) module
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior14::R](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior14::W](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: an alias for `Reg<IPRIOR15_SPEC>`
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register 15
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub struct R(crate::R<IPRIOR15_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR15_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR15_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR15` writer
        pub struct W(crate::W<IPRIOR15_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR15_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR15_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_R = crate::FieldReader<u32>;
        ///Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR15_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<0> {
                IPRIOR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 15
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior15](index.html) module
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior15::R](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior15::W](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: an alias for `Reg<IPRIOR16_SPEC>`
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register 16
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub struct R(crate::R<IPRIOR16_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR16_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR16_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR16` writer
        pub struct W(crate::W<IPRIOR16_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR16_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR16_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_R = crate::FieldReader<u32>;
        ///Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR16_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<0> {
                IPRIOR16_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 16
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior16](index.html) module
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior16::R](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior16::W](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: an alias for `Reg<IPRIOR17_SPEC>`
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register 17
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub struct R(crate::R<IPRIOR17_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR17_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR17_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR17` writer
        pub struct W(crate::W<IPRIOR17_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR17_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR17_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_R = crate::FieldReader<u32>;
        ///Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR17_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<0> {
                IPRIOR17_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 17
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior17](index.html) module
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior17::R](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior17::W](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: an alias for `Reg<IPRIOR18_SPEC>`
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register 18
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub struct R(crate::R<IPRIOR18_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR18_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR18_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR18` writer
        pub struct W(crate::W<IPRIOR18_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR18_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR18_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_R = crate::FieldReader<u32>;
        ///Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR18_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<0> {
                IPRIOR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 18
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior18](index.html) module
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior18::R](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior18::W](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: an alias for `Reg<IPRIOR19_SPEC>`
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register 19
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub struct R(crate::R<IPRIOR19_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR19_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR19_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR19` writer
        pub struct W(crate::W<IPRIOR19_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR19_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR19_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_R = crate::FieldReader<u32>;
        ///Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR19_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<0> {
                IPRIOR19_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 19
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior19](index.html) module
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior19::R](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior19::W](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: an alias for `Reg<IPRIOR20_SPEC>`
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register 20
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub struct R(crate::R<IPRIOR20_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR20_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR20_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR20` writer
        pub struct W(crate::W<IPRIOR20_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR20_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR20_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_R = crate::FieldReader<u32>;
        ///Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR20_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<0> {
                IPRIOR20_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 20
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior20](index.html) module
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior20::R](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior20::W](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: an alias for `Reg<IPRIOR21_SPEC>`
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register 21
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub struct R(crate::R<IPRIOR21_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR21_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR21_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR21` writer
        pub struct W(crate::W<IPRIOR21_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR21_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR21_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_R = crate::FieldReader<u32>;
        ///Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR21_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<0> {
                IPRIOR21_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 21
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior21](index.html) module
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior21::R](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior21::W](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: an alias for `Reg<IPRIOR22_SPEC>`
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register 22
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub struct R(crate::R<IPRIOR22_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR22_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR22_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR22` writer
        pub struct W(crate::W<IPRIOR22_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR22_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR22_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_R = crate::FieldReader<u32>;
        ///Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR22_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<0> {
                IPRIOR22_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 22
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior22](index.html) module
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior22::R](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior22::W](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: an alias for `Reg<IPRIOR23_SPEC>`
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register 23
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub struct R(crate::R<IPRIOR23_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR23_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR23_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR23` writer
        pub struct W(crate::W<IPRIOR23_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR23_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR23_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_R = crate::FieldReader<u32>;
        ///Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR23_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<0> {
                IPRIOR23_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 23
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior23](index.html) module
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior23::R](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior23::W](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: an alias for `Reg<IPRIOR24_SPEC>`
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register 24
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub struct R(crate::R<IPRIOR24_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR24_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR24_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR24` writer
        pub struct W(crate::W<IPRIOR24_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR24_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR24_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_R = crate::FieldReader<u32>;
        ///Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR24_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<0> {
                IPRIOR24_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 24
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior24](index.html) module
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior24::R](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior24::W](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: an alias for `Reg<IPRIOR25_SPEC>`
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register 25
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub struct R(crate::R<IPRIOR25_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR25_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR25_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR25` writer
        pub struct W(crate::W<IPRIOR25_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR25_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR25_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_R = crate::FieldReader<u32>;
        ///Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR25_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<0> {
                IPRIOR25_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 25
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior25](index.html) module
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior25::R](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior25::W](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: an alias for `Reg<IPRIOR26_SPEC>`
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register 26
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub struct R(crate::R<IPRIOR26_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR26_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR26_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR26` writer
        pub struct W(crate::W<IPRIOR26_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR26_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR26_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_R = crate::FieldReader<u32>;
        ///Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR26_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<0> {
                IPRIOR26_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 26
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior26](index.html) module
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior26::R](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior26::W](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: an alias for `Reg<IPRIOR27_SPEC>`
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register 27
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub struct R(crate::R<IPRIOR27_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR27_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR27_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR27` writer
        pub struct W(crate::W<IPRIOR27_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR27_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR27_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_R = crate::FieldReader<u32>;
        ///Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR27_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<0> {
                IPRIOR27_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 27
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior27](index.html) module
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior27::R](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior27::W](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: an alias for `Reg<IPRIOR28_SPEC>`
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register 28
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub struct R(crate::R<IPRIOR28_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR28_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR28_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR28` writer
        pub struct W(crate::W<IPRIOR28_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR28_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR28_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_R = crate::FieldReader<u32>;
        ///Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR28_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<0> {
                IPRIOR28_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 28
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior28](index.html) module
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior28::R](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior28::W](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: an alias for `Reg<IPRIOR29_SPEC>`
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register 29
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub struct R(crate::R<IPRIOR29_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR29_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR29_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR29` writer
        pub struct W(crate::W<IPRIOR29_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR29_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR29_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_R = crate::FieldReader<u32>;
        ///Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR29_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<0> {
                IPRIOR29_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 29
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior29](index.html) module
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior29::R](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior29::W](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: an alias for `Reg<IPRIOR30_SPEC>`
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register 30
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub struct R(crate::R<IPRIOR30_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR30_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR30_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR30` writer
        pub struct W(crate::W<IPRIOR30_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR30_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR30_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_R = crate::FieldReader<u32>;
        ///Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR30_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<0> {
                IPRIOR30_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 30
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior30](index.html) module
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior30::R](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior30::W](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: an alias for `Reg<IPRIOR31_SPEC>`
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register 31
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub struct R(crate::R<IPRIOR31_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR31_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR31_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR31` writer
        pub struct W(crate::W<IPRIOR31_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR31_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR31_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_R = crate::FieldReader<u32>;
        ///Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR31_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<0> {
                IPRIOR31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 31
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior31](index.html) module
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior31::R](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior31::W](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: an alias for `Reg<IPRIOR32_SPEC>`
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register 32
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub struct R(crate::R<IPRIOR32_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR32_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR32_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR32` writer
        pub struct W(crate::W<IPRIOR32_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR32_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR32_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_R = crate::FieldReader<u32>;
        ///Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR32_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<0> {
                IPRIOR32_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 32
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior32](index.html) module
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior32::R](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior32::W](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: an alias for `Reg<IPRIOR33_SPEC>`
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register 33
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub struct R(crate::R<IPRIOR33_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR33_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR33_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR33` writer
        pub struct W(crate::W<IPRIOR33_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR33_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR33_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_R = crate::FieldReader<u32>;
        ///Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR33_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<0> {
                IPRIOR33_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 33
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior33](index.html) module
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior33::R](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior33::W](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: an alias for `Reg<IPRIOR34_SPEC>`
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register 34
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub struct R(crate::R<IPRIOR34_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR34_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR34_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR34` writer
        pub struct W(crate::W<IPRIOR34_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR34_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR34_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_R = crate::FieldReader<u32>;
        ///Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR34_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<0> {
                IPRIOR34_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 34
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior34](index.html) module
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior34::R](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior34::W](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: an alias for `Reg<IPRIOR35_SPEC>`
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register 35
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub struct R(crate::R<IPRIOR35_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR35_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR35_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR35` writer
        pub struct W(crate::W<IPRIOR35_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR35_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR35_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_R = crate::FieldReader<u32>;
        ///Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR35_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<0> {
                IPRIOR35_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 35
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior35](index.html) module
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior35::R](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior35::W](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: an alias for `Reg<IPRIOR36_SPEC>`
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register 36
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub struct R(crate::R<IPRIOR36_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR36_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR36_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR36` writer
        pub struct W(crate::W<IPRIOR36_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR36_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR36_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_R = crate::FieldReader<u32>;
        ///Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR36_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<0> {
                IPRIOR36_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 36
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior36](index.html) module
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior36::R](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior36::W](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: an alias for `Reg<IPRIOR37_SPEC>`
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register 37
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub struct R(crate::R<IPRIOR37_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR37_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR37_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR37` writer
        pub struct W(crate::W<IPRIOR37_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR37_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR37_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_R = crate::FieldReader<u32>;
        ///Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR37_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<0> {
                IPRIOR37_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 37
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior37](index.html) module
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior37::R](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior37::W](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: an alias for `Reg<IPRIOR38_SPEC>`
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register 38
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub struct R(crate::R<IPRIOR38_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR38_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR38_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR38` writer
        pub struct W(crate::W<IPRIOR38_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR38_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR38_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_R = crate::FieldReader<u32>;
        ///Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR38_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<0> {
                IPRIOR38_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 38
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior38](index.html) module
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior38::R](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior38::W](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: an alias for `Reg<IPRIOR39_SPEC>`
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register 39
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub struct R(crate::R<IPRIOR39_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR39_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR39_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR39` writer
        pub struct W(crate::W<IPRIOR39_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR39_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR39_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_R = crate::FieldReader<u32>;
        ///Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR39_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<0> {
                IPRIOR39_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 39
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior39](index.html) module
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior39::R](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior39::W](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: an alias for `Reg<IPRIOR40_SPEC>`
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register 40
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub struct R(crate::R<IPRIOR40_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR40_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR40_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR40` writer
        pub struct W(crate::W<IPRIOR40_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR40_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR40_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_R = crate::FieldReader<u32>;
        ///Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR40_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<0> {
                IPRIOR40_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 40
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior40](index.html) module
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior40::R](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior40::W](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: an alias for `Reg<IPRIOR41_SPEC>`
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register 41
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub struct R(crate::R<IPRIOR41_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR41_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR41_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR41` writer
        pub struct W(crate::W<IPRIOR41_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR41_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR41_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_R = crate::FieldReader<u32>;
        ///Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR41_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<0> {
                IPRIOR41_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 41
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior41](index.html) module
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior41::R](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior41::W](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: an alias for `Reg<IPRIOR42_SPEC>`
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register 42
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub struct R(crate::R<IPRIOR42_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR42_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR42_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR42` writer
        pub struct W(crate::W<IPRIOR42_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR42_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR42_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_R = crate::FieldReader<u32>;
        ///Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR42_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<0> {
                IPRIOR42_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 42
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior42](index.html) module
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior42::R](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior42::W](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: an alias for `Reg<IPRIOR43_SPEC>`
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register 43
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub struct R(crate::R<IPRIOR43_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR43_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR43_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR43` writer
        pub struct W(crate::W<IPRIOR43_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR43_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR43_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_R = crate::FieldReader<u32>;
        ///Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR43_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<0> {
                IPRIOR43_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 43
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior43](index.html) module
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior43::R](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior43::W](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: an alias for `Reg<IPRIOR44_SPEC>`
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register 44
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub struct R(crate::R<IPRIOR44_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR44_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR44_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR44` writer
        pub struct W(crate::W<IPRIOR44_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR44_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR44_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_R = crate::FieldReader<u32>;
        ///Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR44_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<0> {
                IPRIOR44_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 44
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior44](index.html) module
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior44::R](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior44::W](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: an alias for `Reg<IPRIOR45_SPEC>`
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register 45
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub struct R(crate::R<IPRIOR45_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR45_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR45_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR45` writer
        pub struct W(crate::W<IPRIOR45_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR45_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR45_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_R = crate::FieldReader<u32>;
        ///Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR45_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<0> {
                IPRIOR45_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 45
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior45](index.html) module
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior45::R](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior45::W](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: an alias for `Reg<IPRIOR46_SPEC>`
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register 46
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub struct R(crate::R<IPRIOR46_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR46_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR46_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR46` writer
        pub struct W(crate::W<IPRIOR46_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR46_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR46_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_R = crate::FieldReader<u32>;
        ///Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR46_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<0> {
                IPRIOR46_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 46
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior46](index.html) module
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior46::R](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior46::W](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: an alias for `Reg<IPRIOR47_SPEC>`
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register 47
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub struct R(crate::R<IPRIOR47_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR47_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR47_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR47` writer
        pub struct W(crate::W<IPRIOR47_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR47_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR47_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_R = crate::FieldReader<u32>;
        ///Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR47_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<0> {
                IPRIOR47_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 47
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior47](index.html) module
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior47::R](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior47::W](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: an alias for `Reg<IPRIOR48_SPEC>`
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register 48
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub struct R(crate::R<IPRIOR48_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR48_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR48_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR48` writer
        pub struct W(crate::W<IPRIOR48_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR48_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR48_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_R = crate::FieldReader<u32>;
        ///Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR48_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<0> {
                IPRIOR48_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 48
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior48](index.html) module
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior48::R](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior48::W](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: an alias for `Reg<IPRIOR49_SPEC>`
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register 49
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub struct R(crate::R<IPRIOR49_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR49_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR49_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR49` writer
        pub struct W(crate::W<IPRIOR49_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR49_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR49_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_R = crate::FieldReader<u32>;
        ///Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR49_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<0> {
                IPRIOR49_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 49
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior49](index.html) module
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior49::R](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior49::W](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: an alias for `Reg<IPRIOR50_SPEC>`
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register 50
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub struct R(crate::R<IPRIOR50_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR50_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR50_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR50` writer
        pub struct W(crate::W<IPRIOR50_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR50_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR50_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_R = crate::FieldReader<u32>;
        ///Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR50_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<0> {
                IPRIOR50_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 50
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior50](index.html) module
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior50::R](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior50::W](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: an alias for `Reg<IPRIOR51_SPEC>`
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register 51
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub struct R(crate::R<IPRIOR51_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR51_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR51_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR51` writer
        pub struct W(crate::W<IPRIOR51_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR51_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR51_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_R = crate::FieldReader<u32>;
        ///Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR51_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<0> {
                IPRIOR51_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 51
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior51](index.html) module
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior51::R](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior51::W](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: an alias for `Reg<IPRIOR52_SPEC>`
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register 52
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub struct R(crate::R<IPRIOR52_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR52_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR52_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR52` writer
        pub struct W(crate::W<IPRIOR52_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR52_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR52_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_R = crate::FieldReader<u32>;
        ///Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR52_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<0> {
                IPRIOR52_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 52
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior52](index.html) module
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior52::R](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior52::W](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: an alias for `Reg<IPRIOR53_SPEC>`
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register 53
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub struct R(crate::R<IPRIOR53_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR53_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR53_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR53` writer
        pub struct W(crate::W<IPRIOR53_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR53_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR53_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_R = crate::FieldReader<u32>;
        ///Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR53_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<0> {
                IPRIOR53_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 53
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior53](index.html) module
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior53::R](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior53::W](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: an alias for `Reg<IPRIOR54_SPEC>`
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register 54
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub struct R(crate::R<IPRIOR54_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR54_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR54_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR54` writer
        pub struct W(crate::W<IPRIOR54_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR54_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR54_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_R = crate::FieldReader<u32>;
        ///Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR54_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<0> {
                IPRIOR54_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 54
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior54](index.html) module
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior54::R](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior54::W](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: an alias for `Reg<IPRIOR55_SPEC>`
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register 55
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub struct R(crate::R<IPRIOR55_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR55_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR55_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR55` writer
        pub struct W(crate::W<IPRIOR55_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR55_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR55_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_R = crate::FieldReader<u32>;
        ///Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR55_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<0> {
                IPRIOR55_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 55
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior55](index.html) module
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior55::R](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior55::W](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: an alias for `Reg<IPRIOR56_SPEC>`
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register 56
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub struct R(crate::R<IPRIOR56_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR56_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR56_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR56` writer
        pub struct W(crate::W<IPRIOR56_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR56_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR56_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_R = crate::FieldReader<u32>;
        ///Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR56_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<0> {
                IPRIOR56_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 56
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior56](index.html) module
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior56::R](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior56::W](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: an alias for `Reg<IPRIOR57_SPEC>`
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register 57
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub struct R(crate::R<IPRIOR57_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR57_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR57_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR57` writer
        pub struct W(crate::W<IPRIOR57_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR57_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR57_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_R = crate::FieldReader<u32>;
        ///Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR57_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<0> {
                IPRIOR57_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 57
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior57](index.html) module
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior57::R](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior57::W](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: an alias for `Reg<IPRIOR58_SPEC>`
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register 58
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub struct R(crate::R<IPRIOR58_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR58_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR58_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR58` writer
        pub struct W(crate::W<IPRIOR58_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR58_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR58_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_R = crate::FieldReader<u32>;
        ///Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR58_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<0> {
                IPRIOR58_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 58
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior58](index.html) module
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior58::R](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior58::W](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: an alias for `Reg<IPRIOR59_SPEC>`
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register 59
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub struct R(crate::R<IPRIOR59_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR59_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR59_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR59` writer
        pub struct W(crate::W<IPRIOR59_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR59_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR59_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_R = crate::FieldReader<u32>;
        ///Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR59_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<0> {
                IPRIOR59_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 59
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior59](index.html) module
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior59::R](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior59::W](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: an alias for `Reg<IPRIOR60_SPEC>`
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register 60
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub struct R(crate::R<IPRIOR60_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR60_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR60_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR60` writer
        pub struct W(crate::W<IPRIOR60_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR60_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR60_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_R = crate::FieldReader<u32>;
        ///Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR60_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<0> {
                IPRIOR60_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 60
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior60](index.html) module
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior60::R](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior60::W](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: an alias for `Reg<IPRIOR61_SPEC>`
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register 61
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub struct R(crate::R<IPRIOR61_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR61_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR61_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR61` writer
        pub struct W(crate::W<IPRIOR61_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR61_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR61_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_R = crate::FieldReader<u32>;
        ///Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR61_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<0> {
                IPRIOR61_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 61
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior61](index.html) module
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior61::R](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior61::W](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: an alias for `Reg<IPRIOR62_SPEC>`
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register 62
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub struct R(crate::R<IPRIOR62_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR62_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR62_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR62` writer
        pub struct W(crate::W<IPRIOR62_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR62_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR62_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_R = crate::FieldReader<u32>;
        ///Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR62_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<0> {
                IPRIOR62_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 62
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior62](index.html) module
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior62::R](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior62::W](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: an alias for `Reg<IPRIOR63_SPEC>`
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register 63
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub struct R(crate::R<IPRIOR63_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR63_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR63_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR63` writer
        pub struct W(crate::W<IPRIOR63_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR63_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR63_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_R = crate::FieldReader<u32>;
        ///Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_W<'a, const O: u8> = crate::FieldWriter<'a, IPRIOR63_SPEC, 32, O, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<0> {
                IPRIOR63_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 63
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior63](index.html) module
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprior63::R](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior63::W](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SCTLR (rw) register accessor: an alias for `Reg<SCTLR_SPEC>`
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub struct R(crate::R<SCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SCTLR` writer
        pub struct W(crate::W<SCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader;
        ///Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, const O: u8> = crate::BitWriter<'a, SCTLR_SPEC, O>;
        ///Field `SLEEPDEEP` reader - RW,SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader;
        ///Field `SLEEPDEEP` writer - RW,SLEEPDEEP
        pub type SLEEPDEEP_W<'a, const O: u8> = crate::BitWriter<'a, SCTLR_SPEC, O>;
        ///Field `WFITOWFE` reader - RW,WFITOWFE
        pub type WFITOWFE_R = crate::BitReader;
        ///Field `WFITOWFE` writer - RW,WFITOWFE
        pub type WFITOWFE_W<'a, const O: u8> = crate::BitWriter<'a, SCTLR_SPEC, O>;
        ///Field `SEVONPEND` reader - RW,SEVONPEND
        pub type SEVONPEND_R = crate::BitReader;
        ///Field `SEVONPEND` writer - RW,SEVONPEND
        pub type SEVONPEND_W<'a, const O: u8> = crate::BitWriter<'a, SCTLR_SPEC, O>;
        ///Field `SETEVENT` reader - WO,SETEVENT
        pub type SETEVENT_R = crate::BitReader;
        ///Field `SETEVENT` writer - WO,SETEVENT
        pub type SETEVENT_W<'a, const O: u8> = crate::BitWriter<'a, SCTLR_SPEC, O>;
        impl R {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<1> {
                SLEEPONEXIT_W::new(self)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<2> {
                SLEEPDEEP_W::new(self)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<3> {
                WFITOWFE_W::new(self)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<4> {
                SEVONPEND_W::new(self)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<5> {
                SETEVENT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System Control Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sctlr](index.html) module
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sctlr::R](R) reader structure
        impl crate::Readable for SCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sctlr::W](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - System count control register
        pub ctlr: CTLR,
        ///0x04 - System count status register
        pub sr: SR,
        ///0x08..0x10 - System counter register
        pub cnt: CNT,
        ///0x10..0x18 - System count compare register
        pub cmp: CMP,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///System count control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `STE` reader - Counter enable control bit
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - Counter enable control bit
        pub type STE_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O>;
        ///Field `STIE` reader - Counter interrupt enable control bit
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - Counter interrupt enable control bit
        pub type STIE_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O>;
        ///Field `STCLK` reader - Counter system clock sourse selection bit
        pub type STCLK_R = crate::BitReader<STCLK_A>;
        ///Counter system clock sourse selection bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STCLK_A {
            ///0: HCLK/8
            HclkDiv8 = 0,
            ///1: HCLK
            Hclk = 1,
        }
        impl From<STCLK_A> for bool {
            #[inline(always)]
            fn from(variant: STCLK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STCLK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STCLK_A {
                match self.bits {
                    false => STCLK_A::HclkDiv8,
                    true => STCLK_A::Hclk,
                }
            }
            ///Checks if the value of the field is `HclkDiv8`
            #[inline(always)]
            pub fn is_hclk_div8(&self) -> bool {
                *self == STCLK_A::HclkDiv8
            }
            ///Checks if the value of the field is `Hclk`
            #[inline(always)]
            pub fn is_hclk(&self) -> bool {
                *self == STCLK_A::Hclk
            }
        }
        ///Field `STCLK` writer - Counter system clock sourse selection bit
        pub type STCLK_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O, STCLK_A>;
        impl<'a, const O: u8> STCLK_W<'a, O> {
            ///HCLK/8
            #[inline(always)]
            pub fn hclk_div8(self) -> &'a mut W {
                self.variant(STCLK_A::HclkDiv8)
            }
            ///HCLK
            #[inline(always)]
            pub fn hclk(self) -> &'a mut W {
                self.variant(STCLK_A::Hclk)
            }
        }
        ///Field `STRE` reader - Auto reload count enable bit
        pub type STRE_R = crate::BitReader;
        ///Field `STRE` writer - Auto reload count enable bit
        pub type STRE_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O>;
        ///Field `MODE` reader - Counter mode
        pub type MODE_R = crate::BitReader<MODE_A>;
        ///Counter mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE_A {
            ///0: Upcount
            Upcount = 0,
            ///1: Downcount
            Downcount = 1,
        }
        impl From<MODE_A> for bool {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODE_A {
                match self.bits {
                    false => MODE_A::Upcount,
                    true => MODE_A::Downcount,
                }
            }
            ///Checks if the value of the field is `Upcount`
            #[inline(always)]
            pub fn is_upcount(&self) -> bool {
                *self == MODE_A::Upcount
            }
            ///Checks if the value of the field is `Downcount`
            #[inline(always)]
            pub fn is_downcount(&self) -> bool {
                *self == MODE_A::Downcount
            }
        }
        ///Field `MODE` writer - Counter mode
        pub type MODE_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O, MODE_A>;
        impl<'a, const O: u8> MODE_W<'a, O> {
            ///Upcount
            #[inline(always)]
            pub fn upcount(self) -> &'a mut W {
                self.variant(MODE_A::Upcount)
            }
            ///Downcount
            #[inline(always)]
            pub fn downcount(self) -> &'a mut W {
                self.variant(MODE_A::Downcount)
            }
        }
        ///Field `INIT` reader - Counter initial value update
        pub type INIT_R = crate::BitReader;
        ///Field `INIT` writer - Counter initial value update
        pub type INIT_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O>;
        ///Field `SWIE` reader - Software interrupt enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - Software interrupt enable
        pub type SWIE_W<'a, const O: u8> = crate::BitWriter<'a, CTLR_SPEC, O>;
        impl R {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<0> {
                STE_W::new(self)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<1> {
                STIE_W::new(self)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<2> {
                STCLK_W::new(self)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<3> {
                STRE_W::new(self)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<4> {
                MODE_W::new(self)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<5> {
                INIT_W::new(self)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<31> {
                SWIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System count control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SR (rw) register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///System count status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTIF` reader - Count value compare flag
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - Count value compare flag
        pub type CNTIF_W<'a, const O: u8> = crate::BitWriter<'a, SR_SPEC, O>;
        impl R {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<0> {
                CNTIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System count status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///System counter register
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CMP (rw) register accessor: an alias for `Reg<CMP_SPEC>`
    pub type CMP = crate::Reg<cmp::CMP_SPEC>;
    ///System count compare register
    pub mod cmp {
        ///Register `CMP` reader
        pub struct R(crate::R<CMP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CMP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CMP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CMP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CMP` writer
        pub struct W(crate::W<CMP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CMP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CMP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CMP_SPEC>) -> Self {
                W(writer)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMP_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                self.read().fmt(f)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System count compare register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cmp](index.html) module
        pub struct CMP_SPEC;
        impl crate::RegisterSpec for CMP_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [cmp::R](R) reader structure
        impl crate::Readable for CMP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cmp::W](W) writer structure
        impl crate::Writable for CMP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CMP to value 0
        impl crate::Resettable for CMP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///RTC
    pub RTC: RTC,
    ///SYSCTL
    pub SYSCTL: SYSCTL,
    ///TOUCH_KEY
    pub TOUCH_KEY: TOUCH_KEY,
    ///ADC
    pub ADC: ADC,
    ///GPIO
    pub GPIO: GPIO,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///TMR3
    pub TMR3: TMR3,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///I2C
    pub I2C: I2C,
    ///PWMX
    pub PWMX: PWMX,
    ///LCD
    pub LCD: LCD,
    ///USB
    pub USB: USB,
    ///PFIC
    pub PFIC: PFIC,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            SYSCTL: SYSCTL {
                _marker: PhantomData,
            },
            TOUCH_KEY: TOUCH_KEY {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            I2C: I2C {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            LCD: LCD {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
