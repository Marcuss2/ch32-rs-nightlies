//!Peripheral access API for CH583SFR microcontrollers (generated using svd2rust v0.27.2 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.27.2/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIO_A();
    fn GPIO_B();
    fn SPI0();
    fn BLEB();
    fn BLEL();
    fn USB();
    fn USB2();
    fn TMR1();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn I2C();
    fn PWMX();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 36] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIO_A },
    Vector { _handler: GPIO_B },
    Vector { _handler: SPI0 },
    Vector { _handler: BLEB },
    Vector { _handler: BLEL },
    Vector { _handler: USB },
    Vector { _handler: USB2 },
    Vector { _handler: TMR1 },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: I2C },
    Vector { _handler: PWMX },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: WDOG_BAT },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - TMR0_IRQHandler
        TMR0 = 16,
        ///17 - GPIO_IRQHandler
        GPIO_A = 17,
        ///18 - GPIO_IRQHandler
        GPIO_B = 18,
        ///19 - SPI0_IRQHandler
        SPI0 = 19,
        ///20 - BB_IRQHandler
        BLEB = 20,
        ///21 - LLE_IRQHandler
        BLEL = 21,
        ///22 - USB_IRQHandler
        USB = 22,
        ///23 - USB2_IRQHandler
        USB2 = 23,
        ///24 - TMR1_IRQHandler
        TMR1 = 24,
        ///25 - TMR2_IRQHandler
        TMR2 = 25,
        ///26 - UART0_IRQHandler
        UART0 = 26,
        ///27 - UART1_IRQHandler
        UART1 = 27,
        ///28 - RTC_IRQHandler
        RTC = 28,
        ///29 - ADC_IRQHandler
        ADC = 29,
        ///30 - I2C_IRQHandler
        I2C = 30,
        ///31 - PPWMX_SPI1_IRQHandler
        PWMX = 31,
        ///32 - TMR3_IRQHandler
        TMR3 = 32,
        ///33 - UART1_IRQHandler
        UART2 = 33,
        ///34 - UART3_IRQHandler
        UART3 = 34,
        ///35 - WDT_IRQHandler
        WDOG_BAT = 35,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::TMR0),
                17 => Ok(Interrupt::GPIO_A),
                18 => Ok(Interrupt::GPIO_B),
                19 => Ok(Interrupt::SPI0),
                20 => Ok(Interrupt::BLEB),
                21 => Ok(Interrupt::BLEL),
                22 => Ok(Interrupt::USB),
                23 => Ok(Interrupt::USB2),
                24 => Ok(Interrupt::TMR1),
                25 => Ok(Interrupt::TMR2),
                26 => Ok(Interrupt::UART0),
                27 => Ok(Interrupt::UART1),
                28 => Ok(Interrupt::RTC),
                29 => Ok(Interrupt::ADC),
                30 => Ok(Interrupt::I2C),
                31 => Ok(Interrupt::PWMX),
                32 => Ok(Interrupt::TMR3),
                33 => Ok(Interrupt::UART2),
                34 => Ok(Interrupt::UART3),
                35 => Ok(Interrupt::WDOG_BAT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///System Control Register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///System Control Register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x08],
        ///0x08 - RWA, system clock configuration, SAM
        pub r16_clk_sys_cfg: R16_CLK_SYS_CFG,
        ///0x0a - RWA, high frequency clock module power control, SAM
        pub r8_hfck_pwr_ctrl: R8_HFCK_PWR_CTRL,
        _reserved2: [u8; 0x01],
        ///0x0c - RWA, sleep clock off control byte 0, SAM
        pub r8_slp_clk_off0: R8_SLP_CLK_OFF0,
        ///0x0d - RWA, sleep clock off control byte 1, SAM
        pub r8_slp_clk_off1: R8_SLP_CLK_OFF1,
        ///0x0e - RWA, wake control, SAM
        pub r8_slp_wake_ctrl: R8_SLP_WAKE_CTRL,
        ///0x0f - RWA, peripherals power down control, SAM
        pub r8_slp_power_ctrl: R8_SLP_POWER_CTRL,
        _reserved6: [u8; 0x08],
        ///0x18 - RW, function pin alternate configuration
        pub r16_pin_alternate: R16_PIN_ALTERNATE,
        ///0x1a - RW, analog pin enable and digital input disable
        pub r16_pin_analog_ie: R16_PIN_ANALOG_IE,
        _reserved8: [u8; 0x04],
        ///0x20 - RWA, power plan before sleep instruction, SAM
        pub r16_power_plan: R16_POWER_PLAN,
        ///0x22 - RWA, aux power adjust control, SAM
        pub r8_aux_power_adj: R8_AUX_POWER_ADJ,
        _reserved10: [u8; 0x01],
        ///0x24 - RWA, battery voltage detector control, SAM
        pub r8_bat_det_ctrl: R8_BAT_DET_CTRL,
        ///0x25 - RWA, battery voltage detector configuration, SAM
        pub r8_bat_det_cfg: R8_BAT_DET_CFG,
        ///0x26 - RO, battery status
        pub r8_bat_status: R8_BAT_STATUS,
        _reserved13: [u8; 0x05],
        ///0x2c - RWA, internal 32KHz oscillator tune control, SAM
        pub r16_int32k_tune: R16_INT32K_TUNE,
        ///0x2e - RWA, external 32KHz oscillator tune control, SAM
        pub r8_xt32k_tune: R8_XT32K_TUNE,
        ///0x2f - RWA, 32KHz oscillator configure
        pub r8_ck32k_config: R8_CK32K_CONFIG,
        ///0x30 - RW, RTC flag and clear control
        pub r8_rtc_flag_ctrl: R8_RTC_FLAG_CTRL,
        ///0x31 - RWA, RTC mode control, SAM
        pub r8_rtc_mode_ctrl: R8_RTC_MODE_CTRL,
        _reserved18: [u8; 0x02],
        ///0x34 - RWA, RTC trigger value, SAM
        pub r32_rtc_trig: R32_RTC_TRIG,
        ///0x38 - RO, RTC count based 32KHz
        pub r16_rtc_cnt_32k: R16_RTC_CNT_32K,
        ///0x3a - RO, RTC count based 2 second
        pub r16_rtc_cnt_2s: R16_RTC_CNT_2S,
        ///0x3c - RO, RTC count based one day, only low 14 bit
        pub r32_rtc_cnt_day: R32_RTC_CNT_DAY,
        ///0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        pub r8_safe_access_sig: R8_SAFE_ACCESS_SIG,
        ///0x41 - RF, chip ID register, always is ID_CH58*
        pub r8_chip_id: R8_CHIP_ID,
        ///0x42 - RF, safe accessing ID register, always 0x0C
        pub r8_safe_access_id: R8_SAFE_ACCESS_ID,
        ///0x43 - RW, watch-dog count, count by clock frequency Fsys/131072
        pub r8_wdog_count: R8_WDOG_COUNT,
        ///0x44 - RWA, reset status, SAM or flash ROM configuration
        pub r8_reset_status__r8_glob_rom_cfg: R8_RESET_STATUS__R8_GLOB_ROM_CFG,
        ///0x45 - RO, global configuration information and status
        pub r8_glob_cfg_info: R8_GLOB_CFG_INFO,
        ///0x46 - RWA, reset and watch-dog control, SAM
        pub r8_rst_wdog_ctrl: R8_RST_WDOG_CTRL,
        ///0x47 - RW, value keeper during global reset
        pub r8_glob_reset_keep: R8_GLOB_RESET_KEEP,
        _reserved30: [u8; 0x03],
        ///0x4b - RWA, PLL configuration control, SAM
        pub r8_pll_config: R8_PLL_CONFIG,
        _reserved31: [u8; 0x02],
        ///0x4e - RWA, external 32MHz oscillator tune control, SAM
        pub r8_xt32m_tune: R8_XT32M_TUNE,
        _reserved32: [u8; 0x01],
        ///0x50 - RO, system clock count value for 32KHz multi-cycles
        pub r16_osc_cal_cnt: R16_OSC_CAL_CNT,
        ///0x52 - RO, oscillator frequency calibration overflow times
        pub r8_osc_cal_ov_cnt: R8_OSC_CAL_OV_CNT,
        ///0x53 - RWA, oscillator frequency calibration control, SAM
        pub r8_osc_cal_ctrl: R8_OSC_CAL_CTRL,
        ///0x54 - RW, Touchkey charge and discharge count
        pub r8_tkey_count: R8_TKEY_COUNT,
        _reserved36: [u8; 0x01],
        ///0x56 - RW, Touchkey convert start control
        pub r8_tkey_convert: R8_TKEY_CONVERT,
        ///0x57 - RW, Touchkey configure
        pub r8_tkey_cfg: R8_TKEY_CFG,
        ///0x58 - RW, ADC input channel selection
        pub r8_adc_channel: R8_ADC_CHANNEL,
        ///0x59 - RW, ADC configure
        pub r8_adc_cfg: R8_ADC_CFG,
        ///0x5a - RW, ADC convert control
        pub r8_adc_convert: R8_ADC_CONVERT,
        ///0x5b - RW, temperature sensor control
        pub r8_tem_sensor: R8_TEM_SENSOR,
        ///0x5c - RO, ADC data
        pub r16_adc_data: R16_ADC_DATA,
        ///0x5e - RO, ADC interrupt flag register
        pub r8_adc_int_flag: R8_ADC_INT_FLAG,
        _reserved44: [u8; 0x01],
        ///0x60 - RO, ADC DMA control and status register
        pub r32_adc_dma_ctrl: R32_ADC_DMA_CTRL,
        ///0x61 - RW, ADC DMA control
        pub r8_adc_ctrl_dma: R8_ADC_CTRL_DMA,
        ///0x62 - RO, ADC interrupt flag
        pub r8_adc_dma_if: R8_ADC_DMA_IF,
        ///0x63 - RO, ADC interrupt flag
        pub r8_adc_auto_cycle: R8_ADC_AUTO_CYCLE,
        ///0x64 - RO, ADC DMA current address
        pub r16_adc_dma_now: R16_ADC_DMA_NOW,
        _reserved49: [u8; 0x03],
        ///0x68 - RW, ADC DMA begin address
        pub r16_adc_dma_beg: R16_ADC_DMA_BEG,
        _reserved50: [u8; 0x03],
        ///0x6c - RW, ADC DMA end address
        pub r16_adc_dma_end: R16_ADC_DMA_END,
        _reserved51: [u8; 0x23],
        ///0x90 - RW, GPIO PA interrupt enable
        pub r16_pa_int_en: R16_PA_INT_EN,
        ///0x92 - RW, GPIO PB interrupt enable
        pub r16_pb_int_en: R16_PB_INT_EN,
        ///0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        pub r16_pa_int_mode: R16_PA_INT_MODE,
        ///0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        pub r16_pb_int_mode: R16_PB_INT_MODE,
        _reserved55: [u8; 0x04],
        ///0x9c - RW1, GPIO PA interrupt flag
        pub r16_pa_int_if: R16_PA_INT_IF,
        ///0x9e - RW1, GPIO PB interrupt flag
        pub r16_pb_int_if: R16_PB_INT_IF,
        ///0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out
        pub r32_pa_dir: R32_PA_DIR,
        ///0xa4 - RO, GPIO PA input
        pub r32_pa_pin: R32_PA_PIN,
        ///0xa8 - RW, GPIO PA output
        pub r32_pa_out: R32_PA_OUT,
        ///0xac - WZ, GPIO PA clear output: 0=keep, 1=clear
        pub r32_pa_clr: R32_PA_CLR,
        ///0xb0 - RW, GPIO PA pullup resistance enable
        pub r32_pa_pu: R32_PA_PU,
        ///0xb4 - RW, PA pulldown for input or PA driving capability for output
        pub r32_pa_pd_drv: R32_PA_PD_DRV,
        _reserved63: [u8; 0x08],
        ///0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out
        pub r32_pb_dir: R32_PB_DIR,
        ///0xc4 - RO, GPIO PB input
        pub r32_pb_pin: R32_PB_PIN,
        ///0xc8 - RW, GPIO PB output;RW, data for parallel slave read
        pub r32_pb_out__r8_slv_rd_data: R32_PB_OUT__R8_SLV_RD_DATA,
        ///0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear
        pub r32_pb_clr: R32_PB_CLR,
        ///0xd0 - RW, GPIO PB pullup resistance enable
        pub r32_pb_pu: R32_PB_PU,
        ///0xd4 - RW, PB pulldown for input or PB driving capability for output
        pub r32_pb_pd_drv: R32_PB_PD_DRV,
    }
    ///R16_CLK_SYS_CFG (rw) register accessor: an alias for `Reg<R16_CLK_SYS_CFG_SPEC>`
    pub type R16_CLK_SYS_CFG = crate::Reg<r16_clk_sys_cfg::R16_CLK_SYS_CFG_SPEC>;
    ///RWA, system clock configuration, SAM
    pub mod r16_clk_sys_cfg {
        ///Register `R16_CLK_SYS_CFG` reader
        pub struct R(crate::R<R16_CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_CLK_SYS_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_CLK_SYS_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_CLK_SYS_CFG` writer
        pub struct W(crate::W<R16_CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_CLK_SYS_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_CLK_SYS_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M
        pub type RB_CLK_PLL_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `RB_CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M
        pub type RB_CLK_PLL_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_CLK_SYS_CFG_SPEC, u8, u8, 5, O>;
        ///Field `RB_CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type RB_CLK_SYS_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type RB_CLK_SYS_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_CLK_SYS_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            pub fn rb_clk_pll_div(&self) -> RB_CLK_PLL_DIV_R {
                RB_CLK_PLL_DIV_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            pub fn rb_clk_sys_mod(&self) -> RB_CLK_SYS_MOD_R {
                RB_CLK_SYS_MOD_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_pll_div(&mut self) -> RB_CLK_PLL_DIV_W<0> {
                RB_CLK_PLL_DIV_W::new(self)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_sys_mod(&mut self) -> RB_CLK_SYS_MOD_W<6> {
                RB_CLK_SYS_MOD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, system clock configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_clk_sys_cfg](index.html) module
        pub struct R16_CLK_SYS_CFG_SPEC;
        impl crate::RegisterSpec for R16_CLK_SYS_CFG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_clk_sys_cfg::R](R) reader structure
        impl crate::Readable for R16_CLK_SYS_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_clk_sys_cfg::W](W) writer structure
        impl crate::Writable for R16_CLK_SYS_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_CLK_SYS_CFG to value 0x05
        impl crate::Resettable for R16_CLK_SYS_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x05;
        }
    }
    ///R8_HFCK_PWR_CTRL (rw) register accessor: an alias for `Reg<R8_HFCK_PWR_CTRL_SPEC>`
    pub type R8_HFCK_PWR_CTRL = crate::Reg<r8_hfck_pwr_ctrl::R8_HFCK_PWR_CTRL_SPEC>;
    ///RWA, high frequency clock module power control, SAM
    pub mod r8_hfck_pwr_ctrl {
        ///Register `R8_HFCK_PWR_CTRL` reader
        pub struct R(crate::R<R8_HFCK_PWR_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_HFCK_PWR_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_HFCK_PWR_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_HFCK_PWR_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_HFCK_PWR_CTRL` writer
        pub struct W(crate::W<R8_HFCK_PWR_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_HFCK_PWR_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_HFCK_PWR_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_HFCK_PWR_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type RB_CLK_XT32M_PON_R = crate::BitReader<bool>;
        ///Field `RB_CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type RB_CLK_XT32M_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_HFCK_PWR_CTRL_SPEC, bool, O>;
        ///Field `RB_CLK_XT32M_KEEP` reader - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type RB_CLK_XT32M_KEEP_R = crate::BitReader<bool>;
        ///Field `RB_CLK_XT32M_KEEP` writer - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type RB_CLK_XT32M_KEEP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_HFCK_PWR_CTRL_SPEC, bool, O>;
        ///Field `RB_CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on
        pub type RB_CLK_PLL_PON_R = crate::BitReader<bool>;
        ///Field `RB_CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on
        pub type RB_CLK_PLL_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_HFCK_PWR_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn rb_clk_xt32m_pon(&self) -> RB_CLK_XT32M_PON_R {
                RB_CLK_XT32M_PON_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            pub fn rb_clk_xt32m_keep(&self) -> RB_CLK_XT32M_KEEP_R {
                RB_CLK_XT32M_KEEP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn rb_clk_pll_pon(&self) -> RB_CLK_PLL_PON_R {
                RB_CLK_PLL_PON_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_xt32m_pon(&mut self) -> RB_CLK_XT32M_PON_W<2> {
                RB_CLK_XT32M_PON_W::new(self)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_xt32m_keep(&mut self) -> RB_CLK_XT32M_KEEP_W<3> {
                RB_CLK_XT32M_KEEP_W::new(self)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_pll_pon(&mut self) -> RB_CLK_PLL_PON_W<4> {
                RB_CLK_PLL_PON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, high frequency clock module power control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_hfck_pwr_ctrl](index.html) module
        pub struct R8_HFCK_PWR_CTRL_SPEC;
        impl crate::RegisterSpec for R8_HFCK_PWR_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_hfck_pwr_ctrl::R](R) reader structure
        impl crate::Readable for R8_HFCK_PWR_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_hfck_pwr_ctrl::W](W) writer structure
        impl crate::Writable for R8_HFCK_PWR_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_HFCK_PWR_CTRL to value 0x14
        impl crate::Resettable for R8_HFCK_PWR_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x14;
        }
    }
    ///R8_SLP_CLK_OFF0 (rw) register accessor: an alias for `Reg<R8_SLP_CLK_OFF0_SPEC>`
    pub type R8_SLP_CLK_OFF0 = crate::Reg<r8_slp_clk_off0::R8_SLP_CLK_OFF0_SPEC>;
    ///RWA, sleep clock off control byte 0, SAM
    pub mod r8_slp_clk_off0 {
        ///Register `R8_SLP_CLK_OFF0` reader
        pub struct R(crate::R<R8_SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SLP_CLK_OFF0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SLP_CLK_OFF0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SLP_CLK_OFF0` writer
        pub struct W(crate::W<R8_SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SLP_CLK_OFF0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SLP_CLK_OFF0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SLP_CLK_TMR0` reader - RWA, close TMR0 clock
        pub type RB_SLP_CLK_TMR0_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_TMR0` writer - RWA, close TMR0 clock
        pub type RB_SLP_CLK_TMR0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_TMR1` reader - RWA, close TMR1 clock
        pub type RB_SLP_CLK_TMR1_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_TMR1` writer - RWA, close TMR1 clock
        pub type RB_SLP_CLK_TMR1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_TMR2` reader - RWA, close TMR2 clock
        pub type RB_SLP_CLK_TMR2_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_TMR2` writer - RWA, close TMR2 clock
        pub type RB_SLP_CLK_TMR2_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_TMR3` reader - RWA, close TMR3 clock
        pub type RB_SLP_CLK_TMR3_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_TMR3` writer - RWA, close TMR3 clock
        pub type RB_SLP_CLK_TMR3_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_UART0` reader - RWA, close UART0 clock
        pub type RB_SLP_CLK_UART0_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_UART0` writer - RWA, close UART0 clock
        pub type RB_SLP_CLK_UART0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_UART1` reader - RWA, close UART1 clock
        pub type RB_SLP_CLK_UART1_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_UART1` writer - RWA, close UART1 clock
        pub type RB_SLP_CLK_UART1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_UART2` reader - RWA, close UART2 clock
        pub type RB_SLP_CLK_UART2_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_UART2` writer - RWA, close UART2 clock
        pub type RB_SLP_CLK_UART2_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_UART3` reader - RWA, close UART3 clock
        pub type RB_SLP_CLK_UART3_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_UART3` writer - RWA, close UART3 clock
        pub type RB_SLP_CLK_UART3_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF0_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            pub fn rb_slp_clk_tmr0(&self) -> RB_SLP_CLK_TMR0_R {
                RB_SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            pub fn rb_slp_clk_tmr1(&self) -> RB_SLP_CLK_TMR1_R {
                RB_SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            pub fn rb_slp_clk_tmr2(&self) -> RB_SLP_CLK_TMR2_R {
                RB_SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            pub fn rb_slp_clk_tmr3(&self) -> RB_SLP_CLK_TMR3_R {
                RB_SLP_CLK_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            pub fn rb_slp_clk_uart0(&self) -> RB_SLP_CLK_UART0_R {
                RB_SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            pub fn rb_slp_clk_uart1(&self) -> RB_SLP_CLK_UART1_R {
                RB_SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            pub fn rb_slp_clk_uart2(&self) -> RB_SLP_CLK_UART2_R {
                RB_SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            pub fn rb_slp_clk_uart3(&self) -> RB_SLP_CLK_UART3_R {
                RB_SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_tmr0(&mut self) -> RB_SLP_CLK_TMR0_W<0> {
                RB_SLP_CLK_TMR0_W::new(self)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_tmr1(&mut self) -> RB_SLP_CLK_TMR1_W<1> {
                RB_SLP_CLK_TMR1_W::new(self)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_tmr2(&mut self) -> RB_SLP_CLK_TMR2_W<2> {
                RB_SLP_CLK_TMR2_W::new(self)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_tmr3(&mut self) -> RB_SLP_CLK_TMR3_W<3> {
                RB_SLP_CLK_TMR3_W::new(self)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_uart0(&mut self) -> RB_SLP_CLK_UART0_W<4> {
                RB_SLP_CLK_UART0_W::new(self)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_uart1(&mut self) -> RB_SLP_CLK_UART1_W<5> {
                RB_SLP_CLK_UART1_W::new(self)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_uart2(&mut self) -> RB_SLP_CLK_UART2_W<6> {
                RB_SLP_CLK_UART2_W::new(self)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_uart3(&mut self) -> RB_SLP_CLK_UART3_W<7> {
                RB_SLP_CLK_UART3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 0, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_slp_clk_off0](index.html) module
        pub struct R8_SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for R8_SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_slp_clk_off0::R](R) reader structure
        impl crate::Readable for R8_SLP_CLK_OFF0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_slp_clk_off0::W](W) writer structure
        impl crate::Writable for R8_SLP_CLK_OFF0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SLP_CLK_OFF0 to value 0
        impl crate::Resettable for R8_SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SLP_CLK_OFF1 (rw) register accessor: an alias for `Reg<R8_SLP_CLK_OFF1_SPEC>`
    pub type R8_SLP_CLK_OFF1 = crate::Reg<r8_slp_clk_off1::R8_SLP_CLK_OFF1_SPEC>;
    ///RWA, sleep clock off control byte 1, SAM
    pub mod r8_slp_clk_off1 {
        ///Register `R8_SLP_CLK_OFF1` reader
        pub struct R(crate::R<R8_SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SLP_CLK_OFF1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SLP_CLK_OFF1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SLP_CLK_OFF1` writer
        pub struct W(crate::W<R8_SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SLP_CLK_OFF1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SLP_CLK_OFF1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SLP_CLK_SPI0` reader - RWA, close SPI0 clock
        pub type RB_SLP_CLK_SPI0_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_SPI0` writer - RWA, close SPI0 clock
        pub type RB_SLP_CLK_SPI0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_SPI1` reader - RWA, close SPI1 clock
        pub type RB_SLP_CLK_SPI1_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_SPI1` writer - RWA, close SPI1 clock
        pub type RB_SLP_CLK_SPI1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_PWMX` reader - RWA, close PWMx clock
        pub type RB_SLP_CLK_PWMX_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_PWMX` writer - RWA, close PWMx clock
        pub type RB_SLP_CLK_PWMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_I2C` reader - RWA, close I2C clock
        pub type RB_SLP_CLK_I2C_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_I2C` writer - RWA, close I2C clock
        pub type RB_SLP_CLK_I2C_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_USB` reader - RWA, close USB clock
        pub type RB_SLP_CLK_USB_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_USB` writer - RWA, close USB clock
        pub type RB_SLP_CLK_USB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_BLE` reader - RWA, close BLE clock
        pub type RB_SLP_CLK_BLE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_BLE` writer - RWA, close BLE clock
        pub type RB_SLP_CLK_BLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_CLK_OFF1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            pub fn rb_slp_clk_spi0(&self) -> RB_SLP_CLK_SPI0_R {
                RB_SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            pub fn rb_slp_clk_spi1(&self) -> RB_SLP_CLK_SPI1_R {
                RB_SLP_CLK_SPI1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            pub fn rb_slp_clk_pwmx(&self) -> RB_SLP_CLK_PWMX_R {
                RB_SLP_CLK_PWMX_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            pub fn rb_slp_clk_i2c(&self) -> RB_SLP_CLK_I2C_R {
                RB_SLP_CLK_I2C_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            pub fn rb_slp_clk_usb(&self) -> RB_SLP_CLK_USB_R {
                RB_SLP_CLK_USB_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            pub fn rb_slp_clk_ble(&self) -> RB_SLP_CLK_BLE_R {
                RB_SLP_CLK_BLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_spi0(&mut self) -> RB_SLP_CLK_SPI0_W<0> {
                RB_SLP_CLK_SPI0_W::new(self)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_spi1(&mut self) -> RB_SLP_CLK_SPI1_W<1> {
                RB_SLP_CLK_SPI1_W::new(self)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_pwmx(&mut self) -> RB_SLP_CLK_PWMX_W<2> {
                RB_SLP_CLK_PWMX_W::new(self)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_i2c(&mut self) -> RB_SLP_CLK_I2C_W<3> {
                RB_SLP_CLK_I2C_W::new(self)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_usb(&mut self) -> RB_SLP_CLK_USB_W<4> {
                RB_SLP_CLK_USB_W::new(self)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_ble(&mut self) -> RB_SLP_CLK_BLE_W<7> {
                RB_SLP_CLK_BLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 1, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_slp_clk_off1](index.html) module
        pub struct R8_SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for R8_SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_slp_clk_off1::R](R) reader structure
        impl crate::Readable for R8_SLP_CLK_OFF1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_slp_clk_off1::W](W) writer structure
        impl crate::Writable for R8_SLP_CLK_OFF1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SLP_CLK_OFF1 to value 0
        impl crate::Resettable for R8_SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SLP_WAKE_CTRL (rw) register accessor: an alias for `Reg<R8_SLP_WAKE_CTRL_SPEC>`
    pub type R8_SLP_WAKE_CTRL = crate::Reg<r8_slp_wake_ctrl::R8_SLP_WAKE_CTRL_SPEC>;
    ///RWA, wake control, SAM
    pub mod r8_slp_wake_ctrl {
        ///Register `R8_SLP_WAKE_CTRL` reader
        pub struct R(crate::R<R8_SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SLP_WAKE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SLP_WAKE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SLP_WAKE_CTRL` writer
        pub struct W(crate::W<R8_SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SLP_WAKE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SLP_WAKE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SLP_USB_WAKE` reader - RWA, enable USB waking
        pub type RB_SLP_USB_WAKE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_USB_WAKE` writer - RWA, enable USB waking
        pub type RB_SLP_USB_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `RB_SLP_USB2_WAKE` reader - RWA, enable USB2 waking
        pub type RB_SLP_USB2_WAKE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_USB2_WAKE` writer - RWA, enable USB2 waking
        pub type RB_SLP_USB2_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `RB_SLP_RTC_WAKE` reader - RWA, enable RTC waking
        pub type RB_SLP_RTC_WAKE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_RTC_WAKE` writer - RWA, enable RTC waking
        pub type RB_SLP_RTC_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `RB_SLP_GPIO_WAKE` reader - RWA, enable GPIO waking
        pub type RB_SLP_GPIO_WAKE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_GPIO_WAKE` writer - RWA, enable GPIO waking
        pub type RB_SLP_GPIO_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `RB_SLP_BAT_WAKE` reader - RWA, enable BAT waking
        pub type RB_SLP_BAT_WAKE_R = crate::BitReader<bool>;
        ///Field `RB_SLP_BAT_WAKE` writer - RWA, enable BAT waking
        pub type RB_SLP_BAT_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `RB_WAKE_EV_MODE` reader - RWA, event wakeup mode
        pub type RB_WAKE_EV_MODE_R = crate::BitReader<bool>;
        ///Field `RB_WAKE_EV_MODE` writer - RWA, event wakeup mode
        pub type RB_WAKE_EV_MODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_WAKE_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            pub fn rb_slp_usb_wake(&self) -> RB_SLP_USB_WAKE_R {
                RB_SLP_USB_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            pub fn rb_slp_usb2_wake(&self) -> RB_SLP_USB2_WAKE_R {
                RB_SLP_USB2_WAKE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            pub fn rb_slp_rtc_wake(&self) -> RB_SLP_RTC_WAKE_R {
                RB_SLP_RTC_WAKE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            pub fn rb_slp_gpio_wake(&self) -> RB_SLP_GPIO_WAKE_R {
                RB_SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            pub fn rb_slp_bat_wake(&self) -> RB_SLP_BAT_WAKE_R {
                RB_SLP_BAT_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            pub fn rb_wake_ev_mode(&self) -> RB_WAKE_EV_MODE_R {
                RB_WAKE_EV_MODE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_usb_wake(&mut self) -> RB_SLP_USB_WAKE_W<0> {
                RB_SLP_USB_WAKE_W::new(self)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_usb2_wake(&mut self) -> RB_SLP_USB2_WAKE_W<1> {
                RB_SLP_USB2_WAKE_W::new(self)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_rtc_wake(&mut self) -> RB_SLP_RTC_WAKE_W<3> {
                RB_SLP_RTC_WAKE_W::new(self)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_gpio_wake(&mut self) -> RB_SLP_GPIO_WAKE_W<4> {
                RB_SLP_GPIO_WAKE_W::new(self)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_bat_wake(&mut self) -> RB_SLP_BAT_WAKE_W<5> {
                RB_SLP_BAT_WAKE_W::new(self)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn rb_wake_ev_mode(&mut self) -> RB_WAKE_EV_MODE_W<6> {
                RB_WAKE_EV_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, wake control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_slp_wake_ctrl](index.html) module
        pub struct R8_SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for R8_SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_slp_wake_ctrl::R](R) reader structure
        impl crate::Readable for R8_SLP_WAKE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_slp_wake_ctrl::W](W) writer structure
        impl crate::Writable for R8_SLP_WAKE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SLP_WAKE_CTRL to value 0x20
        impl crate::Resettable for R8_SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///R8_SLP_POWER_CTRL (rw) register accessor: an alias for `Reg<R8_SLP_POWER_CTRL_SPEC>`
    pub type R8_SLP_POWER_CTRL = crate::Reg<r8_slp_power_ctrl::R8_SLP_POWER_CTRL_SPEC>;
    ///RWA, peripherals power down control, SAM
    pub mod r8_slp_power_ctrl {
        ///Register `R8_SLP_POWER_CTRL` reader
        pub struct R(crate::R<R8_SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SLP_POWER_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SLP_POWER_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SLP_POWER_CTRL` writer
        pub struct W(crate::W<R8_SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SLP_POWER_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SLP_POWER_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_WAKE_DLY_MOD` reader - RWA, wakeup delay time selection
        pub type RB_WAKE_DLY_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_WAKE_DLY_MOD` writer - RWA, wakeup delay time selection
        pub type RB_WAKE_DLY_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SLP_POWER_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_SLP_CLK_RAMX` reader - RWA, close main SRAM clock
        pub type RB_SLP_CLK_RAMX_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_RAMX` writer - RWA, close main SRAM clock
        pub type RB_SLP_CLK_RAMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_POWER_CTRL_SPEC, bool, O>;
        ///Field `RB_SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock
        pub type RB_SLP_CLK_RAM2K_R = crate::BitReader<bool>;
        ///Field `RB_SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock
        pub type RB_SLP_CLK_RAM2K_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_POWER_CTRL_SPEC, bool, O>;
        ///Field `RB_RAM_RET_LV` reader - RWA, SRAM retention voltage selection
        pub type RB_RAM_RET_LV_R = crate::BitReader<bool>;
        ///Field `RB_RAM_RET_LV` writer - RWA, SRAM retention voltage selection
        pub type RB_RAM_RET_LV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SLP_POWER_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            pub fn rb_wake_dly_mod(&self) -> RB_WAKE_DLY_MOD_R {
                RB_WAKE_DLY_MOD_R::new(self.bits & 3)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            pub fn rb_slp_clk_ramx(&self) -> RB_SLP_CLK_RAMX_R {
                RB_SLP_CLK_RAMX_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            pub fn rb_slp_clk_ram2k(&self) -> RB_SLP_CLK_RAM2K_R {
                RB_SLP_CLK_RAM2K_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            pub fn rb_ram_ret_lv(&self) -> RB_RAM_RET_LV_R {
                RB_RAM_RET_LV_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            #[must_use]
            pub fn rb_wake_dly_mod(&mut self) -> RB_WAKE_DLY_MOD_W<0> {
                RB_WAKE_DLY_MOD_W::new(self)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_ramx(&mut self) -> RB_SLP_CLK_RAMX_W<4> {
                RB_SLP_CLK_RAMX_W::new(self)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn rb_slp_clk_ram2k(&mut self) -> RB_SLP_CLK_RAM2K_W<5> {
                RB_SLP_CLK_RAM2K_W::new(self)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            #[must_use]
            pub fn rb_ram_ret_lv(&mut self) -> RB_RAM_RET_LV_W<6> {
                RB_RAM_RET_LV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, peripherals power down control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_slp_power_ctrl](index.html) module
        pub struct R8_SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for R8_SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_slp_power_ctrl::R](R) reader structure
        impl crate::Readable for R8_SLP_POWER_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_slp_power_ctrl::W](W) writer structure
        impl crate::Writable for R8_SLP_POWER_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SLP_POWER_CTRL to value 0
        impl crate::Resettable for R8_SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PIN_ALTERNATE (rw) register accessor: an alias for `Reg<R16_PIN_ALTERNATE_SPEC>`
    pub type R16_PIN_ALTERNATE = crate::Reg<r16_pin_alternate::R16_PIN_ALTERNATE_SPEC>;
    ///RW, function pin alternate configuration
    pub mod r16_pin_alternate {
        ///Register `R16_PIN_ALTERNATE` reader
        pub struct R(crate::R<R16_PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PIN_ALTERNATE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PIN_ALTERNATE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PIN_ALTERNATE` writer
        pub struct W(crate::W<R16_PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PIN_ALTERNATE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PIN_ALTERNATE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PIN_TMR0` reader - RW, TMR0 alternate pin enable
        pub type RB_PIN_TMR0_R = crate::BitReader<bool>;
        ///Field `RB_PIN_TMR0` writer - RW, TMR0 alternate pin enable
        pub type RB_PIN_TMR0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_TMR1` reader - RW, TMR1 alternate pin enable
        pub type RB_PIN_TMR1_R = crate::BitReader<bool>;
        ///Field `RB_PIN_TMR1` writer - RW, TMR1 alternate pin enable
        pub type RB_PIN_TMR1_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_TMR2` reader - RW, TMR2 alternate pin enable
        pub type RB_PIN_TMR2_R = crate::BitReader<bool>;
        ///Field `RB_PIN_TMR2` writer - RW, TMR2 alternate pin enable
        pub type RB_PIN_TMR2_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_TMR3` reader - RW, TMR3 alternate pin enable
        pub type RB_PIN_TMR3_R = crate::BitReader<bool>;
        ///Field `RB_PIN_TMR3` writer - RW, TMR3 alternate pin enable
        pub type RB_PIN_TMR3_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable
        pub type RB_PIN_UART0_R = crate::BitReader<bool>;
        ///Field `RB_PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable
        pub type RB_PIN_UART0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable
        pub type RB_PIN_UART1_R = crate::BitReader<bool>;
        ///Field `RB_PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable
        pub type RB_PIN_UART1_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable
        pub type RB_PIN_UART2_R = crate::BitReader<bool>;
        ///Field `RB_PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable
        pub type RB_PIN_UART2_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable
        pub type RB_PIN_UART3_R = crate::BitReader<bool>;
        ///Field `RB_PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable
        pub type RB_PIN_UART3_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type RB_PIN_SPI0_R = crate::BitReader<bool>;
        ///Field `RB_PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type RB_PIN_SPI0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type RB_PIN_PWMX_R = crate::BitReader<bool>;
        ///Field `RB_PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type RB_PIN_PWMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_I2C` reader - RW, SCL/SDA alternate pin enable
        pub type RB_PIN_I2C_R = crate::BitReader<bool>;
        ///Field `RB_PIN_I2C` writer - RW, SCL/SDA alternate pin enable
        pub type RB_PIN_I2C_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_MODEM` reader - RW, DSR/DTR alternate pin enable
        pub type RB_PIN_MODEM_R = crate::BitReader<bool>;
        ///Field `RB_PIN_MODEM` writer - RW, DSR/DTR alternate pin enable
        pub type RB_PIN_MODEM_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_INTX` reader - RW, interrupt INT24/INT25 alternate pin enable
        pub type RB_PIN_INTX_R = crate::BitReader<bool>;
        ///Field `RB_PIN_INTX` writer - RW, interrupt INT24/INT25 alternate pin enable
        pub type RB_PIN_INTX_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_PIN_U0_INV` reader - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type RB_PIN_U0_INV_R = crate::BitReader<bool>;
        ///Field `RB_PIN_U0_INV` writer - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type RB_PIN_U0_INV_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RB_RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable
        pub type RB_RF_ANT_SW_EN_R = crate::BitReader<bool>;
        ///Field `RB_RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable
        pub type RB_RF_ANT_SW_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ALTERNATE_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_tmr0(&self) -> RB_PIN_TMR0_R {
                RB_PIN_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_tmr1(&self) -> RB_PIN_TMR1_R {
                RB_PIN_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_tmr2(&self) -> RB_PIN_TMR2_R {
                RB_PIN_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_tmr3(&self) -> RB_PIN_TMR3_R {
                RB_PIN_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_uart0(&self) -> RB_PIN_UART0_R {
                RB_PIN_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_uart1(&self) -> RB_PIN_UART1_R {
                RB_PIN_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_uart2(&self) -> RB_PIN_UART2_R {
                RB_PIN_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_uart3(&self) -> RB_PIN_UART3_R {
                RB_PIN_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            pub fn rb_pin_spi0(&self) -> RB_PIN_SPI0_R {
                RB_PIN_SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_pwmx(&self) -> RB_PIN_PWMX_R {
                RB_PIN_PWMX_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            pub fn rb_pin_i2c(&self) -> RB_PIN_I2C_R {
                RB_PIN_I2C_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            pub fn rb_pin_modem(&self) -> RB_PIN_MODEM_R {
                RB_PIN_MODEM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            pub fn rb_pin_intx(&self) -> RB_PIN_INTX_R {
                RB_PIN_INTX_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            pub fn rb_pin_u0_inv(&self) -> RB_PIN_U0_INV_R {
                RB_PIN_U0_INV_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            pub fn rb_rf_ant_sw_en(&self) -> RB_RF_ANT_SW_EN_R {
                RB_RF_ANT_SW_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_tmr0(&mut self) -> RB_PIN_TMR0_W<0> {
                RB_PIN_TMR0_W::new(self)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_tmr1(&mut self) -> RB_PIN_TMR1_W<1> {
                RB_PIN_TMR1_W::new(self)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_tmr2(&mut self) -> RB_PIN_TMR2_W<2> {
                RB_PIN_TMR2_W::new(self)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_tmr3(&mut self) -> RB_PIN_TMR3_W<3> {
                RB_PIN_TMR3_W::new(self)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_uart0(&mut self) -> RB_PIN_UART0_W<4> {
                RB_PIN_UART0_W::new(self)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_uart1(&mut self) -> RB_PIN_UART1_W<5> {
                RB_PIN_UART1_W::new(self)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_uart2(&mut self) -> RB_PIN_UART2_W<6> {
                RB_PIN_UART2_W::new(self)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_uart3(&mut self) -> RB_PIN_UART3_W<7> {
                RB_PIN_UART3_W::new(self)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_spi0(&mut self) -> RB_PIN_SPI0_W<8> {
                RB_PIN_SPI0_W::new(self)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_pwmx(&mut self) -> RB_PIN_PWMX_W<10> {
                RB_PIN_PWMX_W::new(self)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_i2c(&mut self) -> RB_PIN_I2C_W<11> {
                RB_PIN_I2C_W::new(self)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_modem(&mut self) -> RB_PIN_MODEM_W<12> {
                RB_PIN_MODEM_W::new(self)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_intx(&mut self) -> RB_PIN_INTX_W<13> {
                RB_PIN_INTX_W::new(self)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_u0_inv(&mut self) -> RB_PIN_U0_INV_W<14> {
                RB_PIN_U0_INV_W::new(self)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_rf_ant_sw_en(&mut self) -> RB_RF_ANT_SW_EN_W<15> {
                RB_RF_ANT_SW_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, function pin alternate configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pin_alternate](index.html) module
        pub struct R16_PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for R16_PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pin_alternate::R](R) reader structure
        impl crate::Readable for R16_PIN_ALTERNATE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pin_alternate::W](W) writer structure
        impl crate::Writable for R16_PIN_ALTERNATE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PIN_ALTERNATE to value 0
        impl crate::Resettable for R16_PIN_ALTERNATE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PIN_ANALOG_IE (rw) register accessor: an alias for `Reg<R16_PIN_ANALOG_IE_SPEC>`
    pub type R16_PIN_ANALOG_IE = crate::Reg<r16_pin_analog_ie::R16_PIN_ANALOG_IE_SPEC>;
    ///RW, analog pin enable and digital input disable
    pub mod r16_pin_analog_ie {
        ///Register `R16_PIN_ANALOG_IE` reader
        pub struct R(crate::R<R16_PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PIN_ANALOG_IE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PIN_ANALOG_IE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PIN_ANALOG_IE` writer
        pub struct W(crate::W<R16_PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PIN_ANALOG_IE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PIN_ANALOG_IE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type RB_PIN_ADC8_9_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type RB_PIN_ADC8_9_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC6_7_IE` reader - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type RB_PIN_ADC6_7_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC6_7_IE` writer - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type RB_PIN_ADC6_7_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC10_IE` reader - RW, ADC/TouchKey channel 10 digital input disable
        pub type RB_PIN_ADC10_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC10_IE` writer - RW, ADC/TouchKey channel 10 digital input disable
        pub type RB_PIN_ADC10_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC11_IE` reader - RW, ADC/TouchKey channel 11 digital input disable
        pub type RB_PIN_ADC11_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC11_IE` writer - RW, ADC/TouchKey channel 11 digital input disable
        pub type RB_PIN_ADC11_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_USB2_DP_PU` reader - RW,USB2 UDP internal pullup resistance enable
        pub type RB_PIN_USB2_DP_PU_R = crate::BitReader<bool>;
        ///Field `RB_PIN_USB2_DP_PU` writer - RW,USB2 UDP internal pullup resistance enable
        pub type RB_PIN_USB2_DP_PU_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_USB2_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type RB_PIN_USB2_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_USB2_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type RB_PIN_USB2_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable
        pub type RB_PIN_USB_DP_PU_R = crate::BitReader<bool>;
        ///Field `RB_PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable
        pub type RB_PIN_USB_DP_PU_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type RB_PIN_USB_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type RB_PIN_USB_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC0_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC0_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC1_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC1_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC12_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC12_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC13_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC13_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_XT32K_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_XT32K_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC2_3_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC2_3_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `RB_PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC4_5_IE_R = crate::BitReader<bool>;
        ///Field `RB_PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type RB_PIN_ADC4_5_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_PIN_ANALOG_IE_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            pub fn rb_pin_adc8_9_ie(&self) -> RB_PIN_ADC8_9_IE_R {
                RB_PIN_ADC8_9_IE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            pub fn rb_pin_adc6_7_ie(&self) -> RB_PIN_ADC6_7_IE_R {
                RB_PIN_ADC6_7_IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            pub fn rb_pin_adc10_ie(&self) -> RB_PIN_ADC10_IE_R {
                RB_PIN_ADC10_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            pub fn rb_pin_adc11_ie(&self) -> RB_PIN_ADC11_IE_R {
                RB_PIN_ADC11_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            pub fn rb_pin_usb2_dp_pu(&self) -> RB_PIN_USB2_DP_PU_R {
                RB_PIN_USB2_DP_PU_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn rb_pin_usb2_ie(&self) -> RB_PIN_USB2_IE_R {
                RB_PIN_USB2_IE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            pub fn rb_pin_usb_dp_pu(&self) -> RB_PIN_USB_DP_PU_R {
                RB_PIN_USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn rb_pin_usb_ie(&self) -> RB_PIN_USB_IE_R {
                RB_PIN_USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc0_ie(&self) -> RB_PIN_ADC0_IE_R {
                RB_PIN_ADC0_IE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc1_ie(&self) -> RB_PIN_ADC1_IE_R {
                RB_PIN_ADC1_IE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc12_ie(&self) -> RB_PIN_ADC12_IE_R {
                RB_PIN_ADC12_IE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc13_ie(&self) -> RB_PIN_ADC13_IE_R {
                RB_PIN_ADC13_IE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_xt32k_ie(&self) -> RB_PIN_XT32K_IE_R {
                RB_PIN_XT32K_IE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc2_3_ie(&self) -> RB_PIN_ADC2_3_IE_R {
                RB_PIN_ADC2_3_IE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn rb_pin_adc4_5_ie(&self) -> RB_PIN_ADC4_5_IE_R {
                RB_PIN_ADC4_5_IE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc8_9_ie(&mut self) -> RB_PIN_ADC8_9_IE_W<0> {
                RB_PIN_ADC8_9_IE_W::new(self)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc6_7_ie(&mut self) -> RB_PIN_ADC6_7_IE_W<1> {
                RB_PIN_ADC6_7_IE_W::new(self)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc10_ie(&mut self) -> RB_PIN_ADC10_IE_W<2> {
                RB_PIN_ADC10_IE_W::new(self)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc11_ie(&mut self) -> RB_PIN_ADC11_IE_W<3> {
                RB_PIN_ADC11_IE_W::new(self)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_usb2_dp_pu(&mut self) -> RB_PIN_USB2_DP_PU_W<4> {
                RB_PIN_USB2_DP_PU_W::new(self)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_usb2_ie(&mut self) -> RB_PIN_USB2_IE_W<5> {
                RB_PIN_USB2_IE_W::new(self)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_usb_dp_pu(&mut self) -> RB_PIN_USB_DP_PU_W<6> {
                RB_PIN_USB_DP_PU_W::new(self)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_usb_ie(&mut self) -> RB_PIN_USB_IE_W<7> {
                RB_PIN_USB_IE_W::new(self)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc0_ie(&mut self) -> RB_PIN_ADC0_IE_W<9> {
                RB_PIN_ADC0_IE_W::new(self)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc1_ie(&mut self) -> RB_PIN_ADC1_IE_W<10> {
                RB_PIN_ADC1_IE_W::new(self)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc12_ie(&mut self) -> RB_PIN_ADC12_IE_W<11> {
                RB_PIN_ADC12_IE_W::new(self)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc13_ie(&mut self) -> RB_PIN_ADC13_IE_W<12> {
                RB_PIN_ADC13_IE_W::new(self)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_xt32k_ie(&mut self) -> RB_PIN_XT32K_IE_W<13> {
                RB_PIN_XT32K_IE_W::new(self)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc2_3_ie(&mut self) -> RB_PIN_ADC2_3_IE_W<14> {
                RB_PIN_ADC2_3_IE_W::new(self)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn rb_pin_adc4_5_ie(&mut self) -> RB_PIN_ADC4_5_IE_W<15> {
                RB_PIN_ADC4_5_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, analog pin enable and digital input disable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pin_analog_ie](index.html) module
        pub struct R16_PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for R16_PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pin_analog_ie::R](R) reader structure
        impl crate::Readable for R16_PIN_ANALOG_IE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pin_analog_ie::W](W) writer structure
        impl crate::Writable for R16_PIN_ANALOG_IE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PIN_ANALOG_IE to value 0
        impl crate::Resettable for R16_PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_POWER_PLAN (rw) register accessor: an alias for `Reg<R16_POWER_PLAN_SPEC>`
    pub type R16_POWER_PLAN = crate::Reg<r16_power_plan::R16_POWER_PLAN_SPEC>;
    ///RWA, power plan before sleep instruction, SAM
    pub mod r16_power_plan {
        ///Register `R16_POWER_PLAN` reader
        pub struct R(crate::R<R16_POWER_PLAN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_POWER_PLAN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_POWER_PLAN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_POWER_PLAN` writer
        pub struct W(crate::W<R16_POWER_PLAN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_POWER_PLAN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_POWER_PLAN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PWR_XROM` reader - RWA, power for retention 2KB SRAM
        pub type RB_PWR_XROM_R = crate::BitReader<bool>;
        ///Field `RB_PWR_XROM` writer - RWA, power for retention 2KB SRAM
        pub type RB_PWR_XROM_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_RAM2K` reader - RWA, power for retention 2KB SRAM
        pub type RB_PWR_RAM2K_R = crate::BitReader<bool>;
        ///Field `RB_PWR_RAM2K` writer - RWA, power for retention 2KB SRAM
        pub type RB_PWR_RAM2K_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_CORE` reader - RWA, power retention for core and base peripherals
        pub type RB_PWR_CORE_R = crate::BitReader<bool>;
        ///Field `RB_PWR_CORE` writer - RWA, power retention for core and base peripherals
        pub type RB_PWR_CORE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_EXTEND` reader - RWA, power retention for USB and BLE
        pub type RB_PWR_EXTEND_R = crate::BitReader<bool>;
        ///Field `RB_PWR_EXTEND` writer - RWA, power retention for USB and BLE
        pub type RB_PWR_EXTEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_RAM30K` reader - RWA, power for main SRAM
        pub type RB_PWR_RAM30K_R = crate::BitReader<bool>;
        ///Field `RB_PWR_RAM30K` writer - RWA, power for main SRAM
        pub type RB_PWR_RAM30K_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_SYS_EN` reader - RWA, power for system
        pub type RB_PWR_SYS_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWR_SYS_EN` writer - RWA, power for system
        pub type RB_PWR_SYS_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type RB_PWR_DCDC_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type RB_PWR_DCDC_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable
        pub type RB_PWR_DCDC_PRE_R = crate::BitReader<bool>;
        ///Field `RB_PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable
        pub type RB_PWR_DCDC_PRE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_POWER_PLAN_SPEC, bool, O>;
        ///Field `RB_PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed
        pub type RB_PWR_MUST_0010_R = crate::FieldReader<u8, u8>;
        ///Field `RB_PWR_PLAN_EN` reader - RWA, must write 0010
        pub type RB_PWR_PLAN_EN_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn rb_pwr_xrom(&self) -> RB_PWR_XROM_R {
                RB_PWR_XROM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn rb_pwr_ram2k(&self) -> RB_PWR_RAM2K_R {
                RB_PWR_RAM2K_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            pub fn rb_pwr_core(&self) -> RB_PWR_CORE_R {
                RB_PWR_CORE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            pub fn rb_pwr_extend(&self) -> RB_PWR_EXTEND_R {
                RB_PWR_EXTEND_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            pub fn rb_pwr_ram30k(&self) -> RB_PWR_RAM30K_R {
                RB_PWR_RAM30K_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            pub fn rb_pwr_sys_en(&self) -> RB_PWR_SYS_EN_R {
                RB_PWR_SYS_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            pub fn rb_pwr_dcdc_en(&self) -> RB_PWR_DCDC_EN_R {
                RB_PWR_DCDC_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            pub fn rb_pwr_dcdc_pre(&self) -> RB_PWR_DCDC_PRE_R {
                RB_PWR_DCDC_PRE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bits 11:14 - RWA, power plan enable, auto clear after sleep executed
            #[inline(always)]
            pub fn rb_pwr_must_0010(&self) -> RB_PWR_MUST_0010_R {
                RB_PWR_MUST_0010_R::new(((self.bits >> 11) & 0x0f) as u8)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            pub fn rb_pwr_plan_en(&self) -> RB_PWR_PLAN_EN_R {
                RB_PWR_PLAN_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_xrom(&mut self) -> RB_PWR_XROM_W<0> {
                RB_PWR_XROM_W::new(self)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_ram2k(&mut self) -> RB_PWR_RAM2K_W<1> {
                RB_PWR_RAM2K_W::new(self)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_core(&mut self) -> RB_PWR_CORE_W<2> {
                RB_PWR_CORE_W::new(self)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_extend(&mut self) -> RB_PWR_EXTEND_W<3> {
                RB_PWR_EXTEND_W::new(self)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_ram30k(&mut self) -> RB_PWR_RAM30K_W<4> {
                RB_PWR_RAM30K_W::new(self)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_sys_en(&mut self) -> RB_PWR_SYS_EN_W<7> {
                RB_PWR_SYS_EN_W::new(self)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_dcdc_en(&mut self) -> RB_PWR_DCDC_EN_W<9> {
                RB_PWR_DCDC_EN_W::new(self)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwr_dcdc_pre(&mut self) -> RB_PWR_DCDC_PRE_W<10> {
                RB_PWR_DCDC_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, power plan before sleep instruction, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_power_plan](index.html) module
        pub struct R16_POWER_PLAN_SPEC;
        impl crate::RegisterSpec for R16_POWER_PLAN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_power_plan::R](R) reader structure
        impl crate::Readable for R16_POWER_PLAN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_power_plan::W](W) writer structure
        impl crate::Writable for R16_POWER_PLAN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_POWER_PLAN to value 0x11df
        impl crate::Resettable for R16_POWER_PLAN_SPEC {
            const RESET_VALUE: Self::Ux = 0x11df;
        }
    }
    ///R8_AUX_POWER_ADJ (rw) register accessor: an alias for `Reg<R8_AUX_POWER_ADJ_SPEC>`
    pub type R8_AUX_POWER_ADJ = crate::Reg<r8_aux_power_adj::R8_AUX_POWER_ADJ_SPEC>;
    ///RWA, aux power adjust control, SAM
    pub mod r8_aux_power_adj {
        ///Register `R8_AUX_POWER_ADJ` reader
        pub struct R(crate::R<R8_AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_AUX_POWER_ADJ_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_AUX_POWER_ADJ_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_AUX_POWER_ADJ` writer
        pub struct W(crate::W<R8_AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_AUX_POWER_ADJ_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_AUX_POWER_ADJ_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type RB_ULPLDO_ADJ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type RB_ULPLDO_ADJ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_AUX_POWER_ADJ_SPEC, u8, u8, 3, O>;
        ///Field `RB_DCDC_CHARGE` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type RB_DCDC_CHARGE_R = crate::BitReader<bool>;
        ///Field `RB_DCDC_CHARGE` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type RB_DCDC_CHARGE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_AUX_POWER_ADJ_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn rb_ulpldo_adj(&self) -> RB_ULPLDO_ADJ_R {
                RB_ULPLDO_ADJ_R::new(self.bits & 7)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn rb_dcdc_charge(&self) -> RB_DCDC_CHARGE_R {
                RB_DCDC_CHARGE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn rb_ulpldo_adj(&mut self) -> RB_ULPLDO_ADJ_W<0> {
                RB_ULPLDO_ADJ_W::new(self)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn rb_dcdc_charge(&mut self) -> RB_DCDC_CHARGE_W<7> {
                RB_DCDC_CHARGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, aux power adjust control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_aux_power_adj](index.html) module
        pub struct R8_AUX_POWER_ADJ_SPEC;
        impl crate::RegisterSpec for R8_AUX_POWER_ADJ_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_aux_power_adj::R](R) reader structure
        impl crate::Readable for R8_AUX_POWER_ADJ_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_aux_power_adj::W](W) writer structure
        impl crate::Writable for R8_AUX_POWER_ADJ_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_AUX_POWER_ADJ to value 0
        impl crate::Resettable for R8_AUX_POWER_ADJ_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_BAT_DET_CTRL (rw) register accessor: an alias for `Reg<R8_BAT_DET_CTRL_SPEC>`
    pub type R8_BAT_DET_CTRL = crate::Reg<r8_bat_det_ctrl::R8_BAT_DET_CTRL_SPEC>;
    ///RWA, battery voltage detector control, SAM
    pub mod r8_bat_det_ctrl {
        ///Register `R8_BAT_DET_CTRL` reader
        pub struct R(crate::R<R8_BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_BAT_DET_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_BAT_DET_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_BAT_DET_CTRL` writer
        pub struct W(crate::W<R8_BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_BAT_DET_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_BAT_DET_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_BAT_DET_EN__RB_BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type RB_BAT_DET_EN__RB_BAT_LOW_VTHX_R = crate::BitReader<bool>;
        ///Field `RB_BAT_DET_EN__RB_BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type RB_BAT_DET_EN__RB_BAT_LOW_VTHX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `RB_BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode
        pub type RB_BAT_MON_EN_R = crate::BitReader<bool>;
        ///Field `RB_BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode
        pub type RB_BAT_MON_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `RB_BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage
        pub type RB_BAT_LOWER_IE_R = crate::BitReader<bool>;
        ///Field `RB_BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage
        pub type RB_BAT_LOWER_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `RB_BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage
        pub type RB_BAT_LOW_IE_R = crate::BitReader<bool>;
        ///Field `RB_BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage
        pub type RB_BAT_LOW_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_BAT_DET_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            pub fn rb_bat_det_en__rb_bat_low_vthx(&self) -> RB_BAT_DET_EN__RB_BAT_LOW_VTHX_R {
                RB_BAT_DET_EN__RB_BAT_LOW_VTHX_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            pub fn rb_bat_mon_en(&self) -> RB_BAT_MON_EN_R {
                RB_BAT_MON_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            pub fn rb_bat_lower_ie(&self) -> RB_BAT_LOWER_IE_R {
                RB_BAT_LOWER_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            pub fn rb_bat_low_ie(&self) -> RB_BAT_LOW_IE_R {
                RB_BAT_LOW_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            #[must_use]
            pub fn rb_bat_det_en__rb_bat_low_vthx(
                &mut self,
            ) -> RB_BAT_DET_EN__RB_BAT_LOW_VTHX_W<0> {
                RB_BAT_DET_EN__RB_BAT_LOW_VTHX_W::new(self)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            #[must_use]
            pub fn rb_bat_mon_en(&mut self) -> RB_BAT_MON_EN_W<1> {
                RB_BAT_MON_EN_W::new(self)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            #[must_use]
            pub fn rb_bat_lower_ie(&mut self) -> RB_BAT_LOWER_IE_W<2> {
                RB_BAT_LOWER_IE_W::new(self)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            #[must_use]
            pub fn rb_bat_low_ie(&mut self) -> RB_BAT_LOW_IE_W<3> {
                RB_BAT_LOW_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_bat_det_ctrl](index.html) module
        pub struct R8_BAT_DET_CTRL_SPEC;
        impl crate::RegisterSpec for R8_BAT_DET_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_bat_det_ctrl::R](R) reader structure
        impl crate::Readable for R8_BAT_DET_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_bat_det_ctrl::W](W) writer structure
        impl crate::Writable for R8_BAT_DET_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_BAT_DET_CTRL to value 0
        impl crate::Resettable for R8_BAT_DET_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_BAT_DET_CFG (rw) register accessor: an alias for `Reg<R8_BAT_DET_CFG_SPEC>`
    pub type R8_BAT_DET_CFG = crate::Reg<r8_bat_det_cfg::R8_BAT_DET_CFG_SPEC>;
    ///RWA, battery voltage detector configuration, SAM
    pub mod r8_bat_det_cfg {
        ///Register `R8_BAT_DET_CFG` reader
        pub struct R(crate::R<R8_BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_BAT_DET_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_BAT_DET_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_BAT_DET_CFG` writer
        pub struct W(crate::W<R8_BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_BAT_DET_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_BAT_DET_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low
        pub type RB_BAT_LOW_VTH_R = crate::FieldReader<u8, u8>;
        ///Field `RB_BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low
        pub type RB_BAT_LOW_VTH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_BAT_DET_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            pub fn rb_bat_low_vth(&self) -> RB_BAT_LOW_VTH_R {
                RB_BAT_LOW_VTH_R::new(self.bits & 3)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            #[must_use]
            pub fn rb_bat_low_vth(&mut self) -> RB_BAT_LOW_VTH_W<0> {
                RB_BAT_LOW_VTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_bat_det_cfg](index.html) module
        pub struct R8_BAT_DET_CFG_SPEC;
        impl crate::RegisterSpec for R8_BAT_DET_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_bat_det_cfg::R](R) reader structure
        impl crate::Readable for R8_BAT_DET_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_bat_det_cfg::W](W) writer structure
        impl crate::Writable for R8_BAT_DET_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_BAT_DET_CFG to value 0x01
        impl crate::Resettable for R8_BAT_DET_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_BAT_STATUS (r) register accessor: an alias for `Reg<R8_BAT_STATUS_SPEC>`
    pub type R8_BAT_STATUS = crate::Reg<r8_bat_status::R8_BAT_STATUS_SPEC>;
    ///RO, battery status
    pub mod r8_bat_status {
        ///Register `R8_BAT_STATUS` reader
        pub struct R(crate::R<R8_BAT_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_BAT_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_BAT_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_BAT_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action
        pub type RB_BAT_STAT_LOWER_R = crate::BitReader<bool>;
        ///Field `RB_BAT_STAT_LOW` reader - RO, battery low voltage status, high action
        pub type RB_BAT_STAT_LOW_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, battery lower voltage status, high action
            #[inline(always)]
            pub fn rb_bat_stat_lower(&self) -> RB_BAT_STAT_LOWER_R {
                RB_BAT_STAT_LOWER_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, battery low voltage status, high action
            #[inline(always)]
            pub fn rb_bat_stat_low(&self) -> RB_BAT_STAT_LOW_R {
                RB_BAT_STAT_LOW_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///RO, battery status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_bat_status](index.html) module
        pub struct R8_BAT_STATUS_SPEC;
        impl crate::RegisterSpec for R8_BAT_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_bat_status::R](R) reader structure
        impl crate::Readable for R8_BAT_STATUS_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_BAT_STATUS to value 0
        impl crate::Resettable for R8_BAT_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_INT32K_TUNE (rw) register accessor: an alias for `Reg<R16_INT32K_TUNE_SPEC>`
    pub type R16_INT32K_TUNE = crate::Reg<r16_int32k_tune::R16_INT32K_TUNE_SPEC>;
    ///RWA, internal 32KHz oscillator tune control, SAM
    pub mod r16_int32k_tune {
        ///Register `R16_INT32K_TUNE` reader
        pub struct R(crate::R<R16_INT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_INT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_INT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_INT32K_TUNE` writer
        pub struct W(crate::W<R16_INT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_INT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_INT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune
        pub type RB_INT32K_TUNE_R = crate::FieldReader<u16, u16>;
        ///Field `RB_INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune
        pub type RB_INT32K_TUNE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_INT32K_TUNE_SPEC, u16, u16, 13, O>;
        impl R {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            pub fn rb_int32k_tune(&self) -> RB_INT32K_TUNE_R {
                RB_INT32K_TUNE_R::new(self.bits & 0x1fff)
            }
        }
        impl W {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            #[must_use]
            pub fn rb_int32k_tune(&mut self) -> RB_INT32K_TUNE_W<0> {
                RB_INT32K_TUNE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, internal 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_int32k_tune](index.html) module
        pub struct R16_INT32K_TUNE_SPEC;
        impl crate::RegisterSpec for R16_INT32K_TUNE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_int32k_tune::R](R) reader structure
        impl crate::Readable for R16_INT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_int32k_tune::W](W) writer structure
        impl crate::Writable for R16_INT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_INT32K_TUNE to value 0x1011
        impl crate::Resettable for R16_INT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x1011;
        }
    }
    ///R8_XT32K_TUNE (rw) register accessor: an alias for `Reg<R8_XT32K_TUNE_SPEC>`
    pub type R8_XT32K_TUNE = crate::Reg<r8_xt32k_tune::R8_XT32K_TUNE_SPEC>;
    ///RWA, external 32KHz oscillator tune control, SAM
    pub mod r8_xt32k_tune {
        ///Register `R8_XT32K_TUNE` reader
        pub struct R(crate::R<R8_XT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_XT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_XT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_XT32K_TUNE` writer
        pub struct W(crate::W<R8_XT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_XT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_XT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type RB_XT32K_I_TUNE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type RB_XT32K_I_TUNE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_XT32K_TUNE_SPEC, u8, u8, 2, O>;
        ///Field `RB_XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type RB_XT32K_C_LOAD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type RB_XT32K_C_LOAD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_XT32K_TUNE_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            pub fn rb_xt32k_i_tune(&self) -> RB_XT32K_I_TUNE_R {
                RB_XT32K_I_TUNE_R::new(self.bits & 3)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            pub fn rb_xt32k_c_load(&self) -> RB_XT32K_C_LOAD_R {
                RB_XT32K_C_LOAD_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            #[must_use]
            pub fn rb_xt32k_i_tune(&mut self) -> RB_XT32K_I_TUNE_W<0> {
                RB_XT32K_I_TUNE_W::new(self)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            #[must_use]
            pub fn rb_xt32k_c_load(&mut self) -> RB_XT32K_C_LOAD_W<4> {
                RB_XT32K_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, external 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_xt32k_tune](index.html) module
        pub struct R8_XT32K_TUNE_SPEC;
        impl crate::RegisterSpec for R8_XT32K_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_xt32k_tune::R](R) reader structure
        impl crate::Readable for R8_XT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_xt32k_tune::W](W) writer structure
        impl crate::Writable for R8_XT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_XT32K_TUNE to value 0xc3
        impl crate::Resettable for R8_XT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0xc3;
        }
    }
    ///R8_CK32K_CONFIG (rw) register accessor: an alias for `Reg<R8_CK32K_CONFIG_SPEC>`
    pub type R8_CK32K_CONFIG = crate::Reg<r8_ck32k_config::R8_CK32K_CONFIG_SPEC>;
    ///RWA, 32KHz oscillator configure
    pub mod r8_ck32k_config {
        ///Register `R8_CK32K_CONFIG` reader
        pub struct R(crate::R<R8_CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_CK32K_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_CK32K_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_CK32K_CONFIG` writer
        pub struct W(crate::W<R8_CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_CK32K_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_CK32K_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on
        pub type RB_CLK_XT32K_PON_R = crate::BitReader<bool>;
        ///Field `RB_CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on
        pub type RB_CLK_XT32K_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_CK32K_CONFIG_SPEC, bool, O>;
        ///Field `RB_CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on
        pub type RB_CLK_INT32K_PON_R = crate::BitReader<bool>;
        ///Field `RB_CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on
        pub type RB_CLK_INT32K_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_CK32K_CONFIG_SPEC, bool, O>;
        ///Field `RB_CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type RB_CLK_OSC32K_XT_R = crate::BitReader<bool>;
        ///Field `RB_CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type RB_CLK_OSC32K_XT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_CK32K_CONFIG_SPEC, bool, O>;
        ///Field `RB_CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable
        pub type RB_CLK_OSC32K_FILT_R = crate::BitReader<bool>;
        ///Field `RB_CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable
        pub type RB_CLK_OSC32K_FILT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_CK32K_CONFIG_SPEC, bool, O>;
        ///Field `RB_32K_CLK_PIN` reader - RO, 32KHz oscillator clock pin status
        pub type RB_32K_CLK_PIN_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            pub fn rb_clk_xt32k_pon(&self) -> RB_CLK_XT32K_PON_R {
                RB_CLK_XT32K_PON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            pub fn rb_clk_int32k_pon(&self) -> RB_CLK_INT32K_PON_R {
                RB_CLK_INT32K_PON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            pub fn rb_clk_osc32k_xt(&self) -> RB_CLK_OSC32K_XT_R {
                RB_CLK_OSC32K_XT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            pub fn rb_clk_osc32k_filt(&self) -> RB_CLK_OSC32K_FILT_R {
                RB_CLK_OSC32K_FILT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            pub fn rb_32k_clk_pin(&self) -> RB_32K_CLK_PIN_R {
                RB_32K_CLK_PIN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_xt32k_pon(&mut self) -> RB_CLK_XT32K_PON_W<0> {
                RB_CLK_XT32K_PON_W::new(self)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_int32k_pon(&mut self) -> RB_CLK_INT32K_PON_W<1> {
                RB_CLK_INT32K_PON_W::new(self)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_osc32k_xt(&mut self) -> RB_CLK_OSC32K_XT_W<2> {
                RB_CLK_OSC32K_XT_W::new(self)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            #[must_use]
            pub fn rb_clk_osc32k_filt(&mut self) -> RB_CLK_OSC32K_FILT_W<3> {
                RB_CLK_OSC32K_FILT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, 32KHz oscillator configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_ck32k_config](index.html) module
        pub struct R8_CK32K_CONFIG_SPEC;
        impl crate::RegisterSpec for R8_CK32K_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_ck32k_config::R](R) reader structure
        impl crate::Readable for R8_CK32K_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_ck32k_config::W](W) writer structure
        impl crate::Writable for R8_CK32K_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_CK32K_CONFIG to value 0x02
        impl crate::Resettable for R8_CK32K_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_RTC_FLAG_CTRL (rw) register accessor: an alias for `Reg<R8_RTC_FLAG_CTRL_SPEC>`
    pub type R8_RTC_FLAG_CTRL = crate::Reg<r8_rtc_flag_ctrl::R8_RTC_FLAG_CTRL_SPEC>;
    ///RW, RTC flag and clear control
    pub mod r8_rtc_flag_ctrl {
        ///Register `R8_RTC_FLAG_CTRL` reader
        pub struct R(crate::R<R8_RTC_FLAG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_RTC_FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_RTC_FLAG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_RTC_FLAG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_RTC_FLAG_CTRL` writer
        pub struct W(crate::W<R8_RTC_FLAG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_RTC_FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_RTC_FLAG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_RTC_FLAG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RB_RTC_TMR_CLR_R = crate::BitReader<bool>;
        ///Field `RB_RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RB_RTC_TMR_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_FLAG_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RB_RTC_TRIG_CLR_R = crate::BitReader<bool>;
        ///Field `RB_RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RB_RTC_TRIG_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_FLAG_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_TMR_FLAG` reader - RO, RTC timer action flag
        pub type RB_RTC_TMR_FLAG_R = crate::BitReader<bool>;
        ///Field `RB_RTC_TRIG_FLAG` reader - RO, RTC trigger action flag
        pub type RB_RTC_TRIG_FLAG_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            pub fn rb_rtc_tmr_clr(&self) -> RB_RTC_TMR_CLR_R {
                RB_RTC_TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            pub fn rb_rtc_trig_clr(&self) -> RB_RTC_TRIG_CLR_R {
                RB_RTC_TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, RTC timer action flag
            #[inline(always)]
            pub fn rb_rtc_tmr_flag(&self) -> RB_RTC_TMR_FLAG_R {
                RB_RTC_TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, RTC trigger action flag
            #[inline(always)]
            pub fn rb_rtc_trig_flag(&self) -> RB_RTC_TRIG_FLAG_R {
                RB_RTC_TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_tmr_clr(&mut self) -> RB_RTC_TMR_CLR_W<4> {
                RB_RTC_TMR_CLR_W::new(self)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_trig_clr(&mut self) -> RB_RTC_TRIG_CLR_W<5> {
                RB_RTC_TRIG_CLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, RTC flag and clear control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_rtc_flag_ctrl](index.html) module
        pub struct R8_RTC_FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for R8_RTC_FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_rtc_flag_ctrl::R](R) reader structure
        impl crate::Readable for R8_RTC_FLAG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_rtc_flag_ctrl::W](W) writer structure
        impl crate::Writable for R8_RTC_FLAG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_RTC_FLAG_CTRL to value 0x30
        impl crate::Resettable for R8_RTC_FLAG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x30;
        }
    }
    ///R8_RTC_MODE_CTRL (rw) register accessor: an alias for `Reg<R8_RTC_MODE_CTRL_SPEC>`
    pub type R8_RTC_MODE_CTRL = crate::Reg<r8_rtc_mode_ctrl::R8_RTC_MODE_CTRL_SPEC>;
    ///RWA, RTC mode control, SAM
    pub mod r8_rtc_mode_ctrl {
        ///Register `R8_RTC_MODE_CTRL` reader
        pub struct R(crate::R<R8_RTC_MODE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_RTC_MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_RTC_MODE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_RTC_MODE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_RTC_MODE_CTRL` writer
        pub struct W(crate::W<R8_RTC_MODE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_RTC_MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_RTC_MODE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_RTC_MODE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RB_RTC_TMR_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RB_RTC_TMR_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, u8, u8, 3, O>;
        ///Field `RB_RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RB_RTC_IGNORE_B0_R = crate::BitReader<bool>;
        ///Field `RB_RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RB_RTC_IGNORE_B0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_TMR_EN` reader - RWA, RTC timer mode enable
        pub type RB_RTC_TMR_EN_R = crate::BitReader<bool>;
        ///Field `RB_RTC_TMR_EN` writer - RWA, RTC timer mode enable
        pub type RB_RTC_TMR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_TRIG_EN` reader - RWA, RTC trigger mode enable
        pub type RB_RTC_TRIG_EN_R = crate::BitReader<bool>;
        ///Field `RB_RTC_TRIG_EN` writer - RWA, RTC trigger mode enable
        pub type RB_RTC_TRIG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RB_RTC_LOAD_LO_R = crate::BitReader<bool>;
        ///Field `RB_RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RB_RTC_LOAD_LO_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RB_RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RB_RTC_LOAD_HI_R = crate::BitReader<bool>;
        ///Field `RB_RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RB_RTC_LOAD_HI_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RTC_MODE_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            pub fn rb_rtc_tmr_mode(&self) -> RB_RTC_TMR_MODE_R {
                RB_RTC_TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            pub fn rb_rtc_ignore_b0(&self) -> RB_RTC_IGNORE_B0_R {
                RB_RTC_IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            pub fn rb_rtc_tmr_en(&self) -> RB_RTC_TMR_EN_R {
                RB_RTC_TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            pub fn rb_rtc_trig_en(&self) -> RB_RTC_TRIG_EN_R {
                RB_RTC_TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            pub fn rb_rtc_load_lo(&self) -> RB_RTC_LOAD_LO_R {
                RB_RTC_LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            pub fn rb_rtc_load_hi(&self) -> RB_RTC_LOAD_HI_R {
                RB_RTC_LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_tmr_mode(&mut self) -> RB_RTC_TMR_MODE_W<0> {
                RB_RTC_TMR_MODE_W::new(self)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_ignore_b0(&mut self) -> RB_RTC_IGNORE_B0_W<3> {
                RB_RTC_IGNORE_B0_W::new(self)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_tmr_en(&mut self) -> RB_RTC_TMR_EN_W<4> {
                RB_RTC_TMR_EN_W::new(self)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_trig_en(&mut self) -> RB_RTC_TRIG_EN_W<5> {
                RB_RTC_TRIG_EN_W::new(self)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_load_lo(&mut self) -> RB_RTC_LOAD_LO_W<6> {
                RB_RTC_LOAD_LO_W::new(self)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rb_rtc_load_hi(&mut self) -> RB_RTC_LOAD_HI_W<7> {
                RB_RTC_LOAD_HI_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC mode control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_rtc_mode_ctrl](index.html) module
        pub struct R8_RTC_MODE_CTRL_SPEC;
        impl crate::RegisterSpec for R8_RTC_MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_rtc_mode_ctrl::R](R) reader structure
        impl crate::Readable for R8_RTC_MODE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_rtc_mode_ctrl::W](W) writer structure
        impl crate::Writable for R8_RTC_MODE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_RTC_MODE_CTRL to value 0x02
        impl crate::Resettable for R8_RTC_MODE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R32_RTC_TRIG (rw) register accessor: an alias for `Reg<R32_RTC_TRIG_SPEC>`
    pub type R32_RTC_TRIG = crate::Reg<r32_rtc_trig::R32_RTC_TRIG_SPEC>;
    ///RWA, RTC trigger value, SAM
    pub mod r32_rtc_trig {
        ///Register `R32_RTC_TRIG` reader
        pub struct R(crate::R<R32_RTC_TRIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_RTC_TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_RTC_TRIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_RTC_TRIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_RTC_TRIG` writer
        pub struct W(crate::W<R32_RTC_TRIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_RTC_TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_RTC_TRIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_RTC_TRIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_RTC_TRIG` reader - RWA, RTC trigger value
        pub type R32_RTC_TRIG_R = crate::FieldReader<u32, u32>;
        ///Field `R32_RTC_TRIG` writer - RWA, RTC trigger value
        pub type R32_RTC_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_RTC_TRIG_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            pub fn r32_rtc_trig(&self) -> R32_RTC_TRIG_R {
                R32_RTC_TRIG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            #[must_use]
            pub fn r32_rtc_trig(&mut self) -> R32_RTC_TRIG_W<0> {
                R32_RTC_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC trigger value, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_rtc_trig](index.html) module
        pub struct R32_RTC_TRIG_SPEC;
        impl crate::RegisterSpec for R32_RTC_TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_rtc_trig::R](R) reader structure
        impl crate::Readable for R32_RTC_TRIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_rtc_trig::W](W) writer structure
        impl crate::Writable for R32_RTC_TRIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_RTC_TRIG to value 0
        impl crate::Resettable for R32_RTC_TRIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_RTC_CNT_32K (r) register accessor: an alias for `Reg<R16_RTC_CNT_32K_SPEC>`
    pub type R16_RTC_CNT_32K = crate::Reg<r16_rtc_cnt_32k::R16_RTC_CNT_32K_SPEC>;
    ///RO, RTC count based 32KHz
    pub mod r16_rtc_cnt_32k {
        ///Register `R16_RTC_CNT_32K` reader
        pub struct R(crate::R<R16_RTC_CNT_32K_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_RTC_CNT_32K_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_RTC_CNT_32K_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_RTC_CNT_32K_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R16_RTC_CNT_32K` reader - RWA,RTC count based 32KHz
        pub type R16_RTC_CNT_32K_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RWA,RTC count based 32KHz
            #[inline(always)]
            pub fn r16_rtc_cnt_32k(&self) -> R16_RTC_CNT_32K_R {
                R16_RTC_CNT_32K_R::new(self.bits)
            }
        }
        ///RO, RTC count based 32KHz
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_rtc_cnt_32k](index.html) module
        pub struct R16_RTC_CNT_32K_SPEC;
        impl crate::RegisterSpec for R16_RTC_CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_rtc_cnt_32k::R](R) reader structure
        impl crate::Readable for R16_RTC_CNT_32K_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_RTC_CNT_32K to value 0
        impl crate::Resettable for R16_RTC_CNT_32K_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_RTC_CNT_2S (r) register accessor: an alias for `Reg<R16_RTC_CNT_2S_SPEC>`
    pub type R16_RTC_CNT_2S = crate::Reg<r16_rtc_cnt_2s::R16_RTC_CNT_2S_SPEC>;
    ///RO, RTC count based 2 second
    pub mod r16_rtc_cnt_2s {
        ///Register `R16_RTC_CNT_2S` reader
        pub struct R(crate::R<R16_RTC_CNT_2S_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_RTC_CNT_2S_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_RTC_CNT_2S_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_RTC_CNT_2S_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R16_RTC_CNT_2S` reader - RO, RTC count based 2 second
        pub type R16_RTC_CNT_2S_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RO, RTC count based 2 second
            #[inline(always)]
            pub fn r16_rtc_cnt_2s(&self) -> R16_RTC_CNT_2S_R {
                R16_RTC_CNT_2S_R::new(self.bits)
            }
        }
        ///RO, RTC count based 2 second
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_rtc_cnt_2s](index.html) module
        pub struct R16_RTC_CNT_2S_SPEC;
        impl crate::RegisterSpec for R16_RTC_CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_rtc_cnt_2s::R](R) reader structure
        impl crate::Readable for R16_RTC_CNT_2S_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_RTC_CNT_2S to value 0
        impl crate::Resettable for R16_RTC_CNT_2S_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_RTC_CNT_DAY (r) register accessor: an alias for `Reg<R32_RTC_CNT_DAY_SPEC>`
    pub type R32_RTC_CNT_DAY = crate::Reg<r32_rtc_cnt_day::R32_RTC_CNT_DAY_SPEC>;
    ///RO, RTC count based one day, only low 14 bit
    pub mod r32_rtc_cnt_day {
        ///Register `R32_RTC_CNT_DAY` reader
        pub struct R(crate::R<R32_RTC_CNT_DAY_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_RTC_CNT_DAY_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_RTC_CNT_DAY_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_RTC_CNT_DAY_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_RTC_CNT_DAY` reader - RWA,RTC count based one day
        pub type R32_RTC_CNT_DAY_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:13 - RWA,RTC count based one day
            #[inline(always)]
            pub fn r32_rtc_cnt_day(&self) -> R32_RTC_CNT_DAY_R {
                R32_RTC_CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        ///RO, RTC count based one day, only low 14 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_rtc_cnt_day](index.html) module
        pub struct R32_RTC_CNT_DAY_SPEC;
        impl crate::RegisterSpec for R32_RTC_CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_rtc_cnt_day::R](R) reader structure
        impl crate::Readable for R32_RTC_CNT_DAY_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_RTC_CNT_DAY to value 0
        impl crate::Resettable for R32_RTC_CNT_DAY_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SAFE_ACCESS_SIG (rw) register accessor: an alias for `Reg<R8_SAFE_ACCESS_SIG_SPEC>`
    pub type R8_SAFE_ACCESS_SIG = crate::Reg<r8_safe_access_sig::R8_SAFE_ACCESS_SIG_SPEC>;
    ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    pub mod r8_safe_access_sig {
        ///Register `R8_SAFE_ACCESS_SIG` reader
        pub struct R(crate::R<R8_SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SAFE_ACCESS_SIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SAFE_ACCESS_SIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SAFE_ACCESS_SIG` writer
        pub struct W(crate::W<R8_SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SAFE_ACCESS_SIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SAFE_ACCESS_SIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type RB_SAFE_ACC_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type RB_SAFE_ACC_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SAFE_ACCESS_SIG_SPEC, u8, u8, 2, O>;
        ///Field `R8_SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type R8_SAFE_ACCESS_SIG_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type R8_SAFE_ACCESS_SIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SAFE_ACCESS_SIG_SPEC, u8, u8, 8, O>;
        ///Field `RB_SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type RB_SAFE_ACC_ACT_R = crate::BitReader<bool>;
        ///Field `RB_SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type RB_SAFE_ACC_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SAFE_ACCESS_SIG_SPEC, bool, O>;
        ///Field `RB_SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)
        pub type RB_SAFE_ACC_TIMER_R = crate::FieldReader<u8, u8>;
        ///Field `RB_SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)
        pub type RB_SAFE_ACC_TIMER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SAFE_ACCESS_SIG_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            pub fn rb_safe_acc_mode(&self) -> RB_SAFE_ACC_MODE_R {
                RB_SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            pub fn r8_safe_access_sig(&self) -> R8_SAFE_ACCESS_SIG_R {
                R8_SAFE_ACCESS_SIG_R::new(self.bits)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            pub fn rb_safe_acc_act(&self) -> RB_SAFE_ACC_ACT_R {
                RB_SAFE_ACC_ACT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            pub fn rb_safe_acc_timer(&self) -> RB_SAFE_ACC_TIMER_R {
                RB_SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            #[must_use]
            pub fn rb_safe_acc_mode(&mut self) -> RB_SAFE_ACC_MODE_W<0> {
                RB_SAFE_ACC_MODE_W::new(self)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn r8_safe_access_sig(&mut self) -> R8_SAFE_ACCESS_SIG_W<0> {
                R8_SAFE_ACCESS_SIG_W::new(self)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            #[must_use]
            pub fn rb_safe_acc_act(&mut self) -> RB_SAFE_ACC_ACT_W<3> {
                RB_SAFE_ACC_ACT_W::new(self)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            #[must_use]
            pub fn rb_safe_acc_timer(&mut self) -> RB_SAFE_ACC_TIMER_W<4> {
                RB_SAFE_ACC_TIMER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_safe_access_sig](index.html) module
        pub struct R8_SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for R8_SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_safe_access_sig::R](R) reader structure
        impl crate::Readable for R8_SAFE_ACCESS_SIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_safe_access_sig::W](W) writer structure
        impl crate::Writable for R8_SAFE_ACCESS_SIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for R8_SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_CHIP_ID (r) register accessor: an alias for `Reg<R8_CHIP_ID_SPEC>`
    pub type R8_CHIP_ID = crate::Reg<r8_chip_id::R8_CHIP_ID_SPEC>;
    ///RF, chip ID register, always is ID_CH58*
    pub mod r8_chip_id {
        ///Register `R8_CHIP_ID` reader
        pub struct R(crate::R<R8_CHIP_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_CHIP_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_CHIP_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_CHIP_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_CHIP_ID` reader - RF,chip ID register
        pub type R8_CHIP_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RF,chip ID register
            #[inline(always)]
            pub fn r8_chip_id(&self) -> R8_CHIP_ID_R {
                R8_CHIP_ID_R::new(self.bits)
            }
        }
        ///RF, chip ID register, always is ID_CH58*
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_chip_id](index.html) module
        pub struct R8_CHIP_ID_SPEC;
        impl crate::RegisterSpec for R8_CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_chip_id::R](R) reader structure
        impl crate::Readable for R8_CHIP_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_CHIP_ID to value 0x83
        impl crate::Resettable for R8_CHIP_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0x83;
        }
    }
    ///R8_SAFE_ACCESS_ID (r) register accessor: an alias for `Reg<R8_SAFE_ACCESS_ID_SPEC>`
    pub type R8_SAFE_ACCESS_ID = crate::Reg<r8_safe_access_id::R8_SAFE_ACCESS_ID_SPEC>;
    ///RF, safe accessing ID register, always 0x0C
    pub mod r8_safe_access_id {
        ///Register `R8_SAFE_ACCESS_ID` reader
        pub struct R(crate::R<R8_SAFE_ACCESS_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SAFE_ACCESS_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SAFE_ACCESS_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SAFE_ACCESS_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SAFE_ACCESS_ID` reader - RF,safe accessing ID register
        pub type R8_SAFE_ACCESS_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RF,safe accessing ID register
            #[inline(always)]
            pub fn r8_safe_access_id(&self) -> R8_SAFE_ACCESS_ID_R {
                R8_SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///RF, safe accessing ID register, always 0x0C
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_safe_access_id](index.html) module
        pub struct R8_SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for R8_SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_safe_access_id::R](R) reader structure
        impl crate::Readable for R8_SAFE_ACCESS_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SAFE_ACCESS_ID to value 0x0c
        impl crate::Resettable for R8_SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c;
        }
    }
    ///R8_WDOG_COUNT (rw) register accessor: an alias for `Reg<R8_WDOG_COUNT_SPEC>`
    pub type R8_WDOG_COUNT = crate::Reg<r8_wdog_count::R8_WDOG_COUNT_SPEC>;
    ///RW, watch-dog count, count by clock frequency Fsys/131072
    pub mod r8_wdog_count {
        ///Register `R8_WDOG_COUNT` reader
        pub struct R(crate::R<R8_WDOG_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_WDOG_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_WDOG_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_WDOG_COUNT` writer
        pub struct W(crate::W<R8_WDOG_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_WDOG_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_WDOG_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type R8_WDOG_COUNT_R = crate::FieldReader<u8, u8>;
        ///Field `R8_WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type R8_WDOG_COUNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_WDOG_COUNT_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            pub fn r8_wdog_count(&self) -> R8_WDOG_COUNT_R {
                R8_WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            #[must_use]
            pub fn r8_wdog_count(&mut self) -> R8_WDOG_COUNT_W<0> {
                R8_WDOG_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, watch-dog count, count by clock frequency Fsys/131072
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_wdog_count](index.html) module
        pub struct R8_WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for R8_WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_wdog_count::R](R) reader structure
        impl crate::Readable for R8_WDOG_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_wdog_count::W](W) writer structure
        impl crate::Writable for R8_WDOG_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_WDOG_COUNT to value 0
        impl crate::Resettable for R8_WDOG_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_RESET_STATUS__R8_GLOB_ROM_CFG (r) register accessor: an alias for `Reg<R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>`
    pub type R8_RESET_STATUS__R8_GLOB_ROM_CFG =
        crate::Reg<r8_reset_status__r8_glob_rom_cfg::R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
    ///RWA, reset status, SAM or flash ROM configuration
    pub mod r8_reset_status__r8_glob_rom_cfg {
        ///Register `R8_RESET_STATUS__R8_GLOB_ROM_CFG` reader
        pub struct R(crate::R<R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_RESET_FLAG` reader - RO, recent reset flag
        pub type RB_RESET_FLAG_R = crate::FieldReader<u8, u8>;
        ///Field `RB_ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
        pub type RB_ROM_CODE_OFS_R = crate::BitReader<bool>;
        ///Field `RB_ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable
        pub type RB_ROM_CTRL_EN_R = crate::BitReader<bool>;
        ///Field `RB_ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write
        pub type RB_ROM_DATA_WE_R = crate::BitReader<bool>;
        ///Field `RB_ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write
        pub type RB_ROM_CODE_WE_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:2 - RO, recent reset flag
            #[inline(always)]
            pub fn rb_reset_flag(&self) -> RB_RESET_FLAG_R {
                RB_RESET_FLAG_R::new(self.bits & 7)
            }
            ///Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
            #[inline(always)]
            pub fn rb_rom_code_ofs(&self) -> RB_ROM_CODE_OFS_R {
                RB_ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable flash ROM control interface enable
            #[inline(always)]
            pub fn rb_rom_ctrl_en(&self) -> RB_ROM_CTRL_EN_R {
                RB_ROM_CTRL_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA,enable flash ROM data and code area being erase/write
            #[inline(always)]
            pub fn rb_rom_data_we(&self) -> RB_ROM_DATA_WE_R {
                RB_ROM_DATA_WE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable flash ROM code area being erase or write
            #[inline(always)]
            pub fn rb_rom_code_we(&self) -> RB_ROM_CODE_WE_R {
                RB_ROM_CODE_WE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RWA, reset status, SAM or flash ROM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_reset_status__r8_glob_rom_cfg](index.html) module
        pub struct R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_reset_status__r8_glob_rom_cfg::R](R) reader structure
        impl crate::Readable for R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_RESET_STATUS__R8_GLOB_ROM_CFG to value 0x01
        impl crate::Resettable for R8_RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_GLOB_CFG_INFO (r) register accessor: an alias for `Reg<R8_GLOB_CFG_INFO_SPEC>`
    pub type R8_GLOB_CFG_INFO = crate::Reg<r8_glob_cfg_info::R8_GLOB_CFG_INFO_SPEC>;
    ///RO, global configuration information and status
    pub mod r8_glob_cfg_info {
        ///Register `R8_GLOB_CFG_INFO` reader
        pub struct R(crate::R<R8_GLOB_CFG_INFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_GLOB_CFG_INFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_GLOB_CFG_INFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_GLOB_CFG_INFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
        pub type RB_CFG_ROM_READ_R = crate::BitReader<bool>;
        ///Field `RB_CFG_RESET_EN` reader - RO, manual reset input enable status
        pub type RB_CFG_RESET_EN_R = crate::BitReader<bool>;
        ///Field `RB_CFG_BOOT_EN` reader - RO, boot-loader enable status
        pub type RB_CFG_BOOT_EN_R = crate::BitReader<bool>;
        ///Field `RB_CFG_DEBUG_EN` reader - RO, debug enable status
        pub type RB_CFG_DEBUG_EN_R = crate::BitReader<bool>;
        ///Field `RB_BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
        pub type RB_BOOT_LOADER_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
            #[inline(always)]
            pub fn rb_cfg_rom_read(&self) -> RB_CFG_ROM_READ_R {
                RB_CFG_ROM_READ_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RO, manual reset input enable status
            #[inline(always)]
            pub fn rb_cfg_reset_en(&self) -> RB_CFG_RESET_EN_R {
                RB_CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, boot-loader enable status
            #[inline(always)]
            pub fn rb_cfg_boot_en(&self) -> RB_CFG_BOOT_EN_R {
                RB_CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, debug enable status
            #[inline(always)]
            pub fn rb_cfg_debug_en(&self) -> RB_CFG_DEBUG_EN_R {
                RB_CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
            #[inline(always)]
            pub fn rb_boot_loader(&self) -> RB_BOOT_LOADER_R {
                RB_BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///RO, global configuration information and status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_glob_cfg_info](index.html) module
        pub struct R8_GLOB_CFG_INFO_SPEC;
        impl crate::RegisterSpec for R8_GLOB_CFG_INFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_glob_cfg_info::R](R) reader structure
        impl crate::Readable for R8_GLOB_CFG_INFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_GLOB_CFG_INFO to value 0x0e
        impl crate::Resettable for R8_GLOB_CFG_INFO_SPEC {
            const RESET_VALUE: Self::Ux = 0x0e;
        }
    }
    ///R8_RST_WDOG_CTRL (rw) register accessor: an alias for `Reg<R8_RST_WDOG_CTRL_SPEC>`
    pub type R8_RST_WDOG_CTRL = crate::Reg<r8_rst_wdog_ctrl::R8_RST_WDOG_CTRL_SPEC>;
    ///RWA, reset and watch-dog control, SAM
    pub mod r8_rst_wdog_ctrl {
        ///Register `R8_RST_WDOG_CTRL` reader
        pub struct R(crate::R<R8_RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_RST_WDOG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_RST_WDOG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_RST_WDOG_CTRL` writer
        pub struct W(crate::W<R8_RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_RST_WDOG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_RST_WDOG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear
        pub type RB_SOFTWARE_RESET_R = crate::BitReader<bool>;
        ///Field `RB_SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear
        pub type RB_SOFTWARE_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `RB_WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type RB_WDOG_RST_EN_R = crate::BitReader<bool>;
        ///Field `RB_WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type RB_WDOG_RST_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `RB_WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type RB_WDOG_INT_EN_R = crate::BitReader<bool>;
        ///Field `RB_WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type RB_WDOG_INT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `RB_WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type RB_WDOG_INT_FLAG_R = crate::BitReader<bool>;
        ///Field `RB_WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type RB_WDOG_INT_FLAG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_RST_WDOG_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            pub fn rb_software_reset(&self) -> RB_SOFTWARE_RESET_R {
                RB_SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn rb_wdog_rst_en(&self) -> RB_WDOG_RST_EN_R {
                RB_WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            pub fn rb_wdog_int_en(&self) -> RB_WDOG_INT_EN_R {
                RB_WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            pub fn rb_wdog_int_flag(&self) -> RB_WDOG_INT_FLAG_R {
                RB_WDOG_INT_FLAG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_software_reset(&mut self) -> RB_SOFTWARE_RESET_W<0> {
                RB_SOFTWARE_RESET_W::new(self)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_wdog_rst_en(&mut self) -> RB_WDOG_RST_EN_W<1> {
                RB_WDOG_RST_EN_W::new(self)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            #[must_use]
            pub fn rb_wdog_int_en(&mut self) -> RB_WDOG_INT_EN_W<2> {
                RB_WDOG_INT_EN_W::new(self)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            #[must_use]
            pub fn rb_wdog_int_flag(&mut self) -> RB_WDOG_INT_FLAG_W<4> {
                RB_WDOG_INT_FLAG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, reset and watch-dog control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_rst_wdog_ctrl](index.html) module
        pub struct R8_RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for R8_RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_rst_wdog_ctrl::R](R) reader structure
        impl crate::Readable for R8_RST_WDOG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_rst_wdog_ctrl::W](W) writer structure
        impl crate::Writable for R8_RST_WDOG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_RST_WDOG_CTRL to value 0
        impl crate::Resettable for R8_RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_GLOB_RESET_KEEP (rw) register accessor: an alias for `Reg<R8_GLOB_RESET_KEEP_SPEC>`
    pub type R8_GLOB_RESET_KEEP = crate::Reg<r8_glob_reset_keep::R8_GLOB_RESET_KEEP_SPEC>;
    ///RW, value keeper during global reset
    pub mod r8_glob_reset_keep {
        ///Register `R8_GLOB_RESET_KEEP` reader
        pub struct R(crate::R<R8_GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_GLOB_RESET_KEEP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_GLOB_RESET_KEEP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_GLOB_RESET_KEEP` writer
        pub struct W(crate::W<R8_GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_GLOB_RESET_KEEP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_GLOB_RESET_KEEP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_GLOB_RESET_KEEP` reader - RW, value keeper during global reset
        pub type R8_GLOB_RESET_KEEP_R = crate::FieldReader<u8, u8>;
        ///Field `R8_GLOB_RESET_KEEP` writer - RW, value keeper during global reset
        pub type R8_GLOB_RESET_KEEP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_GLOB_RESET_KEEP_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            pub fn r8_glob_reset_keep(&self) -> R8_GLOB_RESET_KEEP_R {
                R8_GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn r8_glob_reset_keep(&mut self) -> R8_GLOB_RESET_KEEP_W<0> {
                R8_GLOB_RESET_KEEP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, value keeper during global reset
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_glob_reset_keep](index.html) module
        pub struct R8_GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for R8_GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_glob_reset_keep::R](R) reader structure
        impl crate::Readable for R8_GLOB_RESET_KEEP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_glob_reset_keep::W](W) writer structure
        impl crate::Writable for R8_GLOB_RESET_KEEP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_GLOB_RESET_KEEP to value 0
        impl crate::Resettable for R8_GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PLL_CONFIG (rw) register accessor: an alias for `Reg<R8_PLL_CONFIG_SPEC>`
    pub type R8_PLL_CONFIG = crate::Reg<r8_pll_config::R8_PLL_CONFIG_SPEC>;
    ///RWA, PLL configuration control, SAM
    pub mod r8_pll_config {
        ///Register `R8_PLL_CONFIG` reader
        pub struct R(crate::R<R8_PLL_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PLL_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PLL_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PLL_CONFIG` writer
        pub struct W(crate::W<R8_PLL_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PLL_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PLL_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PLL_CFG_DAT` reader - RWA, PLL configure data
        pub type RB_PLL_CFG_DAT_R = crate::FieldReader<u8, u8>;
        ///Field `RB_PLL_CFG_DAT` writer - RWA, PLL configure data
        pub type RB_PLL_CFG_DAT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PLL_CONFIG_SPEC, u8, u8, 7, O>;
        ///Field `RB_FLASH_IO_MOD` reader - RWA, flash ROM interface mode
        pub type RB_FLASH_IO_MOD_R = crate::BitReader<bool>;
        ///Field `RB_FLASH_IO_MOD` writer - RWA, flash ROM interface mode
        pub type RB_FLASH_IO_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PLL_CONFIG_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            pub fn rb_pll_cfg_dat(&self) -> RB_PLL_CFG_DAT_R {
                RB_PLL_CFG_DAT_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            pub fn rb_flash_io_mod(&self) -> RB_FLASH_IO_MOD_R {
                RB_FLASH_IO_MOD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            #[must_use]
            pub fn rb_pll_cfg_dat(&mut self) -> RB_PLL_CFG_DAT_W<0> {
                RB_PLL_CFG_DAT_W::new(self)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            #[must_use]
            pub fn rb_flash_io_mod(&mut self) -> RB_FLASH_IO_MOD_W<7> {
                RB_FLASH_IO_MOD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, PLL configuration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pll_config](index.html) module
        pub struct R8_PLL_CONFIG_SPEC;
        impl crate::RegisterSpec for R8_PLL_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pll_config::R](R) reader structure
        impl crate::Readable for R8_PLL_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pll_config::W](W) writer structure
        impl crate::Writable for R8_PLL_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PLL_CONFIG to value 0x4a
        impl crate::Resettable for R8_PLL_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x4a;
        }
    }
    ///R8_XT32M_TUNE (rw) register accessor: an alias for `Reg<R8_XT32M_TUNE_SPEC>`
    pub type R8_XT32M_TUNE = crate::Reg<r8_xt32m_tune::R8_XT32M_TUNE_SPEC>;
    ///RWA, external 32MHz oscillator tune control, SAM
    pub mod r8_xt32m_tune {
        ///Register `R8_XT32M_TUNE` reader
        pub struct R(crate::R<R8_XT32M_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_XT32M_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_XT32M_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_XT32M_TUNE` writer
        pub struct W(crate::W<R8_XT32M_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_XT32M_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_XT32M_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type RB_XT32M_I_BIAS_R = crate::FieldReader<u8, u8>;
        ///Field `RB_XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type RB_XT32M_I_BIAS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_XT32M_TUNE_SPEC, u8, u8, 2, O>;
        ///Field `RB_XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type RB_XT32M_C_LOAD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type RB_XT32M_C_LOAD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_XT32M_TUNE_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            pub fn rb_xt32m_i_bias(&self) -> RB_XT32M_I_BIAS_R {
                RB_XT32M_I_BIAS_R::new(self.bits & 3)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            pub fn rb_xt32m_c_load(&self) -> RB_XT32M_C_LOAD_R {
                RB_XT32M_C_LOAD_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            #[must_use]
            pub fn rb_xt32m_i_bias(&mut self) -> RB_XT32M_I_BIAS_W<0> {
                RB_XT32M_I_BIAS_W::new(self)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            #[must_use]
            pub fn rb_xt32m_c_load(&mut self) -> RB_XT32M_C_LOAD_W<4> {
                RB_XT32M_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, external 32MHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_xt32m_tune](index.html) module
        pub struct R8_XT32M_TUNE_SPEC;
        impl crate::RegisterSpec for R8_XT32M_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_xt32m_tune::R](R) reader structure
        impl crate::Readable for R8_XT32M_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_xt32m_tune::W](W) writer structure
        impl crate::Writable for R8_XT32M_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_XT32M_TUNE to value 0x32
        impl crate::Resettable for R8_XT32M_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x32;
        }
    }
    ///R16_OSC_CAL_CNT (r) register accessor: an alias for `Reg<R16_OSC_CAL_CNT_SPEC>`
    pub type R16_OSC_CAL_CNT = crate::Reg<r16_osc_cal_cnt::R16_OSC_CAL_CNT_SPEC>;
    ///RO, system clock count value for 32KHz multi-cycles
    pub mod r16_osc_cal_cnt {
        ///Register `R16_OSC_CAL_CNT` reader
        pub struct R(crate::R<R16_OSC_CAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_OSC_CAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_OSC_CAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_OSC_CAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles
        pub type RB_OSC_CAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `RB_OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
        pub type RB_OSC_CAL_OV_CLR_R = crate::BitReader<bool>;
        ///Field `RB_OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear
        pub type RB_OSC_CAL_IF_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:13 - RO, system clock count value for 32KHz multi-cycles
            #[inline(always)]
            pub fn rb_osc_cal_cnt(&self) -> RB_OSC_CAL_CNT_R {
                RB_OSC_CAL_CNT_R::new(self.bits & 0x3fff)
            }
            ///Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
            #[inline(always)]
            pub fn rb_osc_cal_ov_clr(&self) -> RB_OSC_CAL_OV_CLR_R {
                RB_OSC_CAL_OV_CLR_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear
            #[inline(always)]
            pub fn rb_osc_cal_if(&self) -> RB_OSC_CAL_IF_R {
                RB_OSC_CAL_IF_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///RO, system clock count value for 32KHz multi-cycles
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_osc_cal_cnt](index.html) module
        pub struct R16_OSC_CAL_CNT_SPEC;
        impl crate::RegisterSpec for R16_OSC_CAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_osc_cal_cnt::R](R) reader structure
        impl crate::Readable for R16_OSC_CAL_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_OSC_CAL_CNT to value 0
        impl crate::Resettable for R16_OSC_CAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_OSC_CAL_CTRL (rw) register accessor: an alias for `Reg<R8_OSC_CAL_CTRL_SPEC>`
    pub type R8_OSC_CAL_CTRL = crate::Reg<r8_osc_cal_ctrl::R8_OSC_CAL_CTRL_SPEC>;
    ///RWA, oscillator frequency calibration control, SAM
    pub mod r8_osc_cal_ctrl {
        ///Register `R8_OSC_CAL_CTRL` reader
        pub struct R(crate::R<R8_OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_OSC_CAL_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_OSC_CAL_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_OSC_CAL_CTRL` writer
        pub struct W(crate::W<R8_OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_OSC_CAL_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_OSC_CAL_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture
        pub type RB_OSC_CNT_TOTAL_R = crate::FieldReader<u8, u8>;
        ///Field `RB_OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture
        pub type RB_OSC_CNT_TOTAL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_OSC_CAL_CTRL_SPEC, u8, u8, 3, O>;
        ///Field `RB_OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
        pub type RB_OSC_CNT_HALT_R = crate::BitReader<bool>;
        ///Field `RB_OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end
        pub type RB_OSC_CAL_IE_R = crate::BitReader<bool>;
        ///Field `RB_OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end
        pub type RB_OSC_CAL_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_OSC_CAL_CTRL_SPEC, bool, O>;
        ///Field `RB_OSC_CNT_EN` reader - RWA, calibration counter enable
        pub type RB_OSC_CNT_EN_R = crate::BitReader<bool>;
        ///Field `RB_OSC_CNT_EN` writer - RWA, calibration counter enable
        pub type RB_OSC_CNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_OSC_CAL_CTRL_SPEC, bool, O>;
        ///Field `RB_OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type RB_OSC_CNT_END_R = crate::BitReader<bool>;
        ///Field `RB_OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type RB_OSC_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_OSC_CAL_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            pub fn rb_osc_cnt_total(&self) -> RB_OSC_CNT_TOTAL_R {
                RB_OSC_CNT_TOTAL_R::new(self.bits & 7)
            }
            ///Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
            #[inline(always)]
            pub fn rb_osc_cnt_halt(&self) -> RB_OSC_CNT_HALT_R {
                RB_OSC_CNT_HALT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            pub fn rb_osc_cal_ie(&self) -> RB_OSC_CAL_IE_R {
                RB_OSC_CAL_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            pub fn rb_osc_cnt_en(&self) -> RB_OSC_CNT_EN_R {
                RB_OSC_CNT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            pub fn rb_osc_cnt_end(&self) -> RB_OSC_CNT_END_R {
                RB_OSC_CNT_END_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            #[must_use]
            pub fn rb_osc_cnt_total(&mut self) -> RB_OSC_CNT_TOTAL_W<0> {
                RB_OSC_CNT_TOTAL_W::new(self)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            #[must_use]
            pub fn rb_osc_cal_ie(&mut self) -> RB_OSC_CAL_IE_W<4> {
                RB_OSC_CAL_IE_W::new(self)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            #[must_use]
            pub fn rb_osc_cnt_en(&mut self) -> RB_OSC_CNT_EN_W<5> {
                RB_OSC_CNT_EN_W::new(self)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            #[must_use]
            pub fn rb_osc_cnt_end(&mut self) -> RB_OSC_CNT_END_W<6> {
                RB_OSC_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, oscillator frequency calibration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_osc_cal_ctrl](index.html) module
        pub struct R8_OSC_CAL_CTRL_SPEC;
        impl crate::RegisterSpec for R8_OSC_CAL_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_osc_cal_ctrl::R](R) reader structure
        impl crate::Readable for R8_OSC_CAL_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_osc_cal_ctrl::W](W) writer structure
        impl crate::Writable for R8_OSC_CAL_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_OSC_CAL_CTRL to value 0x09
        impl crate::Resettable for R8_OSC_CAL_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x09;
        }
    }
    ///R8_OSC_CAL_OV_CNT (r) register accessor: an alias for `Reg<R8_OSC_CAL_OV_CNT_SPEC>`
    pub type R8_OSC_CAL_OV_CNT = crate::Reg<r8_osc_cal_ov_cnt::R8_OSC_CAL_OV_CNT_SPEC>;
    ///RO, oscillator frequency calibration overflow times
    pub mod r8_osc_cal_ov_cnt {
        ///Register `R8_OSC_CAL_OV_CNT` reader
        pub struct R(crate::R<R8_OSC_CAL_OV_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_OSC_CAL_OV_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_OSC_CAL_OV_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_OSC_CAL_OV_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times
        pub type R8_OSC_CAL_OV_CNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, oscillator frequency calibration overflow times
            #[inline(always)]
            pub fn r8_osc_cal_ov_cnt(&self) -> R8_OSC_CAL_OV_CNT_R {
                R8_OSC_CAL_OV_CNT_R::new(self.bits)
            }
        }
        ///RO, oscillator frequency calibration overflow times
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_osc_cal_ov_cnt](index.html) module
        pub struct R8_OSC_CAL_OV_CNT_SPEC;
        impl crate::RegisterSpec for R8_OSC_CAL_OV_CNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_osc_cal_ov_cnt::R](R) reader structure
        impl crate::Readable for R8_OSC_CAL_OV_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_OSC_CAL_OV_CNT to value 0
        impl crate::Resettable for R8_OSC_CAL_OV_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TKEY_COUNT (rw) register accessor: an alias for `Reg<R8_TKEY_COUNT_SPEC>`
    pub type R8_TKEY_COUNT = crate::Reg<r8_tkey_count::R8_TKEY_COUNT_SPEC>;
    ///RW, Touchkey charge and discharge count
    pub mod r8_tkey_count {
        ///Register `R8_TKEY_COUNT` reader
        pub struct R(crate::R<R8_TKEY_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TKEY_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TKEY_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TKEY_COUNT` writer
        pub struct W(crate::W<R8_TKEY_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TKEY_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TKEY_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TKEY_CHARG_CNT` reader - RW, Touchkey charge count
        pub type RB_TKEY_CHARG_CNT_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TKEY_CHARG_CNT` writer - RW, Touchkey charge count
        pub type RB_TKEY_CHARG_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TKEY_COUNT_SPEC, u8, u8, 5, O>;
        ///Field `RB_TKEY_DISCH_CNT` reader - RW, Touchkey discharge count
        pub type RB_TKEY_DISCH_CNT_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TKEY_DISCH_CNT` writer - RW, Touchkey discharge count
        pub type RB_TKEY_DISCH_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TKEY_COUNT_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            pub fn rb_tkey_charg_cnt(&self) -> RB_TKEY_CHARG_CNT_R {
                RB_TKEY_CHARG_CNT_R::new(self.bits & 0x1f)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            pub fn rb_tkey_disch_cnt(&self) -> RB_TKEY_DISCH_CNT_R {
                RB_TKEY_DISCH_CNT_R::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_charg_cnt(&mut self) -> RB_TKEY_CHARG_CNT_W<0> {
                RB_TKEY_CHARG_CNT_W::new(self)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_disch_cnt(&mut self) -> RB_TKEY_DISCH_CNT_W<5> {
                RB_TKEY_DISCH_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey charge and discharge count
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tkey_count](index.html) module
        pub struct R8_TKEY_COUNT_SPEC;
        impl crate::RegisterSpec for R8_TKEY_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tkey_count::R](R) reader structure
        impl crate::Readable for R8_TKEY_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tkey_count::W](W) writer structure
        impl crate::Writable for R8_TKEY_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TKEY_COUNT to value 0
        impl crate::Resettable for R8_TKEY_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TKEY_CONVERT (rw) register accessor: an alias for `Reg<R8_TKEY_CONVERT_SPEC>`
    pub type R8_TKEY_CONVERT = crate::Reg<r8_tkey_convert::R8_TKEY_CONVERT_SPEC>;
    ///RW, Touchkey convert start control
    pub mod r8_tkey_convert {
        ///Register `R8_TKEY_CONVERT` reader
        pub struct R(crate::R<R8_TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TKEY_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TKEY_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TKEY_CONVERT` writer
        pub struct W(crate::W<R8_TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TKEY_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TKEY_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TKEY_START` reader - RW, Touchkey convert start control
        pub type RB_TKEY_START_R = crate::BitReader<bool>;
        ///Field `RB_TKEY_START` writer - RW, Touchkey convert start control
        pub type RB_TKEY_START_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TKEY_CONVERT_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            pub fn rb_tkey_start(&self) -> RB_TKEY_START_R {
                RB_TKEY_START_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_start(&mut self) -> RB_TKEY_START_W<0> {
                RB_TKEY_START_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey convert start control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tkey_convert](index.html) module
        pub struct R8_TKEY_CONVERT_SPEC;
        impl crate::RegisterSpec for R8_TKEY_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tkey_convert::R](R) reader structure
        impl crate::Readable for R8_TKEY_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tkey_convert::W](W) writer structure
        impl crate::Writable for R8_TKEY_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TKEY_CONVERT to value 0
        impl crate::Resettable for R8_TKEY_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TKEY_CFG (rw) register accessor: an alias for `Reg<R8_TKEY_CFG_SPEC>`
    pub type R8_TKEY_CFG = crate::Reg<r8_tkey_cfg::R8_TKEY_CFG_SPEC>;
    ///RW, Touchkey configure
    pub mod r8_tkey_cfg {
        ///Register `R8_TKEY_CFG` reader
        pub struct R(crate::R<R8_TKEY_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TKEY_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TKEY_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TKEY_CFG` writer
        pub struct W(crate::W<R8_TKEY_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TKEY_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TKEY_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TKEY_PWR_ON` reader - RW, Touchkey power on
        pub type RB_TKEY_PWR_ON_R = crate::BitReader<bool>;
        ///Field `RB_TKEY_PWR_ON` writer - RW, Touchkey power on
        pub type RB_TKEY_PWR_ON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TKEY_CFG_SPEC, bool, O>;
        ///Field `RB_TKEY_CURRENT` reader - RW, Touchkey charge current selection
        pub type RB_TKEY_CURRENT_R = crate::BitReader<bool>;
        ///Field `RB_TKEY_CURRENT` writer - RW, Touchkey charge current selection
        pub type RB_TKEY_CURRENT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TKEY_CFG_SPEC, bool, O>;
        ///Field `RB_TKEY_DRV_EN` reader - RW, Touchkey drive shield enable
        pub type RB_TKEY_DRV_EN_R = crate::BitReader<bool>;
        ///Field `RB_TKEY_DRV_EN` writer - RW, Touchkey drive shield enable
        pub type RB_TKEY_DRV_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TKEY_CFG_SPEC, bool, O>;
        ///Field `RB_TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection
        pub type RB_TKEY_PGA_ADJ_R = crate::BitReader<bool>;
        ///Field `RB_TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection
        pub type RB_TKEY_PGA_ADJ_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TKEY_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            pub fn rb_tkey_pwr_on(&self) -> RB_TKEY_PWR_ON_R {
                RB_TKEY_PWR_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            pub fn rb_tkey_current(&self) -> RB_TKEY_CURRENT_R {
                RB_TKEY_CURRENT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            pub fn rb_tkey_drv_en(&self) -> RB_TKEY_DRV_EN_R {
                RB_TKEY_DRV_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            pub fn rb_tkey_pga_adj(&self) -> RB_TKEY_PGA_ADJ_R {
                RB_TKEY_PGA_ADJ_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_pwr_on(&mut self) -> RB_TKEY_PWR_ON_W<0> {
                RB_TKEY_PWR_ON_W::new(self)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_current(&mut self) -> RB_TKEY_CURRENT_W<1> {
                RB_TKEY_CURRENT_W::new(self)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_drv_en(&mut self) -> RB_TKEY_DRV_EN_W<2> {
                RB_TKEY_DRV_EN_W::new(self)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            #[must_use]
            pub fn rb_tkey_pga_adj(&mut self) -> RB_TKEY_PGA_ADJ_W<3> {
                RB_TKEY_PGA_ADJ_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tkey_cfg](index.html) module
        pub struct R8_TKEY_CFG_SPEC;
        impl crate::RegisterSpec for R8_TKEY_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tkey_cfg::R](R) reader structure
        impl crate::Readable for R8_TKEY_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tkey_cfg::W](W) writer structure
        impl crate::Writable for R8_TKEY_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TKEY_CFG to value 0
        impl crate::Resettable for R8_TKEY_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_ADC_CHANNEL (rw) register accessor: an alias for `Reg<R8_ADC_CHANNEL_SPEC>`
    pub type R8_ADC_CHANNEL = crate::Reg<r8_adc_channel::R8_ADC_CHANNEL_SPEC>;
    ///RW, ADC input channel selection
    pub mod r8_adc_channel {
        ///Register `R8_ADC_CHANNEL` reader
        pub struct R(crate::R<R8_ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_CHANNEL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_CHANNEL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_CHANNEL` writer
        pub struct W(crate::W<R8_ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_CHANNEL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_CHANNEL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ADC_CH_INX` reader - RW, ADC input channel index
        pub type RB_ADC_CH_INX_R = crate::FieldReader<u8, u8>;
        ///Field `RB_ADC_CH_INX` writer - RW, ADC input channel index
        pub type RB_ADC_CH_INX_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_ADC_CHANNEL_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            pub fn rb_adc_ch_inx(&self) -> RB_ADC_CH_INX_R {
                RB_ADC_CH_INX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_ch_inx(&mut self) -> RB_ADC_CH_INX_W<0> {
                RB_ADC_CH_INX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC input channel selection
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_channel](index.html) module
        pub struct R8_ADC_CHANNEL_SPEC;
        impl crate::RegisterSpec for R8_ADC_CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_channel::R](R) reader structure
        impl crate::Readable for R8_ADC_CHANNEL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_channel::W](W) writer structure
        impl crate::Writable for R8_ADC_CHANNEL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_CHANNEL to value 0x0f
        impl crate::Resettable for R8_ADC_CHANNEL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0f;
        }
    }
    ///R8_ADC_CFG (rw) register accessor: an alias for `Reg<R8_ADC_CFG_SPEC>`
    pub type R8_ADC_CFG = crate::Reg<r8_adc_cfg::R8_ADC_CFG_SPEC>;
    ///RW, ADC configure
    pub mod r8_adc_cfg {
        ///Register `R8_ADC_CFG` reader
        pub struct R(crate::R<R8_ADC_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_CFG` writer
        pub struct W(crate::W<R8_ADC_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ADC_POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on
        pub type RB_ADC_POWER_ON_R = crate::BitReader<bool>;
        ///Field `RB_ADC_POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on
        pub type RB_ADC_POWER_ON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CFG_SPEC, bool, O>;
        ///Field `RB_ADC_BUF_EN` reader - RW, ADC input buffer enable
        pub type RB_ADC_BUF_EN_R = crate::BitReader<bool>;
        ///Field `RB_ADC_BUF_EN` writer - RW, ADC input buffer enable
        pub type RB_ADC_BUF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CFG_SPEC, bool, O>;
        ///Field `RB_ADC_DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type RB_ADC_DIFF_EN_R = crate::BitReader<bool>;
        ///Field `RB_ADC_DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type RB_ADC_DIFF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CFG_SPEC, bool, O>;
        ///Field `RB_ADC_OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type RB_ADC_OFS_TEST_R = crate::BitReader<bool>;
        ///Field `RB_ADC_OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type RB_ADC_OFS_TEST_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CFG_SPEC, bool, O>;
        ///Field `RB_ADC_PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type RB_ADC_PGA_GAIN_R = crate::FieldReader<u8, u8>;
        ///Field `RB_ADC_PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type RB_ADC_PGA_GAIN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_ADC_CFG_SPEC, u8, u8, 2, O>;
        ///Field `RB_ADC_CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type RB_ADC_CLK_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `RB_ADC_CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type RB_ADC_CLK_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_ADC_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn rb_adc_power_on(&self) -> RB_ADC_POWER_ON_R {
                RB_ADC_POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            pub fn rb_adc_buf_en(&self) -> RB_ADC_BUF_EN_R {
                RB_ADC_BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn rb_adc_diff_en(&self) -> RB_ADC_DIFF_EN_R {
                RB_ADC_DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            pub fn rb_adc_ofs_test(&self) -> RB_ADC_OFS_TEST_R {
                RB_ADC_OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn rb_adc_pga_gain(&self) -> RB_ADC_PGA_GAIN_R {
                RB_ADC_PGA_GAIN_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn rb_adc_clk_div(&self) -> RB_ADC_CLK_DIV_R {
                RB_ADC_CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_power_on(&mut self) -> RB_ADC_POWER_ON_W<0> {
                RB_ADC_POWER_ON_W::new(self)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_buf_en(&mut self) -> RB_ADC_BUF_EN_W<1> {
                RB_ADC_BUF_EN_W::new(self)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_diff_en(&mut self) -> RB_ADC_DIFF_EN_W<2> {
                RB_ADC_DIFF_EN_W::new(self)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_ofs_test(&mut self) -> RB_ADC_OFS_TEST_W<3> {
                RB_ADC_OFS_TEST_W::new(self)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_pga_gain(&mut self) -> RB_ADC_PGA_GAIN_W<4> {
                RB_ADC_PGA_GAIN_W::new(self)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_clk_div(&mut self) -> RB_ADC_CLK_DIV_W<6> {
                RB_ADC_CLK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_cfg](index.html) module
        pub struct R8_ADC_CFG_SPEC;
        impl crate::RegisterSpec for R8_ADC_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_cfg::R](R) reader structure
        impl crate::Readable for R8_ADC_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_cfg::W](W) writer structure
        impl crate::Writable for R8_ADC_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_CFG to value 0xa0
        impl crate::Resettable for R8_ADC_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0xa0;
        }
    }
    ///R8_ADC_CONVERT (rw) register accessor: an alias for `Reg<R8_ADC_CONVERT_SPEC>`
    pub type R8_ADC_CONVERT = crate::Reg<r8_adc_convert::R8_ADC_CONVERT_SPEC>;
    ///RW, ADC convert control
    pub mod r8_adc_convert {
        ///Register `R8_ADC_CONVERT` reader
        pub struct R(crate::R<R8_ADC_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_CONVERT` writer
        pub struct W(crate::W<R8_ADC_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ADC_START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type RB_ADC_START_R = crate::BitReader<bool>;
        ///Field `RB_ADC_START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type RB_ADC_START_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CONVERT_SPEC, bool, O>;
        ///Field `RB_ADC_EOC_X` reader - RO, end of ADC conversion flag
        pub type RB_ADC_EOC_X_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            pub fn rb_adc_start(&self) -> RB_ADC_START_R {
                RB_ADC_START_R::new((self.bits & 1) != 0)
            }
            ///Bit 7 - RO, end of ADC conversion flag
            #[inline(always)]
            pub fn rb_adc_eoc_x(&self) -> RB_ADC_EOC_X_R {
                RB_ADC_EOC_X_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_start(&mut self) -> RB_ADC_START_W<0> {
                RB_ADC_START_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC convert control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_convert](index.html) module
        pub struct R8_ADC_CONVERT_SPEC;
        impl crate::RegisterSpec for R8_ADC_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_convert::R](R) reader structure
        impl crate::Readable for R8_ADC_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_convert::W](W) writer structure
        impl crate::Writable for R8_ADC_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_CONVERT to value 0
        impl crate::Resettable for R8_ADC_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TEM_SENSOR (rw) register accessor: an alias for `Reg<R8_TEM_SENSOR_SPEC>`
    pub type R8_TEM_SENSOR = crate::Reg<r8_tem_sensor::R8_TEM_SENSOR_SPEC>;
    ///RW, temperature sensor control
    pub mod r8_tem_sensor {
        ///Register `R8_TEM_SENSOR` reader
        pub struct R(crate::R<R8_TEM_SENSOR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TEM_SENSOR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TEM_SENSOR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TEM_SENSOR` writer
        pub struct W(crate::W<R8_TEM_SENSOR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TEM_SENSOR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TEM_SENSOR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on
        pub type RB_TEM_SEN_PWR_ON_R = crate::BitReader<bool>;
        ///Field `RB_TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on
        pub type RB_TEM_SEN_PWR_ON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TEM_SENSOR_SPEC, bool, O>;
        impl R {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn rb_tem_sen_pwr_on(&self) -> RB_TEM_SEN_PWR_ON_R {
                RB_TEM_SEN_PWR_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn rb_tem_sen_pwr_on(&mut self) -> RB_TEM_SEN_PWR_ON_W<7> {
                RB_TEM_SEN_PWR_ON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, temperature sensor control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tem_sensor](index.html) module
        pub struct R8_TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for R8_TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tem_sensor::R](R) reader structure
        impl crate::Readable for R8_TEM_SENSOR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tem_sensor::W](W) writer structure
        impl crate::Writable for R8_TEM_SENSOR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TEM_SENSOR to value 0
        impl crate::Resettable for R8_TEM_SENSOR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_ADC_DATA (r) register accessor: an alias for `Reg<R16_ADC_DATA_SPEC>`
    pub type R16_ADC_DATA = crate::Reg<r16_adc_data::R16_ADC_DATA_SPEC>;
    ///RO, ADC data
    pub mod r16_adc_data {
        ///Register `R16_ADC_DATA` reader
        pub struct R(crate::R<R16_ADC_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_ADC_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_ADC_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_ADC_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_ADC_DATA` reader - RO, ADC conversion data
        pub type RB_ADC_DATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:11 - RO, ADC conversion data
            #[inline(always)]
            pub fn rb_adc_data(&self) -> RB_ADC_DATA_R {
                RB_ADC_DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///RO, ADC data
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_adc_data](index.html) module
        pub struct R16_ADC_DATA_SPEC;
        impl crate::RegisterSpec for R16_ADC_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_adc_data::R](R) reader structure
        impl crate::Readable for R16_ADC_DATA_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_ADC_DATA to value 0
        impl crate::Resettable for R16_ADC_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_ADC_INT_FLAG (r) register accessor: an alias for `Reg<R8_ADC_INT_FLAG_SPEC>`
    pub type R8_ADC_INT_FLAG = crate::Reg<r8_adc_int_flag::R8_ADC_INT_FLAG_SPEC>;
    ///RO, ADC interrupt flag register
    pub mod r8_adc_int_flag {
        ///Register `R8_ADC_INT_FLAG` reader
        pub struct R(crate::R<R8_ADC_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_ADC_IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
        pub type RB_ADC_IF_EOC_R = crate::BitReader<bool>;
        impl R {
            ///Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
            #[inline(always)]
            pub fn rb_adc_if_eoc(&self) -> RB_ADC_IF_EOC_R {
                RB_ADC_IF_EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, ADC interrupt flag register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_int_flag](index.html) module
        pub struct R8_ADC_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_ADC_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_int_flag::R](R) reader structure
        impl crate::Readable for R8_ADC_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_ADC_INT_FLAG to value 0
        impl crate::Resettable for R8_ADC_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_ADC_DMA_CTRL (rw) register accessor: an alias for `Reg<R32_ADC_DMA_CTRL_SPEC>`
    pub type R32_ADC_DMA_CTRL = crate::Reg<r32_adc_dma_ctrl::R32_ADC_DMA_CTRL_SPEC>;
    ///RO, ADC DMA control and status register
    pub mod r32_adc_dma_ctrl {
        ///Register `R32_ADC_DMA_CTRL` reader
        pub struct R(crate::R<R32_ADC_DMA_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_ADC_DMA_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_ADC_DMA_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_ADC_DMA_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_ADC_DMA_CTRL` writer
        pub struct W(crate::W<R32_ADC_DMA_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_ADC_DMA_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_ADC_DMA_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_ADC_DMA_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_ADC_DMA_CTRL` reader - RW, ADC DMA enable
        pub type R32_ADC_DMA_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `R32_ADC_DMA_CTRL` writer - RW, ADC DMA enable
        pub type R32_ADC_DMA_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R32_ADC_DMA_CTRL_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            pub fn r32_adc_dma_ctrl(&self) -> R32_ADC_DMA_CTRL_R {
                R32_ADC_DMA_CTRL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn r32_adc_dma_ctrl(&mut self) -> R32_ADC_DMA_CTRL_W<0> {
                R32_ADC_DMA_CTRL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC DMA control and status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_adc_dma_ctrl](index.html) module
        pub struct R32_ADC_DMA_CTRL_SPEC;
        impl crate::RegisterSpec for R32_ADC_DMA_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r32_adc_dma_ctrl::R](R) reader structure
        impl crate::Readable for R32_ADC_DMA_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_adc_dma_ctrl::W](W) writer structure
        impl crate::Writable for R32_ADC_DMA_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_ADC_DMA_CTRL to value 0
        impl crate::Resettable for R32_ADC_DMA_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_ADC_CTRL_DMA (rw) register accessor: an alias for `Reg<R8_ADC_CTRL_DMA_SPEC>`
    pub type R8_ADC_CTRL_DMA = crate::Reg<r8_adc_ctrl_dma::R8_ADC_CTRL_DMA_SPEC>;
    ///RW, ADC DMA control
    pub mod r8_adc_ctrl_dma {
        ///Register `R8_ADC_CTRL_DMA` reader
        pub struct R(crate::R<R8_ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_CTRL_DMA` writer
        pub struct W(crate::W<R8_ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ADC_DMA_ENABLE` reader - RW, ADC DMA enable
        pub type RB_ADC_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `RB_ADC_DMA_ENABLE` writer - RW, ADC DMA enable
        pub type RB_ADC_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_ADC_DMA_LOOP` reader - RW, ADC DMA address loop enable
        pub type RB_ADC_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_ADC_DMA_LOOP` writer - RW, ADC DMA address loop enable
        pub type RB_ADC_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_ADC_IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion
        pub type RB_ADC_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_ADC_IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion
        pub type RB_ADC_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_ADC_IE_EOC` reader - RW, enable interrupt for end of ADC conversion
        pub type RB_ADC_IE_EOC_R = crate::BitReader<bool>;
        ///Field `RB_ADC_IE_EOC` writer - RW, enable interrupt for end of ADC conversion
        pub type RB_ADC_IE_EOC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_ADC_CONT_EN` reader - RW, enable contineous conversion ADC
        pub type RB_ADC_CONT_EN_R = crate::BitReader<bool>;
        ///Field `RB_ADC_CONT_EN` writer - RW, enable contineous conversion ADC
        pub type RB_ADC_CONT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_ADC_AUTO_EN` reader - RW, enable auto continuing ADC for DMA
        pub type RB_ADC_AUTO_EN_R = crate::BitReader<bool>;
        ///Field `RB_ADC_AUTO_EN` writer - RW, enable auto continuing ADC for DMA
        pub type RB_ADC_AUTO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            pub fn rb_adc_dma_enable(&self) -> RB_ADC_DMA_ENABLE_R {
                RB_ADC_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            pub fn rb_adc_dma_loop(&self) -> RB_ADC_DMA_LOOP_R {
                RB_ADC_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            pub fn rb_adc_ie_dma_end(&self) -> RB_ADC_IE_DMA_END_R {
                RB_ADC_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            pub fn rb_adc_ie_eoc(&self) -> RB_ADC_IE_EOC_R {
                RB_ADC_IE_EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            pub fn rb_adc_cont_en(&self) -> RB_ADC_CONT_EN_R {
                RB_ADC_CONT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn rb_adc_auto_en(&self) -> RB_ADC_AUTO_EN_R {
                RB_ADC_AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_dma_enable(&mut self) -> RB_ADC_DMA_ENABLE_W<0> {
                RB_ADC_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_dma_loop(&mut self) -> RB_ADC_DMA_LOOP_W<2> {
                RB_ADC_DMA_LOOP_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_ie_dma_end(&mut self) -> RB_ADC_IE_DMA_END_W<3> {
                RB_ADC_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_ie_eoc(&mut self) -> RB_ADC_IE_EOC_W<4> {
                RB_ADC_IE_EOC_W::new(self)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_cont_en(&mut self) -> RB_ADC_CONT_EN_W<6> {
                RB_ADC_CONT_EN_W::new(self)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_auto_en(&mut self) -> RB_ADC_AUTO_EN_W<7> {
                RB_ADC_AUTO_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_ctrl_dma](index.html) module
        pub struct R8_ADC_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for R8_ADC_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_ctrl_dma::R](R) reader structure
        impl crate::Readable for R8_ADC_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_ctrl_dma::W](W) writer structure
        impl crate::Writable for R8_ADC_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_CTRL_DMA to value 0
        impl crate::Resettable for R8_ADC_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_ADC_DMA_IF (rw) register accessor: an alias for `Reg<R8_ADC_DMA_IF_SPEC>`
    pub type R8_ADC_DMA_IF = crate::Reg<r8_adc_dma_if::R8_ADC_DMA_IF_SPEC>;
    ///RO, ADC interrupt flag
    pub mod r8_adc_dma_if {
        ///Register `R8_ADC_DMA_IF` reader
        pub struct R(crate::R<R8_ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_DMA_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_DMA_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_DMA_IF` writer
        pub struct W(crate::W<R8_ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_DMA_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_DMA_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_ADC_IF_DMA_END` reader - interrupt flag for ADC DMA completion
        pub type RB_ADC_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_ADC_IF_DMA_END` writer - interrupt flag for ADC DMA completion
        pub type RB_ADC_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_DMA_IF_SPEC, bool, O>;
        ///Field `RB_ADC_IF_END_ADC` reader - interrupt flag for end of ADC conversion
        pub type RB_ADC_IF_END_ADC_R = crate::BitReader<bool>;
        ///Field `RB_ADC_IF_END_ADC` writer - interrupt flag for end of ADC conversion
        pub type RB_ADC_IF_END_ADC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_ADC_DMA_IF_SPEC, bool, O>;
        impl R {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            pub fn rb_adc_if_dma_end(&self) -> RB_ADC_IF_DMA_END_R {
                RB_ADC_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            pub fn rb_adc_if_end_adc(&self) -> RB_ADC_IF_END_ADC_R {
                RB_ADC_IF_END_ADC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_if_dma_end(&mut self) -> RB_ADC_IF_DMA_END_W<3> {
                RB_ADC_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn rb_adc_if_end_adc(&mut self) -> RB_ADC_IF_END_ADC_W<4> {
                RB_ADC_IF_END_ADC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_dma_if](index.html) module
        pub struct R8_ADC_DMA_IF_SPEC;
        impl crate::RegisterSpec for R8_ADC_DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_dma_if::R](R) reader structure
        impl crate::Readable for R8_ADC_DMA_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_dma_if::W](W) writer structure
        impl crate::Writable for R8_ADC_DMA_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_DMA_IF to value 0
        impl crate::Resettable for R8_ADC_DMA_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_ADC_AUTO_CYCLE (rw) register accessor: an alias for `Reg<R8_ADC_AUTO_CYCLE_SPEC>`
    pub type R8_ADC_AUTO_CYCLE = crate::Reg<r8_adc_auto_cycle::R8_ADC_AUTO_CYCLE_SPEC>;
    ///RO, ADC interrupt flag
    pub mod r8_adc_auto_cycle {
        ///Register `R8_ADC_AUTO_CYCLE` reader
        pub struct R(crate::R<R8_ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_ADC_AUTO_CYCLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_ADC_AUTO_CYCLE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_ADC_AUTO_CYCLE` writer
        pub struct W(crate::W<R8_ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_ADC_AUTO_CYCLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_ADC_AUTO_CYCLE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_ADC_AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys
        pub type R8_ADC_AUTO_CYCLE_R = crate::FieldReader<u8, u8>;
        ///Field `R8_ADC_AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys
        pub type R8_ADC_AUTO_CYCLE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_ADC_AUTO_CYCLE_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            pub fn r8_adc_auto_cycle(&self) -> R8_ADC_AUTO_CYCLE_R {
                R8_ADC_AUTO_CYCLE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            #[must_use]
            pub fn r8_adc_auto_cycle(&mut self) -> R8_ADC_AUTO_CYCLE_W<0> {
                R8_ADC_AUTO_CYCLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_adc_auto_cycle](index.html) module
        pub struct R8_ADC_AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for R8_ADC_AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_adc_auto_cycle::R](R) reader structure
        impl crate::Readable for R8_ADC_AUTO_CYCLE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_adc_auto_cycle::W](W) writer structure
        impl crate::Writable for R8_ADC_AUTO_CYCLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_ADC_AUTO_CYCLE to value 0
        impl crate::Resettable for R8_ADC_AUTO_CYCLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_ADC_DMA_NOW (r) register accessor: an alias for `Reg<R16_ADC_DMA_NOW_SPEC>`
    pub type R16_ADC_DMA_NOW = crate::Reg<r16_adc_dma_now::R16_ADC_DMA_NOW_SPEC>;
    ///RO, ADC DMA current address
    pub mod r16_adc_dma_now {
        ///Register `R16_ADC_DMA_NOW` reader
        pub struct R(crate::R<R16_ADC_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_ADC_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_ADC_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_ADC_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R16_ADC_DMA_NOW` reader - ADC DMA current address
        pub type R16_ADC_DMA_NOW_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA current address
            #[inline(always)]
            pub fn r16_adc_dma_now(&self) -> R16_ADC_DMA_NOW_R {
                R16_ADC_DMA_NOW_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///RO, ADC DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_adc_dma_now](index.html) module
        pub struct R16_ADC_DMA_NOW_SPEC;
        impl crate::RegisterSpec for R16_ADC_DMA_NOW_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r16_adc_dma_now::R](R) reader structure
        impl crate::Readable for R16_ADC_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_ADC_DMA_NOW to value 0
        impl crate::Resettable for R16_ADC_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_ADC_DMA_BEG (rw) register accessor: an alias for `Reg<R16_ADC_DMA_BEG_SPEC>`
    pub type R16_ADC_DMA_BEG = crate::Reg<r16_adc_dma_beg::R16_ADC_DMA_BEG_SPEC>;
    ///RW, ADC DMA begin address
    pub mod r16_adc_dma_beg {
        ///Register `R16_ADC_DMA_BEG` reader
        pub struct R(crate::R<R16_ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_ADC_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_ADC_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_ADC_DMA_BEG` writer
        pub struct W(crate::W<R16_ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_ADC_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_ADC_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_ADC_DMA_BEG` reader - ADC DMA begin address
        pub type R16_ADC_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `R16_ADC_DMA_BEG` writer - ADC DMA begin address
        pub type R16_ADC_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R16_ADC_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            pub fn r16_adc_dma_beg(&self) -> R16_ADC_DMA_BEG_R {
                R16_ADC_DMA_BEG_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn r16_adc_dma_beg(&mut self) -> R16_ADC_DMA_BEG_W<0> {
                R16_ADC_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_adc_dma_beg](index.html) module
        pub struct R16_ADC_DMA_BEG_SPEC;
        impl crate::RegisterSpec for R16_ADC_DMA_BEG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r16_adc_dma_beg::R](R) reader structure
        impl crate::Readable for R16_ADC_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_adc_dma_beg::W](W) writer structure
        impl crate::Writable for R16_ADC_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_ADC_DMA_BEG to value 0
        impl crate::Resettable for R16_ADC_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_ADC_DMA_END (rw) register accessor: an alias for `Reg<R16_ADC_DMA_END_SPEC>`
    pub type R16_ADC_DMA_END = crate::Reg<r16_adc_dma_end::R16_ADC_DMA_END_SPEC>;
    ///RW, ADC DMA end address
    pub mod r16_adc_dma_end {
        ///Register `R16_ADC_DMA_END` reader
        pub struct R(crate::R<R16_ADC_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_ADC_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_ADC_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_ADC_DMA_END` writer
        pub struct W(crate::W<R16_ADC_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_ADC_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_ADC_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_ADC_DMA_END` reader - ADC DMA end address
        pub type R16_ADC_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `R16_ADC_DMA_END` writer - ADC DMA end address
        pub type R16_ADC_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R16_ADC_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            pub fn r16_adc_dma_end(&self) -> R16_ADC_DMA_END_R {
                R16_ADC_DMA_END_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            #[must_use]
            pub fn r16_adc_dma_end(&mut self) -> R16_ADC_DMA_END_W<0> {
                R16_ADC_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_adc_dma_end](index.html) module
        pub struct R16_ADC_DMA_END_SPEC;
        impl crate::RegisterSpec for R16_ADC_DMA_END_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r16_adc_dma_end::R](R) reader structure
        impl crate::Readable for R16_ADC_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_adc_dma_end::W](W) writer structure
        impl crate::Writable for R16_ADC_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_ADC_DMA_END to value 0
        impl crate::Resettable for R16_ADC_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PA_INT_EN (rw) register accessor: an alias for `Reg<R16_PA_INT_EN_SPEC>`
    pub type R16_PA_INT_EN = crate::Reg<r16_pa_int_en::R16_PA_INT_EN_SPEC>;
    ///RW, GPIO PA interrupt enable
    pub mod r16_pa_int_en {
        ///Register `R16_PA_INT_EN` reader
        pub struct R(crate::R<R16_PA_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PA_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PA_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PA_INT_EN` writer
        pub struct W(crate::W<R16_PA_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PA_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PA_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PA_INT_EN` reader - GPIO PA interrupt enable
        pub type R16_PA_INT_EN_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PA_INT_EN` writer - GPIO PA interrupt enable
        pub type R16_PA_INT_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PA_INT_EN_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            pub fn r16_pa_int_en(&self) -> R16_PA_INT_EN_R {
                R16_PA_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn r16_pa_int_en(&mut self) -> R16_PA_INT_EN_W<0> {
                R16_PA_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pa_int_en](index.html) module
        pub struct R16_PA_INT_EN_SPEC;
        impl crate::RegisterSpec for R16_PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pa_int_en::R](R) reader structure
        impl crate::Readable for R16_PA_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pa_int_en::W](W) writer structure
        impl crate::Writable for R16_PA_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PA_INT_EN to value 0
        impl crate::Resettable for R16_PA_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PB_INT_EN (rw) register accessor: an alias for `Reg<R16_PB_INT_EN_SPEC>`
    pub type R16_PB_INT_EN = crate::Reg<r16_pb_int_en::R16_PB_INT_EN_SPEC>;
    ///RW, GPIO PB interrupt enable
    pub mod r16_pb_int_en {
        ///Register `R16_PB_INT_EN` reader
        pub struct R(crate::R<R16_PB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PB_INT_EN` writer
        pub struct W(crate::W<R16_PB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PB_INT_EN` reader - GPIO PB interrupt enable
        pub type R16_PB_INT_EN_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PB_INT_EN` writer - GPIO PB interrupt enable
        pub type R16_PB_INT_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PB_INT_EN_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            pub fn r16_pb_int_en(&self) -> R16_PB_INT_EN_R {
                R16_PB_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn r16_pb_int_en(&mut self) -> R16_PB_INT_EN_W<0> {
                R16_PB_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pb_int_en](index.html) module
        pub struct R16_PB_INT_EN_SPEC;
        impl crate::RegisterSpec for R16_PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pb_int_en::R](R) reader structure
        impl crate::Readable for R16_PB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pb_int_en::W](W) writer structure
        impl crate::Writable for R16_PB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PB_INT_EN to value 0
        impl crate::Resettable for R16_PB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PA_INT_MODE (rw) register accessor: an alias for `Reg<R16_PA_INT_MODE_SPEC>`
    pub type R16_PA_INT_MODE = crate::Reg<r16_pa_int_mode::R16_PA_INT_MODE_SPEC>;
    ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    pub mod r16_pa_int_mode {
        ///Register `R16_PA_INT_MODE` reader
        pub struct R(crate::R<R16_PA_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PA_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PA_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PA_INT_MODE` writer
        pub struct W(crate::W<R16_PA_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PA_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PA_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PA_INT_MODE` reader - GPIO PA interrupt mode
        pub type R16_PA_INT_MODE_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PA_INT_MODE` writer - GPIO PA interrupt mode
        pub type R16_PA_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PA_INT_MODE_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            pub fn r16_pa_int_mode(&self) -> R16_PA_INT_MODE_R {
                R16_PA_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn r16_pa_int_mode(&mut self) -> R16_PA_INT_MODE_W<0> {
                R16_PA_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pa_int_mode](index.html) module
        pub struct R16_PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for R16_PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pa_int_mode::R](R) reader structure
        impl crate::Readable for R16_PA_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pa_int_mode::W](W) writer structure
        impl crate::Writable for R16_PA_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PA_INT_MODE to value 0
        impl crate::Resettable for R16_PA_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PB_INT_MODE (rw) register accessor: an alias for `Reg<R16_PB_INT_MODE_SPEC>`
    pub type R16_PB_INT_MODE = crate::Reg<r16_pb_int_mode::R16_PB_INT_MODE_SPEC>;
    ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    pub mod r16_pb_int_mode {
        ///Register `R16_PB_INT_MODE` reader
        pub struct R(crate::R<R16_PB_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PB_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PB_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PB_INT_MODE` writer
        pub struct W(crate::W<R16_PB_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PB_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PB_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PB_INT_MODE` reader - GPIO PB interrupt mode
        pub type R16_PB_INT_MODE_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PB_INT_MODE` writer - GPIO PB interrupt mode
        pub type R16_PB_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PB_INT_MODE_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            pub fn r16_pb_int_mode(&self) -> R16_PB_INT_MODE_R {
                R16_PB_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn r16_pb_int_mode(&mut self) -> R16_PB_INT_MODE_W<0> {
                R16_PB_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pb_int_mode](index.html) module
        pub struct R16_PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for R16_PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pb_int_mode::R](R) reader structure
        impl crate::Readable for R16_PB_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pb_int_mode::W](W) writer structure
        impl crate::Writable for R16_PB_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PB_INT_MODE to value 0
        impl crate::Resettable for R16_PB_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PA_INT_IF (rw) register accessor: an alias for `Reg<R16_PA_INT_IF_SPEC>`
    pub type R16_PA_INT_IF = crate::Reg<r16_pa_int_if::R16_PA_INT_IF_SPEC>;
    ///RW1, GPIO PA interrupt flag
    pub mod r16_pa_int_if {
        ///Register `R16_PA_INT_IF` reader
        pub struct R(crate::R<R16_PA_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PA_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PA_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PA_INT_IF` writer
        pub struct W(crate::W<R16_PA_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PA_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PA_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PA_INT_IF` reader - GPIO PA interrupt flag
        pub type R16_PA_INT_IF_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PA_INT_IF` writer - GPIO PA interrupt flag
        pub type R16_PA_INT_IF_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PA_INT_IF_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            pub fn r16_pa_int_if(&self) -> R16_PA_INT_IF_R {
                R16_PA_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn r16_pa_int_if(&mut self) -> R16_PA_INT_IF_W<0> {
                R16_PA_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PA interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pa_int_if](index.html) module
        pub struct R16_PA_INT_IF_SPEC;
        impl crate::RegisterSpec for R16_PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pa_int_if::R](R) reader structure
        impl crate::Readable for R16_PA_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pa_int_if::W](W) writer structure
        impl crate::Writable for R16_PA_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PA_INT_IF to value 0
        impl crate::Resettable for R16_PA_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_PB_INT_IF (rw) register accessor: an alias for `Reg<R16_PB_INT_IF_SPEC>`
    pub type R16_PB_INT_IF = crate::Reg<r16_pb_int_if::R16_PB_INT_IF_SPEC>;
    ///RW1, GPIO PB interrupt flag
    pub mod r16_pb_int_if {
        ///Register `R16_PB_INT_IF` reader
        pub struct R(crate::R<R16_PB_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_PB_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_PB_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_PB_INT_IF` writer
        pub struct W(crate::W<R16_PB_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_PB_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_PB_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_PB_INT_IF` reader - GPIO PB interrupt flag
        pub type R16_PB_INT_IF_R = crate::FieldReader<u16, u16>;
        ///Field `R16_PB_INT_IF` writer - GPIO PB interrupt flag
        pub type R16_PB_INT_IF_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_PB_INT_IF_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            pub fn r16_pb_int_if(&self) -> R16_PB_INT_IF_R {
                R16_PB_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn r16_pb_int_if(&mut self) -> R16_PB_INT_IF_W<0> {
                R16_PB_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_pb_int_if](index.html) module
        pub struct R16_PB_INT_IF_SPEC;
        impl crate::RegisterSpec for R16_PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_pb_int_if::R](R) reader structure
        impl crate::Readable for R16_PB_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_pb_int_if::W](W) writer structure
        impl crate::Writable for R16_PB_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_PB_INT_IF to value 0
        impl crate::Resettable for R16_PB_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_DIR (rw) register accessor: an alias for `Reg<R32_PA_DIR_SPEC>`
    pub type R32_PA_DIR = crate::Reg<r32_pa_dir::R32_PA_DIR_SPEC>;
    ///RW, GPIO PA I/O direction: 0=in, 1=out
    pub mod r32_pa_dir {
        ///Register `R32_PA_DIR` reader
        pub struct R(crate::R<R32_PA_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PA_DIR` writer
        pub struct W(crate::W<R32_PA_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PA_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PA_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PA_DIR_0` reader - GPIO PA I/O direction byte 0
        pub type R8_PA_DIR_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_DIR_0` writer - GPIO PA I/O direction byte 0
        pub type R8_PA_DIR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_DIR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PA_DIR_1` reader - GPIO PA I/O direction byte 1
        pub type R8_PA_DIR_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_DIR_1` writer - GPIO PA I/O direction byte 1
        pub type R8_PA_DIR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_DIR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            pub fn r8_pa_dir_0(&self) -> R8_PA_DIR_0_R {
                R8_PA_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            pub fn r8_pa_dir_1(&self) -> R8_PA_DIR_1_R {
                R8_PA_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_dir_0(&mut self) -> R8_PA_DIR_0_W<0> {
                R8_PA_DIR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_dir_1(&mut self) -> R8_PA_DIR_1_W<8> {
                R8_PA_DIR_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_dir](index.html) module
        pub struct R32_PA_DIR_SPEC;
        impl crate::RegisterSpec for R32_PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_dir::R](R) reader structure
        impl crate::Readable for R32_PA_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pa_dir::W](W) writer structure
        impl crate::Writable for R32_PA_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PA_DIR to value 0
        impl crate::Resettable for R32_PA_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_PIN (r) register accessor: an alias for `Reg<R32_PA_PIN_SPEC>`
    pub type R32_PA_PIN = crate::Reg<r32_pa_pin::R32_PA_PIN_SPEC>;
    ///RO, GPIO PA input
    pub mod r32_pa_pin {
        ///Register `R32_PA_PIN` reader
        pub struct R(crate::R<R32_PA_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_PA_PIN_0` reader - GPIO PA input byte 0
        pub type R8_PA_PIN_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_PIN_1` reader - GPIO PA input byte 1
        pub type R8_PA_PIN_1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - GPIO PA input byte 0
            #[inline(always)]
            pub fn r8_pa_pin_0(&self) -> R8_PA_PIN_0_R {
                R8_PA_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA input byte 1
            #[inline(always)]
            pub fn r8_pa_pin_1(&self) -> R8_PA_PIN_1_R {
                R8_PA_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///RO, GPIO PA input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_pin](index.html) module
        pub struct R32_PA_PIN_SPEC;
        impl crate::RegisterSpec for R32_PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_pin::R](R) reader structure
        impl crate::Readable for R32_PA_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PA_PIN to value 0
        impl crate::Resettable for R32_PA_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_OUT (rw) register accessor: an alias for `Reg<R32_PA_OUT_SPEC>`
    pub type R32_PA_OUT = crate::Reg<r32_pa_out::R32_PA_OUT_SPEC>;
    ///RW, GPIO PA output
    pub mod r32_pa_out {
        ///Register `R32_PA_OUT` reader
        pub struct R(crate::R<R32_PA_OUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_OUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_OUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PA_OUT` writer
        pub struct W(crate::W<R32_PA_OUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PA_OUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PA_OUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PA_OUT_0` reader - GPIO PA output byte 0
        pub type R8_PA_OUT_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_OUT_0` writer - GPIO PA output byte 0
        pub type R8_PA_OUT_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_OUT_SPEC, u8, u8, 8, O>;
        ///Field `R8_PA_OUT_1` reader - GPIO PA output byte 1
        pub type R8_PA_OUT_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_OUT_1` writer - GPIO PA output byte 1
        pub type R8_PA_OUT_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_OUT_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            pub fn r8_pa_out_0(&self) -> R8_PA_OUT_0_R {
                R8_PA_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            pub fn r8_pa_out_1(&self) -> R8_PA_OUT_1_R {
                R8_PA_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_out_0(&mut self) -> R8_PA_OUT_0_W<0> {
                R8_PA_OUT_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_out_1(&mut self) -> R8_PA_OUT_1_W<8> {
                R8_PA_OUT_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_out](index.html) module
        pub struct R32_PA_OUT_SPEC;
        impl crate::RegisterSpec for R32_PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_out::R](R) reader structure
        impl crate::Readable for R32_PA_OUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pa_out::W](W) writer structure
        impl crate::Writable for R32_PA_OUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PA_OUT to value 0
        impl crate::Resettable for R32_PA_OUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_CLR (rw) register accessor: an alias for `Reg<R32_PA_CLR_SPEC>`
    pub type R32_PA_CLR = crate::Reg<r32_pa_clr::R32_PA_CLR_SPEC>;
    ///WZ, GPIO PA clear output: 0=keep, 1=clear
    pub mod r32_pa_clr {
        ///Register `R32_PA_CLR` reader
        pub struct R(crate::R<R32_PA_CLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_CLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_CLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PA_CLR` writer
        pub struct W(crate::W<R32_PA_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PA_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PA_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PA_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PA_CLR_0` reader - GPIO PA clear output byte 0
        pub type R8_PA_CLR_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_CLR_0` writer - GPIO PA clear output byte 0
        pub type R8_PA_CLR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_CLR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PA_CLR_1` reader - GPIO PA clear output byte 1
        pub type R8_PA_CLR_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_CLR_1` writer - GPIO PA clear output byte 1
        pub type R8_PA_CLR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_CLR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            pub fn r8_pa_clr_0(&self) -> R8_PA_CLR_0_R {
                R8_PA_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            pub fn r8_pa_clr_1(&self) -> R8_PA_CLR_1_R {
                R8_PA_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_clr_0(&mut self) -> R8_PA_CLR_0_W<0> {
                R8_PA_CLR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_clr_1(&mut self) -> R8_PA_CLR_1_W<8> {
                R8_PA_CLR_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PA clear output: 0=keep, 1=clear
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_clr](index.html) module
        pub struct R32_PA_CLR_SPEC;
        impl crate::RegisterSpec for R32_PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_clr::R](R) reader structure
        impl crate::Readable for R32_PA_CLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pa_clr::W](W) writer structure
        impl crate::Writable for R32_PA_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PA_CLR to value 0
        impl crate::Resettable for R32_PA_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_PU (rw) register accessor: an alias for `Reg<R32_PA_PU_SPEC>`
    pub type R32_PA_PU = crate::Reg<r32_pa_pu::R32_PA_PU_SPEC>;
    ///RW, GPIO PA pullup resistance enable
    pub mod r32_pa_pu {
        ///Register `R32_PA_PU` reader
        pub struct R(crate::R<R32_PA_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PA_PU` writer
        pub struct W(crate::W<R32_PA_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PA_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PA_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PA_PU_0` reader - GPIO PA pullup resistance enable byte 0
        pub type R8_PA_PU_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_PU_0` writer - GPIO PA pullup resistance enable byte 0
        pub type R8_PA_PU_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_PU_SPEC, u8, u8, 8, O>;
        ///Field `R8_PA_PU_1` reader - GPIO PA pullup resistance enable byte 0
        pub type R8_PA_PU_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_PU_1` writer - GPIO PA pullup resistance enable byte 0
        pub type R8_PA_PU_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_PU_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn r8_pa_pu_0(&self) -> R8_PA_PU_0_R {
                R8_PA_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn r8_pa_pu_1(&self) -> R8_PA_PU_1_R {
                R8_PA_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_pu_0(&mut self) -> R8_PA_PU_0_W<0> {
                R8_PA_PU_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_pu_1(&mut self) -> R8_PA_PU_1_W<8> {
                R8_PA_PU_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_pu](index.html) module
        pub struct R32_PA_PU_SPEC;
        impl crate::RegisterSpec for R32_PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_pu::R](R) reader structure
        impl crate::Readable for R32_PA_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pa_pu::W](W) writer structure
        impl crate::Writable for R32_PA_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PA_PU to value 0
        impl crate::Resettable for R32_PA_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PA_PD_DRV (rw) register accessor: an alias for `Reg<R32_PA_PD_DRV_SPEC>`
    pub type R32_PA_PD_DRV = crate::Reg<r32_pa_pd_drv::R32_PA_PD_DRV_SPEC>;
    ///RW, PA pulldown for input or PA driving capability for output
    pub mod r32_pa_pd_drv {
        ///Register `R32_PA_PD_DRV` reader
        pub struct R(crate::R<R32_PA_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PA_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PA_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PA_PD_DRV` writer
        pub struct W(crate::W<R32_PA_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PA_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PA_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PA_PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0
        pub type R8_PA_PD_DRV_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0
        pub type R8_PA_PD_DRV_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `R8_PA_PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1
        pub type R8_PA_PD_DRV_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PA_PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1
        pub type R8_PA_PD_DRV_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PA_PD_DRV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            pub fn r8_pa_pd_drv_0(&self) -> R8_PA_PD_DRV_0_R {
                R8_PA_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            pub fn r8_pa_pd_drv_1(&self) -> R8_PA_PD_DRV_1_R {
                R8_PA_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_pd_drv_0(&mut self) -> R8_PA_PD_DRV_0_W<0> {
                R8_PA_PD_DRV_0_W::new(self)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pa_pd_drv_1(&mut self) -> R8_PA_PD_DRV_1_W<8> {
                R8_PA_PD_DRV_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PA pulldown for input or PA driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pa_pd_drv](index.html) module
        pub struct R32_PA_PD_DRV_SPEC;
        impl crate::RegisterSpec for R32_PA_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pa_pd_drv::R](R) reader structure
        impl crate::Readable for R32_PA_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pa_pd_drv::W](W) writer structure
        impl crate::Writable for R32_PA_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PA_PD_DRV to value 0
        impl crate::Resettable for R32_PA_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_DIR (rw) register accessor: an alias for `Reg<R32_PB_DIR_SPEC>`
    pub type R32_PB_DIR = crate::Reg<r32_pb_dir::R32_PB_DIR_SPEC>;
    ///RW, GPIO PB I/O direction: 0=in, 1=out
    pub mod r32_pb_dir {
        ///Register `R32_PB_DIR` reader
        pub struct R(crate::R<R32_PB_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PB_DIR` writer
        pub struct W(crate::W<R32_PB_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PB_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PB_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PB_DIR_0` reader - GPIO PB I/O direction byte 0
        pub type R8_PB_DIR_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_DIR_0` writer - GPIO PB I/O direction byte 0
        pub type R8_PB_DIR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_DIR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_DIR_1` reader - GPIO PB I/O direction byte 1
        pub type R8_PB_DIR_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_DIR_1` writer - GPIO PB I/O direction byte 1
        pub type R8_PB_DIR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_DIR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_DIR_2` reader - GPIO PB I/O direction byte 2
        pub type R8_PB_DIR_2_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_DIR_2` writer - GPIO PB I/O direction byte 2
        pub type R8_PB_DIR_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_DIR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            pub fn r8_pb_dir_0(&self) -> R8_PB_DIR_0_R {
                R8_PB_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            pub fn r8_pb_dir_1(&self) -> R8_PB_DIR_1_R {
                R8_PB_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            pub fn r8_pb_dir_2(&self) -> R8_PB_DIR_2_R {
                R8_PB_DIR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_dir_0(&mut self) -> R8_PB_DIR_0_W<0> {
                R8_PB_DIR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_dir_1(&mut self) -> R8_PB_DIR_1_W<8> {
                R8_PB_DIR_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_dir_2(&mut self) -> R8_PB_DIR_2_W<16> {
                R8_PB_DIR_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_dir](index.html) module
        pub struct R32_PB_DIR_SPEC;
        impl crate::RegisterSpec for R32_PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_dir::R](R) reader structure
        impl crate::Readable for R32_PB_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pb_dir::W](W) writer structure
        impl crate::Writable for R32_PB_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PB_DIR to value 0
        impl crate::Resettable for R32_PB_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_PIN (r) register accessor: an alias for `Reg<R32_PB_PIN_SPEC>`
    pub type R32_PB_PIN = crate::Reg<r32_pb_pin::R32_PB_PIN_SPEC>;
    ///RO, GPIO PB input
    pub mod r32_pb_pin {
        ///Register `R32_PB_PIN` reader
        pub struct R(crate::R<R32_PB_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_PB_PIN_0` reader - GPIO PB input byte 0
        pub type R8_PB_PIN_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PIN_1` reader - GPIO PB input byte 1
        pub type R8_PB_PIN_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PIN_2` reader - GPIO PB input byte 2
        pub type R8_PB_PIN_2_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - GPIO PB input byte 0
            #[inline(always)]
            pub fn r8_pb_pin_0(&self) -> R8_PB_PIN_0_R {
                R8_PB_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB input byte 1
            #[inline(always)]
            pub fn r8_pb_pin_1(&self) -> R8_PB_PIN_1_R {
                R8_PB_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB input byte 2
            #[inline(always)]
            pub fn r8_pb_pin_2(&self) -> R8_PB_PIN_2_R {
                R8_PB_PIN_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///RO, GPIO PB input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_pin](index.html) module
        pub struct R32_PB_PIN_SPEC;
        impl crate::RegisterSpec for R32_PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_pin::R](R) reader structure
        impl crate::Readable for R32_PB_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PB_PIN to value 0
        impl crate::Resettable for R32_PB_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_OUT__R8_SLV_RD_DATA (rw) register accessor: an alias for `Reg<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>`
    pub type R32_PB_OUT__R8_SLV_RD_DATA =
        crate::Reg<r32_pb_out__r8_slv_rd_data::R32_PB_OUT__R8_SLV_RD_DATA_SPEC>;
    ///RW, GPIO PB output;RW, data for parallel slave read
    pub mod r32_pb_out__r8_slv_rd_data {
        ///Register `R32_PB_OUT__R8_SLV_RD_DATA` reader
        pub struct R(crate::R<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PB_OUT__R8_SLV_RD_DATA` writer
        pub struct W(crate::W<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PB_OUT__R8_SLV_RD_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PB_OUT_0` reader - GPIO PB output byte 0
        pub type R8_PB_OUT_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_OUT_0` writer - GPIO PB output byte 0
        pub type R8_PB_OUT_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_OUT_1` reader - GPIO PB output byte 1
        pub type R8_PB_OUT_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_OUT_1` writer - GPIO PB output byte 1
        pub type R8_PB_OUT_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_OUT_2` reader - GPIO PB output byte 2
        pub type R8_PB_OUT_2_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_OUT_2` writer - GPIO PB output byte 2
        pub type R8_PB_OUT_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            pub fn r8_pb_out_0(&self) -> R8_PB_OUT_0_R {
                R8_PB_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            pub fn r8_pb_out_1(&self) -> R8_PB_OUT_1_R {
                R8_PB_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            pub fn r8_pb_out_2(&self) -> R8_PB_OUT_2_R {
                R8_PB_OUT_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_out_0(&mut self) -> R8_PB_OUT_0_W<0> {
                R8_PB_OUT_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_out_1(&mut self) -> R8_PB_OUT_1_W<8> {
                R8_PB_OUT_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_out_2(&mut self) -> R8_PB_OUT_2_W<16> {
                R8_PB_OUT_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB output;RW, data for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_out__r8_slv_rd_data](index.html) module
        pub struct R32_PB_OUT__R8_SLV_RD_DATA_SPEC;
        impl crate::RegisterSpec for R32_PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_out__r8_slv_rd_data::R](R) reader structure
        impl crate::Readable for R32_PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pb_out__r8_slv_rd_data::W](W) writer structure
        impl crate::Writable for R32_PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PB_OUT__R8_SLV_RD_DATA to value 0
        impl crate::Resettable for R32_PB_OUT__R8_SLV_RD_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_CLR (rw) register accessor: an alias for `Reg<R32_PB_CLR_SPEC>`
    pub type R32_PB_CLR = crate::Reg<r32_pb_clr::R32_PB_CLR_SPEC>;
    ///WZ, GPIO PB clear output: 0=keep, 1=clear
    pub mod r32_pb_clr {
        ///Register `R32_PB_CLR` reader
        pub struct R(crate::R<R32_PB_CLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_CLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_CLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PB_CLR` writer
        pub struct W(crate::W<R32_PB_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PB_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PB_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PB_CLR_0` reader - GPIO PB clear output byte 0
        pub type R8_PB_CLR_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_CLR_0` writer - GPIO PB clear output byte 0
        pub type R8_PB_CLR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_CLR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_CLR_1` reader - GPIO PB clear output byte 1
        pub type R8_PB_CLR_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_CLR_1` writer - GPIO PB clear output byte 1
        pub type R8_PB_CLR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_CLR_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_CLR_2` reader - GPIO PB clear output byte 2
        pub type R8_PB_CLR_2_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_CLR_2` writer - GPIO PB clear output byte 2
        pub type R8_PB_CLR_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_CLR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            pub fn r8_pb_clr_0(&self) -> R8_PB_CLR_0_R {
                R8_PB_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            pub fn r8_pb_clr_1(&self) -> R8_PB_CLR_1_R {
                R8_PB_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            pub fn r8_pb_clr_2(&self) -> R8_PB_CLR_2_R {
                R8_PB_CLR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_clr_0(&mut self) -> R8_PB_CLR_0_W<0> {
                R8_PB_CLR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_clr_1(&mut self) -> R8_PB_CLR_1_W<8> {
                R8_PB_CLR_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_clr_2(&mut self) -> R8_PB_CLR_2_W<16> {
                R8_PB_CLR_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PB clear output: 0=keep, 1=clear
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_clr](index.html) module
        pub struct R32_PB_CLR_SPEC;
        impl crate::RegisterSpec for R32_PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_clr::R](R) reader structure
        impl crate::Readable for R32_PB_CLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pb_clr::W](W) writer structure
        impl crate::Writable for R32_PB_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PB_CLR to value 0
        impl crate::Resettable for R32_PB_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_PU (rw) register accessor: an alias for `Reg<R32_PB_PU_SPEC>`
    pub type R32_PB_PU = crate::Reg<r32_pb_pu::R32_PB_PU_SPEC>;
    ///RW, GPIO PB pullup resistance enable
    pub mod r32_pb_pu {
        ///Register `R32_PB_PU` reader
        pub struct R(crate::R<R32_PB_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PB_PU` writer
        pub struct W(crate::W<R32_PB_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PB_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PB_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PB_PU_0` reader - GPIO PB pullup resistance enable byte 0
        pub type R8_PB_PU_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PU_0` writer - GPIO PB pullup resistance enable byte 0
        pub type R8_PB_PU_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PU_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_PU_1` reader - GPIO PB pullup resistance enable byte 1
        pub type R8_PB_PU_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PU_1` writer - GPIO PB pullup resistance enable byte 1
        pub type R8_PB_PU_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PU_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_PU_2` reader - GPIO PB pullup resistance enable byte 2
        pub type R8_PB_PU_2_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PU_2` writer - GPIO PB pullup resistance enable byte 2
        pub type R8_PB_PU_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PU_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            pub fn r8_pb_pu_0(&self) -> R8_PB_PU_0_R {
                R8_PB_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            pub fn r8_pb_pu_1(&self) -> R8_PB_PU_1_R {
                R8_PB_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            pub fn r8_pb_pu_2(&self) -> R8_PB_PU_2_R {
                R8_PB_PU_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pu_0(&mut self) -> R8_PB_PU_0_W<0> {
                R8_PB_PU_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pu_1(&mut self) -> R8_PB_PU_1_W<8> {
                R8_PB_PU_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pu_2(&mut self) -> R8_PB_PU_2_W<16> {
                R8_PB_PU_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_pu](index.html) module
        pub struct R32_PB_PU_SPEC;
        impl crate::RegisterSpec for R32_PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_pu::R](R) reader structure
        impl crate::Readable for R32_PB_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pb_pu::W](W) writer structure
        impl crate::Writable for R32_PB_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PB_PU to value 0
        impl crate::Resettable for R32_PB_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PB_PD_DRV (rw) register accessor: an alias for `Reg<R32_PB_PD_DRV_SPEC>`
    pub type R32_PB_PD_DRV = crate::Reg<r32_pb_pd_drv::R32_PB_PD_DRV_SPEC>;
    ///RW, PB pulldown for input or PB driving capability for output
    pub mod r32_pb_pd_drv {
        ///Register `R32_PB_PD_DRV` reader
        pub struct R(crate::R<R32_PB_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PB_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PB_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PB_PD_DRV` writer
        pub struct W(crate::W<R32_PB_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PB_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PB_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PB_PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_0_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_1_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `R8_PB_PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_2_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PB_PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type R8_PB_PD_DRV_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PB_PD_DRV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn r8_pb_pd_drv_0(&self) -> R8_PB_PD_DRV_0_R {
                R8_PB_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn r8_pb_pd_drv_1(&self) -> R8_PB_PD_DRV_1_R {
                R8_PB_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn r8_pb_pd_drv_2(&self) -> R8_PB_PD_DRV_2_R {
                R8_PB_PD_DRV_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pd_drv_0(&mut self) -> R8_PB_PD_DRV_0_W<0> {
                R8_PB_PD_DRV_0_W::new(self)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pd_drv_1(&mut self) -> R8_PB_PD_DRV_1_W<8> {
                R8_PB_PD_DRV_1_W::new(self)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn r8_pb_pd_drv_2(&mut self) -> R8_PB_PD_DRV_2_W<16> {
                R8_PB_PD_DRV_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PB pulldown for input or PB driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pb_pd_drv](index.html) module
        pub struct R32_PB_PD_DRV_SPEC;
        impl crate::RegisterSpec for R32_PB_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pb_pd_drv::R](R) reader structure
        impl crate::Readable for R32_PB_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pb_pd_drv::W](W) writer structure
        impl crate::Writable for R32_PB_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PB_PD_DRV to value 0
        impl crate::Resettable for R32_PB_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///Timer0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR0 mode control
        pub r8_tmr0_ctrl_mod: R8_TMR0_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR0 interrupt enable
        pub r8_tmr0_inter_en: R8_TMR0_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR0 interrupt flag
        pub r8_tmr0_int_flag: R8_TMR0_INT_FLAG,
        ///0x07 - RO, TMR0 FIFO count status
        pub r8_tmr0_fifo_count: R8_TMR0_FIFO_COUNT,
        ///0x08 - RO, TMR0 current count
        pub r32_tmr0_count: R32_TMR0_COUNT,
        ///0x0c - RW, TMR0 end count value, only low 26 bit
        pub r32_tmr0_cnt_end: R32_TMR0_CNT_END,
        ///0x10 - RO/WO, TMR0 FIFO register, only low 26 bit
        pub r32_tmr0_fifo: R32_TMR0_FIFO,
    }
    ///R8_TMR0_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_TMR0_CTRL_MOD_SPEC>`
    pub type R8_TMR0_CTRL_MOD = crate::Reg<r8_tmr0_ctrl_mod::R8_TMR0_CTRL_MOD_SPEC>;
    ///RW, TMR0 mode control
    pub mod r8_tmr0_ctrl_mod {
        ///Register `R8_TMR0_CTRL_MOD` reader
        pub struct R(crate::R<R8_TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR0_CTRL_MOD` writer
        pub struct W(crate::W<R8_TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_COUNT_EN` reader - RW, timer count enable
        pub type RB_TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_COUNT_EN` writer - RW, timer count enable
        pub type RB_TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_EN` reader - RW, timer output enable
        pub type RB_TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_EN` writer - RW, timer output enable
        pub type RB_TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TMR0_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn rb_tmr_mode_in(&self) -> RB_TMR_MODE_IN_R {
                RB_TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn rb_tmr_all_clear(&self) -> RB_TMR_ALL_CLEAR_R {
                RB_TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn rb_tmr_count_en(&self) -> RB_TMR_COUNT_EN_R {
                RB_TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn rb_tmr_out_en(&self) -> RB_TMR_OUT_EN_R {
                RB_TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_mode_in(&mut self) -> RB_TMR_MODE_IN_W<0> {
                RB_TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_all_clear(&mut self) -> RB_TMR_ALL_CLEAR_W<1> {
                RB_TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_count_en(&mut self) -> RB_TMR_COUNT_EN_W<2> {
                RB_TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_en(&mut self) -> RB_TMR_OUT_EN_W<3> {
                RB_TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr0_ctrl_mod](index.html) module
        pub struct R8_TMR0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_TMR0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr0_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_TMR0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr0_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_TMR0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR0_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_TMR0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_TMR0_INTER_EN (rw) register accessor: an alias for `Reg<R8_TMR0_INTER_EN_SPEC>`
    pub type R8_TMR0_INTER_EN = crate::Reg<r8_tmr0_inter_en::R8_TMR0_INTER_EN_SPEC>;
    ///RW, TMR0 interrupt enable
    pub mod r8_tmr0_inter_en {
        ///Register `R8_TMR0_INTER_EN` reader
        pub struct R(crate::R<R8_TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR0_INTER_EN` writer
        pub struct W(crate::W<R8_TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_ie_cyc_end(&self) -> RB_TMR_IE_CYC_END_R {
                RB_TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_ie_data_act(&self) -> RB_TMR_IE_DATA_ACT_R {
                RB_TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_hf(&self) -> RB_TMR_IE_FIFO_HF_R {
                RB_TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_ie_dma_end(&self) -> RB_TMR_IE_DMA_END_R {
                RB_TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_ov(&self) -> RB_TMR_IE_FIFO_OV_R {
                RB_TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_cyc_end(&mut self) -> RB_TMR_IE_CYC_END_W<0> {
                RB_TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_data_act(&mut self) -> RB_TMR_IE_DATA_ACT_W<1> {
                RB_TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_hf(&mut self) -> RB_TMR_IE_FIFO_HF_W<2> {
                RB_TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_dma_end(&mut self) -> RB_TMR_IE_DMA_END_W<3> {
                RB_TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_ov(&mut self) -> RB_TMR_IE_FIFO_OV_W<4> {
                RB_TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr0_inter_en](index.html) module
        pub struct R8_TMR0_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_TMR0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr0_inter_en::R](R) reader structure
        impl crate::Readable for R8_TMR0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr0_inter_en::W](W) writer structure
        impl crate::Writable for R8_TMR0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR0_INTER_EN to value 0
        impl crate::Resettable for R8_TMR0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR0_INT_FLAG (rw) register accessor: an alias for `Reg<R8_TMR0_INT_FLAG_SPEC>`
    pub type R8_TMR0_INT_FLAG = crate::Reg<r8_tmr0_int_flag::R8_TMR0_INT_FLAG_SPEC>;
    ///RW1, TMR0 interrupt flag
    pub mod r8_tmr0_int_flag {
        ///Register `R8_TMR0_INT_FLAG` reader
        pub struct R(crate::R<R8_TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR0_INT_FLAG` writer
        pub struct W(crate::W<R8_TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR0_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_if_cyc_end(&self) -> RB_TMR_IF_CYC_END_R {
                RB_TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_if_data_act(&self) -> RB_TMR_IF_DATA_ACT_R {
                RB_TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn rb_tmr_if_fifo_hf(&self) -> RB_TMR_IF_FIFO_HF_R {
                RB_TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_if_dma_end(&self) -> RB_TMR_IF_DMA_END_R {
                RB_TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_if_fifo_ov(&self) -> RB_TMR_IF_FIFO_OV_R {
                RB_TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_cyc_end(&mut self) -> RB_TMR_IF_CYC_END_W<0> {
                RB_TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_data_act(&mut self) -> RB_TMR_IF_DATA_ACT_W<1> {
                RB_TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_hf(&mut self) -> RB_TMR_IF_FIFO_HF_W<2> {
                RB_TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_dma_end(&mut self) -> RB_TMR_IF_DMA_END_W<3> {
                RB_TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_ov(&mut self) -> RB_TMR_IF_FIFO_OV_W<4> {
                RB_TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr0_int_flag](index.html) module
        pub struct R8_TMR0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_TMR0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr0_int_flag::R](R) reader structure
        impl crate::Readable for R8_TMR0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr0_int_flag::W](W) writer structure
        impl crate::Writable for R8_TMR0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR0_INT_FLAG to value 0
        impl crate::Resettable for R8_TMR0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR0_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_TMR0_FIFO_COUNT_SPEC>`
    pub type R8_TMR0_FIFO_COUNT = crate::Reg<r8_tmr0_fifo_count::R8_TMR0_FIFO_COUNT_SPEC>;
    ///RO, TMR0 FIFO count status
    pub mod r8_tmr0_fifo_count {
        ///Register `R8_TMR0_FIFO_COUNT` reader
        pub struct R(crate::R<R8_TMR0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_TMR0_FIFO_COUNT` reader - RW1,TMR0 FIFO count status
        pub type R8_TMR0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RW1,TMR0 FIFO count status
            #[inline(always)]
            pub fn r8_tmr0_fifo_count(&self) -> R8_TMR0_FIFO_COUNT_R {
                R8_TMR0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr0_fifo_count](index.html) module
        pub struct R8_TMR0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_TMR0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr0_fifo_count::R](R) reader structure
        impl crate::Readable for R8_TMR0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_TMR0_FIFO_COUNT to value 0
        impl crate::Resettable for R8_TMR0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR0_COUNT (r) register accessor: an alias for `Reg<R32_TMR0_COUNT_SPEC>`
    pub type R32_TMR0_COUNT = crate::Reg<r32_tmr0_count::R32_TMR0_COUNT_SPEC>;
    ///RO, TMR0 current count
    pub mod r32_tmr0_count {
        ///Register `R32_TMR0_COUNT` reader
        pub struct R(crate::R<R32_TMR0_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR0_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR0_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR0_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR0_COUNT` reader - RW1,TMR0 current count
        pub type R32_TMR0_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 current count
            #[inline(always)]
            pub fn r32_tmr0_count(&self) -> R32_TMR0_COUNT_R {
                R32_TMR0_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr0_count](index.html) module
        pub struct R32_TMR0_COUNT_SPEC;
        impl crate::RegisterSpec for R32_TMR0_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr0_count::R](R) reader structure
        impl crate::Readable for R32_TMR0_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR0_COUNT to value 0
        impl crate::Resettable for R32_TMR0_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR0_CNT_END (rw) register accessor: an alias for `Reg<R32_TMR0_CNT_END_SPEC>`
    pub type R32_TMR0_CNT_END = crate::Reg<r32_tmr0_cnt_end::R32_TMR0_CNT_END_SPEC>;
    ///RW, TMR0 end count value, only low 26 bit
    pub mod r32_tmr0_cnt_end {
        ///Register `R32_TMR0_CNT_END` reader
        pub struct R(crate::R<R32_TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR0_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR0_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR0_CNT_END` writer
        pub struct W(crate::W<R32_TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR0_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR0_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR0_CNT_END` reader - RW1,TMR0 end count value
        pub type R32_TMR0_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR0_CNT_END` writer - RW1,TMR0 end count value
        pub type R32_TMR0_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR0_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            pub fn r32_tmr0_cnt_end(&self) -> R32_TMR0_CNT_END_R {
                R32_TMR0_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr0_cnt_end(&mut self) -> R32_TMR0_CNT_END_W<0> {
                R32_TMR0_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr0_cnt_end](index.html) module
        pub struct R32_TMR0_CNT_END_SPEC;
        impl crate::RegisterSpec for R32_TMR0_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr0_cnt_end::R](R) reader structure
        impl crate::Readable for R32_TMR0_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr0_cnt_end::W](W) writer structure
        impl crate::Writable for R32_TMR0_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR0_CNT_END to value 0
        impl crate::Resettable for R32_TMR0_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR0_FIFO (r) register accessor: an alias for `Reg<R32_TMR0_FIFO_SPEC>`
    pub type R32_TMR0_FIFO = crate::Reg<r32_tmr0_fifo::R32_TMR0_FIFO_SPEC>;
    ///RO/WO, TMR0 FIFO register, only low 26 bit
    pub mod r32_tmr0_fifo {
        ///Register `R32_TMR0_FIFO` reader
        pub struct R(crate::R<R32_TMR0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR0_FIFO` reader - RW1,TMR0 FIFO register
        pub type R32_TMR0_FIFO_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 FIFO register
            #[inline(always)]
            pub fn r32_tmr0_fifo(&self) -> R32_TMR0_FIFO_R {
                R32_TMR0_FIFO_R::new(self.bits)
            }
        }
        ///RO/WO, TMR0 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr0_fifo](index.html) module
        pub struct R32_TMR0_FIFO_SPEC;
        impl crate::RegisterSpec for R32_TMR0_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr0_fifo::R](R) reader structure
        impl crate::Readable for R32_TMR0_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR0_FIFO to value 0
        impl crate::Resettable for R32_TMR0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///Timer1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR1 mode control
        pub r8_tmr1_ctrl_mod: R8_TMR1_CTRL_MOD,
        ///0x01 - RW, TMR1 DMA control
        pub r8_tmr1_ctrl_dma: R8_TMR1_CTRL_DMA,
        ///0x02 - RW, TMR1 interrupt enable
        pub r8_tmr1_inter_en: R8_TMR1_INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR1 interrupt flag
        pub r8_tmr1_int_flag: R8_TMR1_INT_FLAG,
        ///0x07 - RO, TMR1 FIFO count status
        pub r8_tmr1_fifo_count: R8_TMR1_FIFO_COUNT,
        ///0x08 - RO, TMR1 current count
        pub r32_tmr1_count: R32_TMR1_COUNT,
        ///0x0c - RW, TMR1 end count value, only low 26 bit
        pub r32_tmr1_cnt_end: R32_TMR1_CNT_END,
        ///0x10 - RO, TMR1 FIFO register, only low 26 bit
        pub r32_tmr1_fifo: R32_TMR1_FIFO,
        ///0x14 - RO, TMR1 DMA current address
        pub r16_tmr1_dma_now: R16_TMR1_DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR1 DMA begin address
        pub r16_tmr1_dma_beg: R16_TMR1_DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR1 DMA end address
        pub r16_tmr1_dma_end: R16_TMR1_DMA_END,
    }
    ///R8_TMR1_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_TMR1_CTRL_MOD_SPEC>`
    pub type R8_TMR1_CTRL_MOD = crate::Reg<r8_tmr1_ctrl_mod::R8_TMR1_CTRL_MOD_SPEC>;
    ///RW, TMR1 mode control
    pub mod r8_tmr1_ctrl_mod {
        ///Register `R8_TMR1_CTRL_MOD` reader
        pub struct R(crate::R<R8_TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR1_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR1_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR1_CTRL_MOD` writer
        pub struct W(crate::W<R8_TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR1_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR1_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_COUNT_EN` reader - RW, timer count enable
        pub type RB_TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_COUNT_EN` writer - RW, timer count enable
        pub type RB_TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_EN` reader - RW, timer output enable
        pub type RB_TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_EN` writer - RW, timer output enable
        pub type RB_TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TMR1_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn rb_tmr_mode_in(&self) -> RB_TMR_MODE_IN_R {
                RB_TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn rb_tmr_all_clear(&self) -> RB_TMR_ALL_CLEAR_R {
                RB_TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn rb_tmr_count_en(&self) -> RB_TMR_COUNT_EN_R {
                RB_TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn rb_tmr_out_en(&self) -> RB_TMR_OUT_EN_R {
                RB_TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_mode_in(&mut self) -> RB_TMR_MODE_IN_W<0> {
                RB_TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_all_clear(&mut self) -> RB_TMR_ALL_CLEAR_W<1> {
                RB_TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_count_en(&mut self) -> RB_TMR_COUNT_EN_W<2> {
                RB_TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_en(&mut self) -> RB_TMR_OUT_EN_W<3> {
                RB_TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr1_ctrl_mod](index.html) module
        pub struct R8_TMR1_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_TMR1_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr1_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_TMR1_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr1_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_TMR1_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR1_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_TMR1_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_TMR1_CTRL_DMA (rw) register accessor: an alias for `Reg<R8_TMR1_CTRL_DMA_SPEC>`
    pub type R8_TMR1_CTRL_DMA = crate::Reg<r8_tmr1_ctrl_dma::R8_TMR1_CTRL_DMA_SPEC>;
    ///RW, TMR1 DMA control
    pub mod r8_tmr1_ctrl_dma {
        ///Register `R8_TMR1_CTRL_DMA` reader
        pub struct R(crate::R<R8_TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR1_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR1_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR1_CTRL_DMA` writer
        pub struct W(crate::W<R8_TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR1_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR1_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_DMA_ENABLE` reader - RW, timer1/2 DMA enable
        pub type RB_TMR_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `RB_TMR_DMA_ENABLE` writer - RW, timer1/2 DMA enable
        pub type RB_TMR_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_TMR_DMA_LOOP` reader - RW, timer1/2 DMA address loop enable
        pub type RB_TMR_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_TMR_DMA_LOOP` writer - RW, timer1/2 DMA address loop enable
        pub type RB_TMR_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            pub fn rb_tmr_dma_enable(&self) -> RB_TMR_DMA_ENABLE_R {
                RB_TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn rb_tmr_dma_loop(&self) -> RB_TMR_DMA_LOOP_R {
                RB_TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_dma_enable(&mut self) -> RB_TMR_DMA_ENABLE_W<0> {
                RB_TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_dma_loop(&mut self) -> RB_TMR_DMA_LOOP_W<2> {
                RB_TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr1_ctrl_dma](index.html) module
        pub struct R8_TMR1_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for R8_TMR1_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr1_ctrl_dma::R](R) reader structure
        impl crate::Readable for R8_TMR1_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr1_ctrl_dma::W](W) writer structure
        impl crate::Writable for R8_TMR1_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR1_CTRL_DMA to value 0
        impl crate::Resettable for R8_TMR1_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR1_INTER_EN (rw) register accessor: an alias for `Reg<R8_TMR1_INTER_EN_SPEC>`
    pub type R8_TMR1_INTER_EN = crate::Reg<r8_tmr1_inter_en::R8_TMR1_INTER_EN_SPEC>;
    ///RW, TMR1 interrupt enable
    pub mod r8_tmr1_inter_en {
        ///Register `R8_TMR1_INTER_EN` reader
        pub struct R(crate::R<R8_TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR1_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR1_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR1_INTER_EN` writer
        pub struct W(crate::W<R8_TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR1_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR1_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_ie_cyc_end(&self) -> RB_TMR_IE_CYC_END_R {
                RB_TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_ie_data_act(&self) -> RB_TMR_IE_DATA_ACT_R {
                RB_TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_hf(&self) -> RB_TMR_IE_FIFO_HF_R {
                RB_TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_ie_dma_end(&self) -> RB_TMR_IE_DMA_END_R {
                RB_TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_ov(&self) -> RB_TMR_IE_FIFO_OV_R {
                RB_TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_cyc_end(&mut self) -> RB_TMR_IE_CYC_END_W<0> {
                RB_TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_data_act(&mut self) -> RB_TMR_IE_DATA_ACT_W<1> {
                RB_TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_hf(&mut self) -> RB_TMR_IE_FIFO_HF_W<2> {
                RB_TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_dma_end(&mut self) -> RB_TMR_IE_DMA_END_W<3> {
                RB_TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_ov(&mut self) -> RB_TMR_IE_FIFO_OV_W<4> {
                RB_TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr1_inter_en](index.html) module
        pub struct R8_TMR1_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_TMR1_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr1_inter_en::R](R) reader structure
        impl crate::Readable for R8_TMR1_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr1_inter_en::W](W) writer structure
        impl crate::Writable for R8_TMR1_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR1_INTER_EN to value 0
        impl crate::Resettable for R8_TMR1_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR1_INT_FLAG (rw) register accessor: an alias for `Reg<R8_TMR1_INT_FLAG_SPEC>`
    pub type R8_TMR1_INT_FLAG = crate::Reg<r8_tmr1_int_flag::R8_TMR1_INT_FLAG_SPEC>;
    ///RW1, TMR1 interrupt flag
    pub mod r8_tmr1_int_flag {
        ///Register `R8_TMR1_INT_FLAG` reader
        pub struct R(crate::R<R8_TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR1_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR1_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR1_INT_FLAG` writer
        pub struct W(crate::W<R8_TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR1_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR1_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR1_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_if_cyc_end(&self) -> RB_TMR_IF_CYC_END_R {
                RB_TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_if_data_act(&self) -> RB_TMR_IF_DATA_ACT_R {
                RB_TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn rb_tmr_if_fifo_hf(&self) -> RB_TMR_IF_FIFO_HF_R {
                RB_TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_if_dma_end(&self) -> RB_TMR_IF_DMA_END_R {
                RB_TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_if_fifo_ov(&self) -> RB_TMR_IF_FIFO_OV_R {
                RB_TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_cyc_end(&mut self) -> RB_TMR_IF_CYC_END_W<0> {
                RB_TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_data_act(&mut self) -> RB_TMR_IF_DATA_ACT_W<1> {
                RB_TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_hf(&mut self) -> RB_TMR_IF_FIFO_HF_W<2> {
                RB_TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_dma_end(&mut self) -> RB_TMR_IF_DMA_END_W<3> {
                RB_TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_ov(&mut self) -> RB_TMR_IF_FIFO_OV_W<4> {
                RB_TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR1 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr1_int_flag](index.html) module
        pub struct R8_TMR1_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_TMR1_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr1_int_flag::R](R) reader structure
        impl crate::Readable for R8_TMR1_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr1_int_flag::W](W) writer structure
        impl crate::Writable for R8_TMR1_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR1_INT_FLAG to value 0
        impl crate::Resettable for R8_TMR1_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR1_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_TMR1_FIFO_COUNT_SPEC>`
    pub type R8_TMR1_FIFO_COUNT = crate::Reg<r8_tmr1_fifo_count::R8_TMR1_FIFO_COUNT_SPEC>;
    ///RO, TMR1 FIFO count status
    pub mod r8_tmr1_fifo_count {
        ///Register `R8_TMR1_FIFO_COUNT` reader
        pub struct R(crate::R<R8_TMR1_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR1_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR1_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR1_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_TMR1_FIFO_COUNT` reader - RW1, TMR1 FIFO count status
        pub type R8_TMR1_FIFO_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1, TMR1 FIFO count status
            #[inline(always)]
            pub fn r8_tmr1_fifo_count(&self) -> R8_TMR1_FIFO_COUNT_R {
                R8_TMR1_FIFO_COUNT_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        ///RO, TMR1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr1_fifo_count](index.html) module
        pub struct R8_TMR1_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_TMR1_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr1_fifo_count::R](R) reader structure
        impl crate::Readable for R8_TMR1_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_TMR1_FIFO_COUNT to value 0
        impl crate::Resettable for R8_TMR1_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR1_COUNT (r) register accessor: an alias for `Reg<R32_TMR1_COUNT_SPEC>`
    pub type R32_TMR1_COUNT = crate::Reg<r32_tmr1_count::R32_TMR1_COUNT_SPEC>;
    ///RO, TMR1 current count
    pub mod r32_tmr1_count {
        ///Register `R32_TMR1_COUNT` reader
        pub struct R(crate::R<R32_TMR1_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR1_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR1_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR1_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR1_COUNT` reader - RW1,TMR1 current count
        pub type R32_TMR1_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 current count
            #[inline(always)]
            pub fn r32_tmr1_count(&self) -> R32_TMR1_COUNT_R {
                R32_TMR1_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr1_count](index.html) module
        pub struct R32_TMR1_COUNT_SPEC;
        impl crate::RegisterSpec for R32_TMR1_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr1_count::R](R) reader structure
        impl crate::Readable for R32_TMR1_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR1_COUNT to value 0
        impl crate::Resettable for R32_TMR1_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR1_CNT_END (rw) register accessor: an alias for `Reg<R32_TMR1_CNT_END_SPEC>`
    pub type R32_TMR1_CNT_END = crate::Reg<r32_tmr1_cnt_end::R32_TMR1_CNT_END_SPEC>;
    ///RW, TMR1 end count value, only low 26 bit
    pub mod r32_tmr1_cnt_end {
        ///Register `R32_TMR1_CNT_END` reader
        pub struct R(crate::R<R32_TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR1_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR1_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR1_CNT_END` writer
        pub struct W(crate::W<R32_TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR1_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR1_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR1_CNT_END` reader - RW1,TMR1 end count value,
        pub type R32_TMR1_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR1_CNT_END` writer - RW1,TMR1 end count value,
        pub type R32_TMR1_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR1_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            pub fn r32_tmr1_cnt_end(&self) -> R32_TMR1_CNT_END_R {
                R32_TMR1_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr1_cnt_end(&mut self) -> R32_TMR1_CNT_END_W<0> {
                R32_TMR1_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr1_cnt_end](index.html) module
        pub struct R32_TMR1_CNT_END_SPEC;
        impl crate::RegisterSpec for R32_TMR1_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr1_cnt_end::R](R) reader structure
        impl crate::Readable for R32_TMR1_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr1_cnt_end::W](W) writer structure
        impl crate::Writable for R32_TMR1_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR1_CNT_END to value 0
        impl crate::Resettable for R32_TMR1_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR1_FIFO (r) register accessor: an alias for `Reg<R32_TMR1_FIFO_SPEC>`
    pub type R32_TMR1_FIFO = crate::Reg<r32_tmr1_fifo::R32_TMR1_FIFO_SPEC>;
    ///RO, TMR1 FIFO register, only low 26 bit
    pub mod r32_tmr1_fifo {
        ///Register `R32_TMR1_FIFO` reader
        pub struct R(crate::R<R32_TMR1_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR1_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR1_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR1_FIFO` reader - RW1,TMR1 FIFO register
        pub type R32_TMR1_FIFO_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn r32_tmr1_fifo(&self) -> R32_TMR1_FIFO_R {
                R32_TMR1_FIFO_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr1_fifo](index.html) module
        pub struct R32_TMR1_FIFO_SPEC;
        impl crate::RegisterSpec for R32_TMR1_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr1_fifo::R](R) reader structure
        impl crate::Readable for R32_TMR1_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR1_FIFO to value 0
        impl crate::Resettable for R32_TMR1_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR1_DMA_NOW (r) register accessor: an alias for `Reg<R16_TMR1_DMA_NOW_SPEC>`
    pub type R16_TMR1_DMA_NOW = crate::Reg<r16_tmr1_dma_now::R16_TMR1_DMA_NOW_SPEC>;
    ///RO, TMR1 DMA current address
    pub mod r16_tmr1_dma_now {
        ///Register `R16_TMR1_DMA_NOW` reader
        pub struct R(crate::R<R16_TMR1_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR1_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR1_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR1_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R16_TMR1_DMA_NOW` reader - RW1,TMR1 FIFO register
        pub type R16_TMR1_DMA_NOW_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn r16_tmr1_dma_now(&self) -> R16_TMR1_DMA_NOW_R {
                R16_TMR1_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR1 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr1_dma_now](index.html) module
        pub struct R16_TMR1_DMA_NOW_SPEC;
        impl crate::RegisterSpec for R16_TMR1_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr1_dma_now::R](R) reader structure
        impl crate::Readable for R16_TMR1_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_TMR1_DMA_NOW to value 0
        impl crate::Resettable for R16_TMR1_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR1_DMA_BEG (rw) register accessor: an alias for `Reg<R16_TMR1_DMA_BEG_SPEC>`
    pub type R16_TMR1_DMA_BEG = crate::Reg<r16_tmr1_dma_beg::R16_TMR1_DMA_BEG_SPEC>;
    ///RW, TMR1 DMA begin address
    pub mod r16_tmr1_dma_beg {
        ///Register `R16_TMR1_DMA_BEG` reader
        pub struct R(crate::R<R16_TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR1_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR1_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_TMR1_DMA_BEG` writer
        pub struct W(crate::W<R16_TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_TMR1_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_TMR1_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_TMR1_DMA_BEG` reader - RW1,TMR1 FIFO register
        pub type R16_TMR1_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `R16_TMR1_DMA_BEG` writer - RW1,TMR1 FIFO register
        pub type R16_TMR1_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_TMR1_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn r16_tmr1_dma_beg(&self) -> R16_TMR1_DMA_BEG_R {
                R16_TMR1_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn r16_tmr1_dma_beg(&mut self) -> R16_TMR1_DMA_BEG_W<0> {
                R16_TMR1_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr1_dma_beg](index.html) module
        pub struct R16_TMR1_DMA_BEG_SPEC;
        impl crate::RegisterSpec for R16_TMR1_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr1_dma_beg::R](R) reader structure
        impl crate::Readable for R16_TMR1_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_tmr1_dma_beg::W](W) writer structure
        impl crate::Writable for R16_TMR1_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_TMR1_DMA_BEG to value 0
        impl crate::Resettable for R16_TMR1_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR1_DMA_END (rw) register accessor: an alias for `Reg<R16_TMR1_DMA_END_SPEC>`
    pub type R16_TMR1_DMA_END = crate::Reg<r16_tmr1_dma_end::R16_TMR1_DMA_END_SPEC>;
    ///RW, TMR1 DMA end address
    pub mod r16_tmr1_dma_end {
        ///Register `R16_TMR1_DMA_END` reader
        pub struct R(crate::R<R16_TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR1_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR1_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_TMR1_DMA_END` writer
        pub struct W(crate::W<R16_TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_TMR1_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_TMR1_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_TMR1_DMA_END` reader - RW1,TMR1 FIFO register
        pub type R16_TMR1_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `R16_TMR1_DMA_END` writer - RW1,TMR1 FIFO register
        pub type R16_TMR1_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_TMR1_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn r16_tmr1_dma_end(&self) -> R16_TMR1_DMA_END_R {
                R16_TMR1_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn r16_tmr1_dma_end(&mut self) -> R16_TMR1_DMA_END_W<0> {
                R16_TMR1_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr1_dma_end](index.html) module
        pub struct R16_TMR1_DMA_END_SPEC;
        impl crate::RegisterSpec for R16_TMR1_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr1_dma_end::R](R) reader structure
        impl crate::Readable for R16_TMR1_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_tmr1_dma_end::W](W) writer structure
        impl crate::Writable for R16_TMR1_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_TMR1_DMA_END to value 0
        impl crate::Resettable for R16_TMR1_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr2::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR2 {
    type Target = tmr2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///Timer2 register
pub mod tmr2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR2 mode control
        pub r8_tmr2_ctrl_mod: R8_TMR2_CTRL_MOD,
        ///0x01 - RW, TMR2 DMA control
        pub r8_tmr2_ctrl_dma: R8_TMR2_CTRL_DMA,
        ///0x02 - RW, TMR2 interrupt enable
        pub r8_tmr2_inter_en: R8_TMR2_INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR2 interrupt flag
        pub r8_tmr2_int_flag: R8_TMR2_INT_FLAG,
        ///0x07 - RO, TMR2 FIFO count status
        pub r8_tmr2_fifo_count: R8_TMR2_FIFO_COUNT,
        ///0x08 - RO, TMR2 current count
        pub r32_tmr2_count: R32_TMR2_COUNT,
        ///0x0c - RW, TMR2 end count value, only low 26 bit
        pub r32_tmr2_cnt_end: R32_TMR2_CNT_END,
        ///0x10 - RO, TMR2 FIFO register, only low 26 bit
        pub r32_tmr2_count: R32_TMR2_COUNT,
        ///0x14 - RO, TMR2 DMA current address
        pub r16_tmr2_dma_now: R16_TMR2_DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR2 DMA begin address
        pub r16_tmr2_dma_beg: R16_TMR2_DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR2 DMA end address
        pub r16_tmr2_dma_end: R16_TMR2_DMA_END,
    }
    ///R8_TMR2_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_TMR2_CTRL_MOD_SPEC>`
    pub type R8_TMR2_CTRL_MOD = crate::Reg<r8_tmr2_ctrl_mod::R8_TMR2_CTRL_MOD_SPEC>;
    ///RW, TMR2 mode control
    pub mod r8_tmr2_ctrl_mod {
        ///Register `R8_TMR2_CTRL_MOD` reader
        pub struct R(crate::R<R8_TMR2_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR2_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR2_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR2_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR2_CTRL_MOD` writer
        pub struct W(crate::W<R8_TMR2_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR2_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR2_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR2_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_MODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type RB_TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_MODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type RB_TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_COUNT_EN` reader - RW, timer count enable
        pub type RB_TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_COUNT_EN` writer - RW, timer count enable
        pub type RB_TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_EN` reader - RW, timer output enable
        pub type RB_TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_EN` writer - RW, timer output enable
        pub type RB_TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TMR2_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            pub fn rb_tmr_mode_in(&self) -> RB_TMR_MODE_IN_R {
                RB_TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn rb_tmr_all_clear(&self) -> RB_TMR_ALL_CLEAR_R {
                RB_TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn rb_tmr_count_en(&self) -> RB_TMR_COUNT_EN_R {
                RB_TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn rb_tmr_out_en(&self) -> RB_TMR_OUT_EN_R {
                RB_TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_mode_in(&mut self) -> RB_TMR_MODE_IN_W<0> {
                RB_TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_all_clear(&mut self) -> RB_TMR_ALL_CLEAR_W<1> {
                RB_TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_count_en(&mut self) -> RB_TMR_COUNT_EN_W<2> {
                RB_TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_en(&mut self) -> RB_TMR_OUT_EN_W<3> {
                RB_TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr2_ctrl_mod](index.html) module
        pub struct R8_TMR2_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_TMR2_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr2_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_TMR2_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr2_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_TMR2_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR2_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_TMR2_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_TMR2_CTRL_DMA (rw) register accessor: an alias for `Reg<R8_TMR2_CTRL_DMA_SPEC>`
    pub type R8_TMR2_CTRL_DMA = crate::Reg<r8_tmr2_ctrl_dma::R8_TMR2_CTRL_DMA_SPEC>;
    ///RW, TMR2 DMA control
    pub mod r8_tmr2_ctrl_dma {
        ///Register `R8_TMR2_CTRL_DMA` reader
        pub struct R(crate::R<R8_TMR2_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR2_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR2_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR2_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR2_CTRL_DMA` writer
        pub struct W(crate::W<R8_TMR2_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR2_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR2_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR2_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_DMA_ENABLE` reader - RW, timer1_2 DMA enable
        pub type RB_TMR_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `RB_TMR_DMA_ENABLE` writer - RW, timer1_2 DMA enable
        pub type RB_TMR_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_DMA_SPEC, bool, O>;
        ///Field `RB_TMR_DMA_LOOP` reader - RW, timer1_2 DMA address loop enable
        pub type RB_TMR_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_TMR_DMA_LOOP` writer - RW, timer1_2 DMA address loop enable
        pub type RB_TMR_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            pub fn rb_tmr_dma_enable(&self) -> RB_TMR_DMA_ENABLE_R {
                RB_TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            pub fn rb_tmr_dma_loop(&self) -> RB_TMR_DMA_LOOP_R {
                RB_TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_dma_enable(&mut self) -> RB_TMR_DMA_ENABLE_W<0> {
                RB_TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_dma_loop(&mut self) -> RB_TMR_DMA_LOOP_W<2> {
                RB_TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr2_ctrl_dma](index.html) module
        pub struct R8_TMR2_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for R8_TMR2_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr2_ctrl_dma::R](R) reader structure
        impl crate::Readable for R8_TMR2_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr2_ctrl_dma::W](W) writer structure
        impl crate::Writable for R8_TMR2_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR2_CTRL_DMA to value 0
        impl crate::Resettable for R8_TMR2_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR2_INTER_EN (rw) register accessor: an alias for `Reg<R8_TMR2_INTER_EN_SPEC>`
    pub type R8_TMR2_INTER_EN = crate::Reg<r8_tmr2_inter_en::R8_TMR2_INTER_EN_SPEC>;
    ///RW, TMR2 interrupt enable
    pub mod r8_tmr2_inter_en {
        ///Register `R8_TMR2_INTER_EN` reader
        pub struct R(crate::R<R8_TMR2_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR2_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR2_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR2_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR2_INTER_EN` writer
        pub struct W(crate::W<R8_TMR2_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR2_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR2_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR2_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_ie_cyc_end(&self) -> RB_TMR_IE_CYC_END_R {
                RB_TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_ie_data_act(&self) -> RB_TMR_IE_DATA_ACT_R {
                RB_TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_hf(&self) -> RB_TMR_IE_FIFO_HF_R {
                RB_TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_ie_dma_end(&self) -> RB_TMR_IE_DMA_END_R {
                RB_TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_ov(&self) -> RB_TMR_IE_FIFO_OV_R {
                RB_TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_cyc_end(&mut self) -> RB_TMR_IE_CYC_END_W<0> {
                RB_TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_data_act(&mut self) -> RB_TMR_IE_DATA_ACT_W<1> {
                RB_TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_hf(&mut self) -> RB_TMR_IE_FIFO_HF_W<2> {
                RB_TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_dma_end(&mut self) -> RB_TMR_IE_DMA_END_W<3> {
                RB_TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_ov(&mut self) -> RB_TMR_IE_FIFO_OV_W<4> {
                RB_TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr2_inter_en](index.html) module
        pub struct R8_TMR2_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_TMR2_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr2_inter_en::R](R) reader structure
        impl crate::Readable for R8_TMR2_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr2_inter_en::W](W) writer structure
        impl crate::Writable for R8_TMR2_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR2_INTER_EN to value 0
        impl crate::Resettable for R8_TMR2_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR2_INT_FLAG (rw) register accessor: an alias for `Reg<R8_TMR2_INT_FLAG_SPEC>`
    pub type R8_TMR2_INT_FLAG = crate::Reg<r8_tmr2_int_flag::R8_TMR2_INT_FLAG_SPEC>;
    ///RW1, TMR2 interrupt flag
    pub mod r8_tmr2_int_flag {
        ///Register `R8_TMR2_INT_FLAG` reader
        pub struct R(crate::R<R8_TMR2_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR2_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR2_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR2_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR2_INT_FLAG` writer
        pub struct W(crate::W<R8_TMR2_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR2_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR2_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR2_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR2_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_if_cyc_end(&self) -> RB_TMR_IF_CYC_END_R {
                RB_TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_if_data_act(&self) -> RB_TMR_IF_DATA_ACT_R {
                RB_TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn rb_tmr_if_fifo_hf(&self) -> RB_TMR_IF_FIFO_HF_R {
                RB_TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_if_dma_end(&self) -> RB_TMR_IF_DMA_END_R {
                RB_TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_if_fifo_ov(&self) -> RB_TMR_IF_FIFO_OV_R {
                RB_TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_cyc_end(&mut self) -> RB_TMR_IF_CYC_END_W<0> {
                RB_TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_data_act(&mut self) -> RB_TMR_IF_DATA_ACT_W<1> {
                RB_TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_hf(&mut self) -> RB_TMR_IF_FIFO_HF_W<2> {
                RB_TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_dma_end(&mut self) -> RB_TMR_IF_DMA_END_W<3> {
                RB_TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_ov(&mut self) -> RB_TMR_IF_FIFO_OV_W<4> {
                RB_TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR2 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr2_int_flag](index.html) module
        pub struct R8_TMR2_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_TMR2_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr2_int_flag::R](R) reader structure
        impl crate::Readable for R8_TMR2_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr2_int_flag::W](W) writer structure
        impl crate::Writable for R8_TMR2_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR2_INT_FLAG to value 0
        impl crate::Resettable for R8_TMR2_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR2_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_TMR2_FIFO_COUNT_SPEC>`
    pub type R8_TMR2_FIFO_COUNT = crate::Reg<r8_tmr2_fifo_count::R8_TMR2_FIFO_COUNT_SPEC>;
    ///RO, TMR2 FIFO count status
    pub mod r8_tmr2_fifo_count {
        ///Register `R8_TMR2_FIFO_COUNT` reader
        pub struct R(crate::R<R8_TMR2_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR2_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR2_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR2_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_TMR2_FIFO_COUNT` reader - RW, TMR2 FIFO count status
        pub type R8_TMR2_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RW, TMR2 FIFO count status
            #[inline(always)]
            pub fn r8_tmr2_fifo_count(&self) -> R8_TMR2_FIFO_COUNT_R {
                R8_TMR2_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr2_fifo_count](index.html) module
        pub struct R8_TMR2_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_TMR2_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr2_fifo_count::R](R) reader structure
        impl crate::Readable for R8_TMR2_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_TMR2_FIFO_COUNT to value 0
        impl crate::Resettable for R8_TMR2_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR2_COUNT (r) register accessor: an alias for `Reg<R32_TMR2_COUNT_SPEC>`
    pub type R32_TMR2_COUNT = crate::Reg<r32_tmr2_count::R32_TMR2_COUNT_SPEC>;
    ///RO, TMR2 current count
    pub mod r32_tmr2_count {
        ///Register `R32_TMR2_COUNT` reader
        pub struct R(crate::R<R32_TMR2_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR2_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR2_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR2_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR2_COUNT` reader - RW, TMR2 current count
        pub type R32_TMR2_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn r32_tmr2_count(&self) -> R32_TMR2_COUNT_R {
                R32_TMR2_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr2_count](index.html) module
        pub struct R32_TMR2_COUNT_SPEC;
        impl crate::RegisterSpec for R32_TMR2_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr2_count::R](R) reader structure
        impl crate::Readable for R32_TMR2_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR2_COUNT to value 0
        impl crate::Resettable for R32_TMR2_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR2_CNT_END (rw) register accessor: an alias for `Reg<R32_TMR2_CNT_END_SPEC>`
    pub type R32_TMR2_CNT_END = crate::Reg<r32_tmr2_cnt_end::R32_TMR2_CNT_END_SPEC>;
    ///RW, TMR2 end count value, only low 26 bit
    pub mod r32_tmr2_cnt_end {
        ///Register `R32_TMR2_CNT_END` reader
        pub struct R(crate::R<R32_TMR2_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR2_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR2_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR2_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR2_CNT_END` writer
        pub struct W(crate::W<R32_TMR2_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR2_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR2_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR2_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR2_COUNT` reader - RW, TMR2 current count
        pub type R32_TMR2_COUNT_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR2_COUNT` writer - RW, TMR2 current count
        pub type R32_TMR2_COUNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR2_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn r32_tmr2_count(&self) -> R32_TMR2_COUNT_R {
                R32_TMR2_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr2_count(&mut self) -> R32_TMR2_COUNT_W<0> {
                R32_TMR2_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr2_cnt_end](index.html) module
        pub struct R32_TMR2_CNT_END_SPEC;
        impl crate::RegisterSpec for R32_TMR2_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr2_cnt_end::R](R) reader structure
        impl crate::Readable for R32_TMR2_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr2_cnt_end::W](W) writer structure
        impl crate::Writable for R32_TMR2_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR2_CNT_END to value 0
        impl crate::Resettable for R32_TMR2_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR2_COUNT (rw) register accessor: an alias for `Reg<R32_TMR2_COUNT_SPEC>`
    pub type R32_TMR2_COUNT = crate::Reg<r32_tmr2_count::R32_TMR2_COUNT_SPEC>;
    ///RO, TMR2 FIFO register, only low 26 bit
    pub mod r32_tmr2_count {
        ///Register `R32_TMR2_COUNT` reader
        pub struct R(crate::R<R32_TMR2_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR2_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR2_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR2_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR2_COUNT` writer
        pub struct W(crate::W<R32_TMR2_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR2_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR2_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR2_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR2_FIFO` reader - RW, TMR2 current count
        pub type R32_TMR2_FIFO_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR2_FIFO` writer - RW, TMR2 current count
        pub type R32_TMR2_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR2_COUNT_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn r32_tmr2_fifo(&self) -> R32_TMR2_FIFO_R {
                R32_TMR2_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr2_fifo(&mut self) -> R32_TMR2_FIFO_W<0> {
                R32_TMR2_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, TMR2 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr2_count](index.html) module
        pub struct R32_TMR2_COUNT_SPEC;
        impl crate::RegisterSpec for R32_TMR2_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr2_count::R](R) reader structure
        impl crate::Readable for R32_TMR2_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr2_count::W](W) writer structure
        impl crate::Writable for R32_TMR2_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR2_COUNT to value 0
        impl crate::Resettable for R32_TMR2_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR2_DMA_NOW (r) register accessor: an alias for `Reg<R16_TMR2_DMA_NOW_SPEC>`
    pub type R16_TMR2_DMA_NOW = crate::Reg<r16_tmr2_dma_now::R16_TMR2_DMA_NOW_SPEC>;
    ///RO, TMR2 DMA current address
    pub mod r16_tmr2_dma_now {
        ///Register `R16_TMR2_DMA_NOW` reader
        pub struct R(crate::R<R16_TMR2_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR2_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR2_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR2_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR2_FIFO` reader - RW, TMR2 current count
        pub type R32_TMR2_FIFO_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn r32_tmr2_fifo(&self) -> R32_TMR2_FIFO_R {
                R32_TMR2_FIFO_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        ///RO, TMR2 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr2_dma_now](index.html) module
        pub struct R16_TMR2_DMA_NOW_SPEC;
        impl crate::RegisterSpec for R16_TMR2_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr2_dma_now::R](R) reader structure
        impl crate::Readable for R16_TMR2_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_TMR2_DMA_NOW to value 0
        impl crate::Resettable for R16_TMR2_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR2_DMA_BEG (rw) register accessor: an alias for `Reg<R16_TMR2_DMA_BEG_SPEC>`
    pub type R16_TMR2_DMA_BEG = crate::Reg<r16_tmr2_dma_beg::R16_TMR2_DMA_BEG_SPEC>;
    ///RW, TMR2 DMA begin address
    pub mod r16_tmr2_dma_beg {
        ///Register `R16_TMR2_DMA_BEG` reader
        pub struct R(crate::R<R16_TMR2_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR2_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR2_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR2_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_TMR2_DMA_BEG` writer
        pub struct W(crate::W<R16_TMR2_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_TMR2_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_TMR2_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_TMR2_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_TMR2_DMA_BEG` reader - RW, TMR2 DMA begin address
        pub type R16_TMR2_DMA_BEG_R = crate::FieldReader<u32, u32>;
        ///Field `R16_TMR2_DMA_BEG` writer - RW, TMR2 DMA begin address
        pub type R16_TMR2_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_TMR2_DMA_BEG_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 DMA begin address
            #[inline(always)]
            pub fn r16_tmr2_dma_beg(&self) -> R16_TMR2_DMA_BEG_R {
                R16_TMR2_DMA_BEG_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn r16_tmr2_dma_beg(&mut self) -> R16_TMR2_DMA_BEG_W<0> {
                R16_TMR2_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr2_dma_beg](index.html) module
        pub struct R16_TMR2_DMA_BEG_SPEC;
        impl crate::RegisterSpec for R16_TMR2_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr2_dma_beg::R](R) reader structure
        impl crate::Readable for R16_TMR2_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_tmr2_dma_beg::W](W) writer structure
        impl crate::Writable for R16_TMR2_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_TMR2_DMA_BEG to value 0
        impl crate::Resettable for R16_TMR2_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_TMR2_DMA_END (rw) register accessor: an alias for `Reg<R16_TMR2_DMA_END_SPEC>`
    pub type R16_TMR2_DMA_END = crate::Reg<r16_tmr2_dma_end::R16_TMR2_DMA_END_SPEC>;
    ///RW, TMR2 DMA end address
    pub mod r16_tmr2_dma_end {
        ///Register `R16_TMR2_DMA_END` reader
        pub struct R(crate::R<R16_TMR2_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_TMR2_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_TMR2_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_TMR2_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_TMR2_DMA_END` writer
        pub struct W(crate::W<R16_TMR2_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_TMR2_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_TMR2_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_TMR2_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_TMR2_DMA_END` reader - RW, TMR2 DMA end address
        pub type R16_TMR2_DMA_END_R = crate::FieldReader<u32, u32>;
        ///Field `R16_TMR2_DMA_END` writer - RW, TMR2 DMA end address
        pub type R16_TMR2_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_TMR2_DMA_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 DMA end address
            #[inline(always)]
            pub fn r16_tmr2_dma_end(&self) -> R16_TMR2_DMA_END_R {
                R16_TMR2_DMA_END_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn r16_tmr2_dma_end(&mut self) -> R16_TMR2_DMA_END_W<0> {
                R16_TMR2_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_tmr2_dma_end](index.html) module
        pub struct R16_TMR2_DMA_END_SPEC;
        impl crate::RegisterSpec for R16_TMR2_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_tmr2_dma_end::R](R) reader structure
        impl crate::Readable for R16_TMR2_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_tmr2_dma_end::W](W) writer structure
        impl crate::Writable for R16_TMR2_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_TMR2_DMA_END to value 0
        impl crate::Resettable for R16_TMR2_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer3 register
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    ///Pointer to the register block
    pub const PTR: *const tmr3::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR3 {
    type Target = tmr3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
///Timer3 register
pub mod tmr3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR3 mode control
        pub r8_tmr3_ctrl_mod: R8_TMR3_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR3 interrupt enable
        pub r8_tmr3_inter_en: R8_TMR3_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR3 interrupt flag
        pub r8_tmr3_int_flag: R8_TMR3_INT_FLAG,
        ///0x07 - RO, TMR3 FIFO count status
        pub r8_tmr3_fifo_count: R8_TMR3_FIFO_COUNT,
        ///0x08 - RO, TMR3 current count
        pub r32_tmr3_count: R32_TMR3_COUNT,
        ///0x0c - RW, TMR3 end count value, only low 26 bit
        pub r32_tmr3_cnt_end: R32_TMR3_CNT_END,
        ///0x10 - RO/WO, TMR3 FIFO register, only low 26 bit
        pub r32_tmr3_fifo: R32_TMR3_FIFO,
    }
    ///R8_TMR3_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_TMR3_CTRL_MOD_SPEC>`
    pub type R8_TMR3_CTRL_MOD = crate::Reg<r8_tmr3_ctrl_mod::R8_TMR3_CTRL_MOD_SPEC>;
    ///RW, TMR3 mode control
    pub mod r8_tmr3_ctrl_mod {
        ///Register `R8_TMR3_CTRL_MOD` reader
        pub struct R(crate::R<R8_TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR3_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR3_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR3_CTRL_MOD` writer
        pub struct W(crate::W<R8_TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR3_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR3_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type RB_TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type RB_TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_COUNT_EN` reader - RW, timer count enable
        pub type RB_TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_COUNT_EN` writer - RW, timer count enable
        pub type RB_TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_EN` reader - RW, timer output enable
        pub type RB_TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_EN` writer - RW, timer output enable
        pub type RB_TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_TMR3_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn rb_tmr_mode_in(&self) -> RB_TMR_MODE_IN_R {
                RB_TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn rb_tmr_all_clear(&self) -> RB_TMR_ALL_CLEAR_R {
                RB_TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn rb_tmr_count_en(&self) -> RB_TMR_COUNT_EN_R {
                RB_TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn rb_tmr_out_en(&self) -> RB_TMR_OUT_EN_R {
                RB_TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_mode_in(&mut self) -> RB_TMR_MODE_IN_W<0> {
                RB_TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_all_clear(&mut self) -> RB_TMR_ALL_CLEAR_W<1> {
                RB_TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_count_en(&mut self) -> RB_TMR_COUNT_EN_W<2> {
                RB_TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_en(&mut self) -> RB_TMR_OUT_EN_W<3> {
                RB_TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                RB_TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                RB_TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr3_ctrl_mod](index.html) module
        pub struct R8_TMR3_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_TMR3_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr3_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_TMR3_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr3_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_TMR3_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR3_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_TMR3_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_TMR3_INTER_EN (rw) register accessor: an alias for `Reg<R8_TMR3_INTER_EN_SPEC>`
    pub type R8_TMR3_INTER_EN = crate::Reg<r8_tmr3_inter_en::R8_TMR3_INTER_EN_SPEC>;
    ///RW, TMR3 interrupt enable
    pub mod r8_tmr3_inter_en {
        ///Register `R8_TMR3_INTER_EN` reader
        pub struct R(crate::R<R8_TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR3_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR3_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR3_INTER_EN` writer
        pub struct W(crate::W<R8_TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR3_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR3_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type RB_TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type RB_TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type RB_TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `RB_TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type RB_TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_ie_cyc_end(&self) -> RB_TMR_IE_CYC_END_R {
                RB_TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_ie_data_act(&self) -> RB_TMR_IE_DATA_ACT_R {
                RB_TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_hf(&self) -> RB_TMR_IE_FIFO_HF_R {
                RB_TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_ie_dma_end(&self) -> RB_TMR_IE_DMA_END_R {
                RB_TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_ie_fifo_ov(&self) -> RB_TMR_IE_FIFO_OV_R {
                RB_TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_cyc_end(&mut self) -> RB_TMR_IE_CYC_END_W<0> {
                RB_TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_data_act(&mut self) -> RB_TMR_IE_DATA_ACT_W<1> {
                RB_TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_hf(&mut self) -> RB_TMR_IE_FIFO_HF_W<2> {
                RB_TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_dma_end(&mut self) -> RB_TMR_IE_DMA_END_W<3> {
                RB_TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_ie_fifo_ov(&mut self) -> RB_TMR_IE_FIFO_OV_W<4> {
                RB_TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr3_inter_en](index.html) module
        pub struct R8_TMR3_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_TMR3_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr3_inter_en::R](R) reader structure
        impl crate::Readable for R8_TMR3_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr3_inter_en::W](W) writer structure
        impl crate::Writable for R8_TMR3_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR3_INTER_EN to value 0
        impl crate::Resettable for R8_TMR3_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR3_INT_FLAG (rw) register accessor: an alias for `Reg<R8_TMR3_INT_FLAG_SPEC>`
    pub type R8_TMR3_INT_FLAG = crate::Reg<r8_tmr3_int_flag::R8_TMR3_INT_FLAG_SPEC>;
    ///RW1, TMR3 interrupt flag
    pub mod r8_tmr3_int_flag {
        ///Register `R8_TMR3_INT_FLAG` reader
        pub struct R(crate::R<R8_TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR3_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR3_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_TMR3_INT_FLAG` writer
        pub struct W(crate::W<R8_TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_TMR3_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_TMR3_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type RB_TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type RB_TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type RB_TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type RB_TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type RB_TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_TMR3_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn rb_tmr_if_cyc_end(&self) -> RB_TMR_IF_CYC_END_R {
                RB_TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn rb_tmr_if_data_act(&self) -> RB_TMR_IF_DATA_ACT_R {
                RB_TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn rb_tmr_if_fifo_hf(&self) -> RB_TMR_IF_FIFO_HF_R {
                RB_TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn rb_tmr_if_dma_end(&self) -> RB_TMR_IF_DMA_END_R {
                RB_TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn rb_tmr_if_fifo_ov(&self) -> RB_TMR_IF_FIFO_OV_R {
                RB_TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_cyc_end(&mut self) -> RB_TMR_IF_CYC_END_W<0> {
                RB_TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_data_act(&mut self) -> RB_TMR_IF_DATA_ACT_W<1> {
                RB_TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_hf(&mut self) -> RB_TMR_IF_FIFO_HF_W<2> {
                RB_TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_dma_end(&mut self) -> RB_TMR_IF_DMA_END_W<3> {
                RB_TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_tmr_if_fifo_ov(&mut self) -> RB_TMR_IF_FIFO_OV_W<4> {
                RB_TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR3 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr3_int_flag](index.html) module
        pub struct R8_TMR3_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_TMR3_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr3_int_flag::R](R) reader structure
        impl crate::Readable for R8_TMR3_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_tmr3_int_flag::W](W) writer structure
        impl crate::Writable for R8_TMR3_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_TMR3_INT_FLAG to value 0
        impl crate::Resettable for R8_TMR3_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_TMR3_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_TMR3_FIFO_COUNT_SPEC>`
    pub type R8_TMR3_FIFO_COUNT = crate::Reg<r8_tmr3_fifo_count::R8_TMR3_FIFO_COUNT_SPEC>;
    ///RO, TMR3 FIFO count status
    pub mod r8_tmr3_fifo_count {
        ///Register `R8_TMR3_FIFO_COUNT` reader
        pub struct R(crate::R<R8_TMR3_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_TMR3_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_TMR3_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_TMR3_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_TMR3_FIFO_COUNT` reader - R0, TMR3 FIFO count status
        pub type R8_TMR3_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - R0, TMR3 FIFO count status
            #[inline(always)]
            pub fn r8_tmr3_fifo_count(&self) -> R8_TMR3_FIFO_COUNT_R {
                R8_TMR3_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_tmr3_fifo_count](index.html) module
        pub struct R8_TMR3_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_TMR3_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_tmr3_fifo_count::R](R) reader structure
        impl crate::Readable for R8_TMR3_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_TMR3_FIFO_COUNT to value 0
        impl crate::Resettable for R8_TMR3_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR3_COUNT (r) register accessor: an alias for `Reg<R32_TMR3_COUNT_SPEC>`
    pub type R32_TMR3_COUNT = crate::Reg<r32_tmr3_count::R32_TMR3_COUNT_SPEC>;
    ///RO, TMR3 current count
    pub mod r32_tmr3_count {
        ///Register `R32_TMR3_COUNT` reader
        pub struct R(crate::R<R32_TMR3_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR3_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR3_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR3_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R32_TMR3_COUNT` reader - R0, TMR3 current count
        pub type R32_TMR3_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - R0, TMR3 current count
            #[inline(always)]
            pub fn r32_tmr3_count(&self) -> R32_TMR3_COUNT_R {
                R32_TMR3_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr3_count](index.html) module
        pub struct R32_TMR3_COUNT_SPEC;
        impl crate::RegisterSpec for R32_TMR3_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr3_count::R](R) reader structure
        impl crate::Readable for R32_TMR3_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_TMR3_COUNT to value 0
        impl crate::Resettable for R32_TMR3_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR3_CNT_END (rw) register accessor: an alias for `Reg<R32_TMR3_CNT_END_SPEC>`
    pub type R32_TMR3_CNT_END = crate::Reg<r32_tmr3_cnt_end::R32_TMR3_CNT_END_SPEC>;
    ///RW, TMR3 end count value, only low 26 bit
    pub mod r32_tmr3_cnt_end {
        ///Register `R32_TMR3_CNT_END` reader
        pub struct R(crate::R<R32_TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR3_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR3_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR3_CNT_END` writer
        pub struct W(crate::W<R32_TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR3_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR3_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR3_CNT_END` reader - RW, TMR3 end count value, only low 26 bit
        pub type R32_TMR3_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR3_CNT_END` writer - RW, TMR3 end count value, only low 26 bit
        pub type R32_TMR3_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR3_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            pub fn r32_tmr3_cnt_end(&self) -> R32_TMR3_CNT_END_R {
                R32_TMR3_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr3_cnt_end(&mut self) -> R32_TMR3_CNT_END_W<0> {
                R32_TMR3_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr3_cnt_end](index.html) module
        pub struct R32_TMR3_CNT_END_SPEC;
        impl crate::RegisterSpec for R32_TMR3_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr3_cnt_end::R](R) reader structure
        impl crate::Readable for R32_TMR3_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr3_cnt_end::W](W) writer structure
        impl crate::Writable for R32_TMR3_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR3_CNT_END to value 0
        impl crate::Resettable for R32_TMR3_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_TMR3_FIFO (rw) register accessor: an alias for `Reg<R32_TMR3_FIFO_SPEC>`
    pub type R32_TMR3_FIFO = crate::Reg<r32_tmr3_fifo::R32_TMR3_FIFO_SPEC>;
    ///RO/WO, TMR3 FIFO register, only low 26 bit
    pub mod r32_tmr3_fifo {
        ///Register `R32_TMR3_FIFO` reader
        pub struct R(crate::R<R32_TMR3_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_TMR3_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_TMR3_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_TMR3_FIFO` writer
        pub struct W(crate::W<R32_TMR3_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_TMR3_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_TMR3_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R32_TMR3_FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type R32_TMR3_FIFO_R = crate::FieldReader<u32, u32>;
        ///Field `R32_TMR3_FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type R32_TMR3_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_TMR3_FIFO_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            pub fn r32_tmr3_fifo(&self) -> R32_TMR3_FIFO_R {
                R32_TMR3_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn r32_tmr3_fifo(&mut self) -> R32_TMR3_FIFO_W<0> {
                R32_TMR3_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, TMR3 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_tmr3_fifo](index.html) module
        pub struct R32_TMR3_FIFO_SPEC;
        impl crate::RegisterSpec for R32_TMR3_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_tmr3_fifo::R](R) reader structure
        impl crate::Readable for R32_TMR3_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_tmr3_fifo::W](W) writer structure
        impl crate::Writable for R32_TMR3_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_TMR3_FIFO to value 0
        impl crate::Resettable for R32_TMR3_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART0 modem control
        pub r8_uart0_mcr: R8_UART0_MCR,
        ///0x01 - RW, UART0 interrupt enable
        pub r8_uart0_ier: R8_UART0_IER,
        ///0x02 - RW, UART0 FIFO control
        pub r8_uart0_fcr: R8_UART0_FCR,
        ///0x03 - RW, UART0 line control
        pub r8_uart0_lcr: R8_UART0_LCR,
        ///0x04 - RO, UART0 interrupt identification
        pub r8_uart0_iir: R8_UART0_IIR,
        ///0x05 - RO, UART0 line status
        pub r8_uart0_lsr: R8_UART0_LSR,
        ///0x06 - RO, UART0 modem status
        pub r8_uart0_msr: R8_UART0_MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_r8_uart0: [u8; 0x01],
        _reserved8: [u8; 0x01],
        ///0x0a - RO, UART0 receiver FIFO count
        pub r8_uart0_rfc: R8_UART0_RFC,
        ///0x0b - RO, UART0 transmitter FIFO count
        pub r8_uart0_tfc: R8_UART0_TFC,
        ///0x0c - RW, UART0 divisor latch
        pub r16_uart0_dl: R16_UART0_DL,
        ///0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub r8_uart0_div: R8_UART0_DIV,
        ///0x0f - RW, UART0 slave address: 0xFF=disable, other=enable
        pub r8_uart0_adr: R8_UART0_ADR,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART0 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn r8_uart0_thr(&self) -> &R8_UART0_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART0 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn r8_uart0_rbr(&self) -> &R8_UART0_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///R8_UART0_MCR (rw) register accessor: an alias for `Reg<R8_UART0_MCR_SPEC>`
    pub type R8_UART0_MCR = crate::Reg<r8_uart0_mcr::R8_UART0_MCR_SPEC>;
    ///RW, UART0 modem control
    pub mod r8_uart0_mcr {
        ///Register `R8_UART0_MCR` reader
        pub struct R(crate::R<R8_UART0_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_MCR` writer
        pub struct W(crate::W<R8_UART0_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_MCR_DTR` reader - RW, UART0 control DTR
        pub type RB_MCR_DTR_R = crate::BitReader<bool>;
        ///Field `RB_MCR_DTR` writer - RW, UART0 control DTR
        pub type RB_MCR_DTR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_RTS` reader - RW, UART0 control RTS
        pub type RB_MCR_RTS_R = crate::BitReader<bool>;
        ///Field `RB_MCR_RTS` writer - RW, UART0 control RTS
        pub type RB_MCR_RTS_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_OUT1` reader - RW, UART0 control OUT1
        pub type RB_MCR_OUT1_R = crate::BitReader<bool>;
        ///Field `RB_MCR_OUT1` writer - RW, UART0 control OUT1
        pub type RB_MCR_OUT1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/ UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/ UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_LOOP` reader - RW, UART0 enable local loop back
        pub type RB_MCR_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_MCR_LOOP` writer - RW, UART0 enable local loop back
        pub type RB_MCR_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_AU_FLOW_EN` reader - RW, UART0 enable autoflow control
        pub type RB_MCR_AU_FLOW_EN_R = crate::BitReader<bool>;
        ///Field `RB_MCR_AU_FLOW_EN` writer - RW, UART0 enable autoflow control
        pub type RB_MCR_AU_FLOW_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_TNOW` reader - RW, UART0 enable TNOW output on DTR pin
        pub type RB_MCR_TNOW_R = crate::BitReader<bool>;
        ///Field `RB_MCR_TNOW` writer - RW, UART0 enable TNOW output on DTR pin
        pub type RB_MCR_TNOW_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        ///Field `RB_MCR_HALF` reader - RW, UART0 enable half-duplex
        pub type RB_MCR_HALF_R = crate::BitReader<bool>;
        ///Field `RB_MCR_HALF` writer - RW, UART0 enable half-duplex
        pub type RB_MCR_HALF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            pub fn rb_mcr_dtr(&self) -> RB_MCR_DTR_R {
                RB_MCR_DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            pub fn rb_mcr_rts(&self) -> RB_MCR_RTS_R {
                RB_MCR_RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            pub fn rb_mcr_out1(&self) -> RB_MCR_OUT1_R {
                RB_MCR_OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&self) -> RB_MCR_OUT2__RB_MCR_INT_OE_R {
                RB_MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            pub fn rb_mcr_loop(&self) -> RB_MCR_LOOP_R {
                RB_MCR_LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            pub fn rb_mcr_au_flow_en(&self) -> RB_MCR_AU_FLOW_EN_R {
                RB_MCR_AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn rb_mcr_tnow(&self) -> RB_MCR_TNOW_R {
                RB_MCR_TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            pub fn rb_mcr_half(&self) -> RB_MCR_HALF_R {
                RB_MCR_HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_dtr(&mut self) -> RB_MCR_DTR_W<0> {
                RB_MCR_DTR_W::new(self)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_rts(&mut self) -> RB_MCR_RTS_W<1> {
                RB_MCR_RTS_W::new(self)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_out1(&mut self) -> RB_MCR_OUT1_W<2> {
                RB_MCR_OUT1_W::new(self)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&mut self) -> RB_MCR_OUT2__RB_MCR_INT_OE_W<3> {
                RB_MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_loop(&mut self) -> RB_MCR_LOOP_W<4> {
                RB_MCR_LOOP_W::new(self)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_au_flow_en(&mut self) -> RB_MCR_AU_FLOW_EN_W<5> {
                RB_MCR_AU_FLOW_EN_W::new(self)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_tnow(&mut self) -> RB_MCR_TNOW_W<6> {
                RB_MCR_TNOW_W::new(self)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_half(&mut self) -> RB_MCR_HALF_W<7> {
                RB_MCR_HALF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_mcr](index.html) module
        pub struct R8_UART0_MCR_SPEC;
        impl crate::RegisterSpec for R8_UART0_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_mcr::R](R) reader structure
        impl crate::Readable for R8_UART0_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_mcr::W](W) writer structure
        impl crate::Writable for R8_UART0_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_MCR to value 0
        impl crate::Resettable for R8_UART0_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_IER (rw) register accessor: an alias for `Reg<R8_UART0_IER_SPEC>`
    pub type R8_UART0_IER = crate::Reg<r8_uart0_ier::R8_UART0_IER_SPEC>;
    ///RW, UART0 interrupt enable
    pub mod r8_uart0_ier {
        ///Register `R8_UART0_IER` reader
        pub struct R(crate::R<R8_UART0_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_IER` writer
        pub struct W(crate::W<R8_UART0_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `RB_IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `RB_IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `RB_IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change
        pub type RB_IER_MODEM_CHG_R = crate::BitReader<bool>;
        ///Field `RB_IER_MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change
        pub type RB_IER_MODEM_CHG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable
        pub type RB_IER_DTR_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable
        pub type RB_IER_DTR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_RTS_EN` reader - RW, UART0 RTS output pin enable
        pub type RB_IER_RTS_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_RTS_EN` writer - RW, UART0 RTS output pin enable
        pub type RB_IER_RTS_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        ///Field `RB_IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_R = crate::BitReader<bool>;
        ///Field `RB_IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn rb_ier_recv_rdy(&self) -> RB_IER_RECV_RDY_R {
                RB_IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn rb_ier_thr_empty(&self) -> RB_IER_THR_EMPTY_R {
                RB_IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn rb_ier_line_stat(&self) -> RB_IER_LINE_STAT_R {
                RB_IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn rb_ier_modem_chg(&self) -> RB_IER_MODEM_CHG_R {
                RB_IER_MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn rb_ier_dtr_en(&self) -> RB_IER_DTR_EN_R {
                RB_IER_DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            pub fn rb_ier_rts_en(&self) -> RB_IER_RTS_EN_R {
                RB_IER_RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn rb_ier_txd_en(&self) -> RB_IER_TXD_EN_R {
                RB_IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn rb_ier_reset(&self) -> RB_IER_RESET_R {
                RB_IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_recv_rdy(&mut self) -> RB_IER_RECV_RDY_W<0> {
                RB_IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_thr_empty(&mut self) -> RB_IER_THR_EMPTY_W<1> {
                RB_IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_line_stat(&mut self) -> RB_IER_LINE_STAT_W<2> {
                RB_IER_LINE_STAT_W::new(self)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_modem_chg(&mut self) -> RB_IER_MODEM_CHG_W<3> {
                RB_IER_MODEM_CHG_W::new(self)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_dtr_en(&mut self) -> RB_IER_DTR_EN_W<4> {
                RB_IER_DTR_EN_W::new(self)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_rts_en(&mut self) -> RB_IER_RTS_EN_W<5> {
                RB_IER_RTS_EN_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_txd_en(&mut self) -> RB_IER_TXD_EN_W<6> {
                RB_IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_reset(&mut self) -> RB_IER_RESET_W<7> {
                RB_IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_ier](index.html) module
        pub struct R8_UART0_IER_SPEC;
        impl crate::RegisterSpec for R8_UART0_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_ier::R](R) reader structure
        impl crate::Readable for R8_UART0_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_ier::W](W) writer structure
        impl crate::Writable for R8_UART0_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_IER to value 0
        impl crate::Resettable for R8_UART0_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_FCR (rw) register accessor: an alias for `Reg<R8_UART0_FCR_SPEC>`
    pub type R8_UART0_FCR = crate::Reg<r8_uart0_fcr::R8_UART0_FCR_SPEC>;
    ///RW, UART0 FIFO control
    pub mod r8_uart0_fcr {
        ///Register `R8_UART0_FCR` reader
        pub struct R(crate::R<R8_UART0_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_FCR` writer
        pub struct W(crate::W<R8_UART0_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `RB_FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `RB_FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn rb_fcr_fifo_en(&self) -> RB_FCR_FIFO_EN_R {
                RB_FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_rx_fifo_clr(&self) -> RB_FCR_RX_FIFO_CLR_R {
                RB_FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_tx_fifo_clr(&self) -> RB_FCR_TX_FIFO_CLR_R {
                RB_FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn rb_fcr_fifo_trig(&self) -> RB_FCR_FIFO_TRIG_R {
                RB_FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_en(&mut self) -> RB_FCR_FIFO_EN_W<0> {
                RB_FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_rx_fifo_clr(&mut self) -> RB_FCR_RX_FIFO_CLR_W<1> {
                RB_FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_tx_fifo_clr(&mut self) -> RB_FCR_TX_FIFO_CLR_W<2> {
                RB_FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_trig(&mut self) -> RB_FCR_FIFO_TRIG_W<6> {
                RB_FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_fcr](index.html) module
        pub struct R8_UART0_FCR_SPEC;
        impl crate::RegisterSpec for R8_UART0_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_fcr::R](R) reader structure
        impl crate::Readable for R8_UART0_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_fcr::W](W) writer structure
        impl crate::Writable for R8_UART0_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_FCR to value 0
        impl crate::Resettable for R8_UART0_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_LCR (rw) register accessor: an alias for `Reg<R8_UART0_LCR_SPEC>`
    pub type R8_UART0_LCR = crate::Reg<r8_uart0_lcr::R8_UART0_LCR_SPEC>;
    ///RW, UART0 line control
    pub mod r8_uart0_lcr {
        ///Register `R8_UART0_LCR` reader
        pub struct R(crate::R<R8_UART0_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_LCR` writer
        pub struct W(crate::W<R8_UART0_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_EN` reader - RW, UART parity enable
        pub type RB_LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_PAR_EN` writer - RW, UART parity enable
        pub type RB_LCR_PAR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_BREAK_EN` reader - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_BREAK_EN` writer - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART0_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn rb_lcr_word_sz(&self) -> RB_LCR_WORD_SZ_R {
                RB_LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn rb_lcr_stop_bit(&self) -> RB_LCR_STOP_BIT_R {
                RB_LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn rb_lcr_par_en(&self) -> RB_LCR_PAR_EN_R {
                RB_LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn rb_lcr_par_mod(&self) -> RB_LCR_PAR_MOD_R {
                RB_LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn rb_lcr_break_en(&self) -> RB_LCR_BREAK_EN_R {
                RB_LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_R {
                RB_LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_word_sz(&mut self) -> RB_LCR_WORD_SZ_W<0> {
                RB_LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_stop_bit(&mut self) -> RB_LCR_STOP_BIT_W<2> {
                RB_LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_en(&mut self) -> RB_LCR_PAR_EN_W<3> {
                RB_LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_mod(&mut self) -> RB_LCR_PAR_MOD_W<4> {
                RB_LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_break_en(&mut self) -> RB_LCR_BREAK_EN_W<6> {
                RB_LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&mut self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                RB_LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_lcr](index.html) module
        pub struct R8_UART0_LCR_SPEC;
        impl crate::RegisterSpec for R8_UART0_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_lcr::R](R) reader structure
        impl crate::Readable for R8_UART0_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_lcr::W](W) writer structure
        impl crate::Writable for R8_UART0_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_LCR to value 0
        impl crate::Resettable for R8_UART0_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_IIR (r) register accessor: an alias for `Reg<R8_UART0_IIR_SPEC>`
    pub type R8_UART0_IIR = crate::Reg<r8_uart0_iir::R8_UART0_IIR_SPEC>;
    ///RO, UART0 interrupt identification
    pub mod r8_uart0_iir {
        ///Register `R8_UART0_IIR` reader
        pub struct R(crate::R<R8_UART0_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type RB_IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `RB_IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type RB_IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `RB_IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type RB_IIR_FIFO_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn rb_iir_no_int(&self) -> RB_IIR_NO_INT_R {
                RB_IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn rb_iir_int_mask(&self) -> RB_IIR_INT_MASK_R {
                RB_IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn rb_iir_fifo_id(&self) -> RB_IIR_FIFO_ID_R {
                RB_IIR_FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART0 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_iir](index.html) module
        pub struct R8_UART0_IIR_SPEC;
        impl crate::RegisterSpec for R8_UART0_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_iir::R](R) reader structure
        impl crate::Readable for R8_UART0_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_IIR to value 0x01
        impl crate::Resettable for R8_UART0_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_UART0_LSR (r) register accessor: an alias for `Reg<R8_UART0_LSR_SPEC>`
    pub type R8_UART0_LSR = crate::Reg<r8_uart0_lsr::R8_UART0_LSR_SPEC>;
    ///RO, UART0 line status
    pub mod r8_uart0_lsr {
        ///Register `R8_UART0_LSR` reader
        pub struct R(crate::R<R8_UART0_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type RB_LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `RB_LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type RB_LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type RB_LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type RB_LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type RB_LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type RB_LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type RB_LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type RB_LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn rb_lsr_data_rdy(&self) -> RB_LSR_DATA_RDY_R {
                RB_LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn rb_lsr_over_err(&self) -> RB_LSR_OVER_ERR_R {
                RB_LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn rb_lsr_par_err(&self) -> RB_LSR_PAR_ERR_R {
                RB_LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn rb_lsr_frame_err(&self) -> RB_LSR_FRAME_ERR_R {
                RB_LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn rb_lsr_break_err(&self) -> RB_LSR_BREAK_ERR_R {
                RB_LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn rb_lsr_tx_fifo_emp(&self) -> RB_LSR_TX_FIFO_EMP_R {
                RB_LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn rb_lsr_tx_all_emp(&self) -> RB_LSR_TX_ALL_EMP_R {
                RB_LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn rb_lsr_err_rx_fifo(&self) -> RB_LSR_ERR_RX_FIFO_R {
                RB_LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_lsr](index.html) module
        pub struct R8_UART0_LSR_SPEC;
        impl crate::RegisterSpec for R8_UART0_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_lsr::R](R) reader structure
        impl crate::Readable for R8_UART0_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_LSR to value 0x60
        impl crate::Resettable for R8_UART0_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///R8_UART0_MSR (r) register accessor: an alias for `Reg<R8_UART0_MSR_SPEC>`
    pub type R8_UART0_MSR = crate::Reg<r8_uart0_msr::R8_UART0_MSR_SPEC>;
    ///RO, UART0 modem status
    pub mod r8_uart0_msr {
        ///Register `R8_UART0_MSR` reader
        pub struct R(crate::R<R8_UART0_MSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_MSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_MSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_MSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_MSR_CTS_CHG` reader - RZ, UART0 CTS changed status, high action
        pub type RB_MSR_CTS_CHG_R = crate::BitReader<bool>;
        ///Field `RB_MSR_DSR_CHG` reader - RZ, UART0 DSR changed status, high action
        pub type RB_MSR_DSR_CHG_R = crate::BitReader<bool>;
        ///Field `RB_MSR_RI_CHG` reader - RZ, UART0 RI changed status, high action
        pub type RB_MSR_RI_CHG_R = crate::BitReader<bool>;
        ///Field `RB_MSR_DCD_CHG` reader - RZ, UART0 DCD changed status, high action
        pub type RB_MSR_DCD_CHG_R = crate::BitReader<bool>;
        ///Field `RB_MSR_CTS` reader - RO, UART0 CTS action status
        pub type RB_MSR_CTS_R = crate::BitReader<bool>;
        ///Field `RB_MSR_DSR` reader - RO, UART0 DSR action statusv
        pub type RB_MSR_DSR_R = crate::BitReader<bool>;
        ///Field `RB_MSR_RI` reader - RO, UART0 RI action status
        pub type RB_MSR_RI_R = crate::BitReader<bool>;
        ///Field `RB_MSR_DCD` reader - RO, UART0 DCD action status
        pub type RB_MSR_DCD_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RZ, UART0 CTS changed status, high action
            #[inline(always)]
            pub fn rb_msr_cts_chg(&self) -> RB_MSR_CTS_CHG_R {
                RB_MSR_CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART0 DSR changed status, high action
            #[inline(always)]
            pub fn rb_msr_dsr_chg(&self) -> RB_MSR_DSR_CHG_R {
                RB_MSR_DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART0 RI changed status, high action
            #[inline(always)]
            pub fn rb_msr_ri_chg(&self) -> RB_MSR_RI_CHG_R {
                RB_MSR_RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART0 DCD changed status, high action
            #[inline(always)]
            pub fn rb_msr_dcd_chg(&self) -> RB_MSR_DCD_CHG_R {
                RB_MSR_DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, UART0 CTS action status
            #[inline(always)]
            pub fn rb_msr_cts(&self) -> RB_MSR_CTS_R {
                RB_MSR_CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART0 DSR action statusv
            #[inline(always)]
            pub fn rb_msr_dsr(&self) -> RB_MSR_DSR_R {
                RB_MSR_DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART0 RI action status
            #[inline(always)]
            pub fn rb_msr_ri(&self) -> RB_MSR_RI_R {
                RB_MSR_RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, UART0 DCD action status
            #[inline(always)]
            pub fn rb_msr_dcd(&self) -> RB_MSR_DCD_R {
                RB_MSR_DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 modem status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_msr](index.html) module
        pub struct R8_UART0_MSR_SPEC;
        impl crate::RegisterSpec for R8_UART0_MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_msr::R](R) reader structure
        impl crate::Readable for R8_UART0_MSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_MSR to value 0
        impl crate::Resettable for R8_UART0_MSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_RBR (r) register accessor: an alias for `Reg<R8_UART0_RBR_SPEC>`
    pub type R8_UART0_RBR = crate::Reg<r8_uart0_rbr::R8_UART0_RBR_SPEC>;
    ///RO, UART0 receiver buffer, receiving byte
    pub mod r8_uart0_rbr {
        ///Register `R8_UART0_RBR` reader
        pub struct R(crate::R<R8_UART0_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART0_RBR` reader - RO, UART0 receiver buffer, receiving byte
        pub type R8_UART0_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver buffer, receiving byte
            #[inline(always)]
            pub fn r8_uart0_rbr(&self) -> R8_UART0_RBR_R {
                R8_UART0_RBR_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_rbr](index.html) module
        pub struct R8_UART0_RBR_SPEC;
        impl crate::RegisterSpec for R8_UART0_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_rbr::R](R) reader structure
        impl crate::Readable for R8_UART0_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_RBR to value 0
        impl crate::Resettable for R8_UART0_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_THR (w) register accessor: an alias for `Reg<R8_UART0_THR_SPEC>`
    pub type R8_UART0_THR = crate::Reg<r8_uart0_thr::R8_UART0_THR_SPEC>;
    ///WO, UART0 transmitter holding, transmittal byte
    pub mod r8_uart0_thr {
        ///Register `R8_UART0_THR` writer
        pub struct W(crate::W<R8_UART0_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART0_THR` writer - RO, UART0 transmitter holding, transmittal byte
        pub type R8_UART0_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - RO, UART0 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn r8_uart0_thr(&mut self) -> R8_UART0_THR_W<0> {
                R8_UART0_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART0 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_thr](index.html) module
        pub struct R8_UART0_THR_SPEC;
        impl crate::RegisterSpec for R8_UART0_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [r8_uart0_thr::W](W) writer structure
        impl crate::Writable for R8_UART0_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_THR to value 0
        impl crate::Resettable for R8_UART0_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_RFC (r) register accessor: an alias for `Reg<R8_UART0_RFC_SPEC>`
    pub type R8_UART0_RFC = crate::Reg<r8_uart0_rfc::R8_UART0_RFC_SPEC>;
    ///RO, UART0 receiver FIFO count
    pub mod r8_uart0_rfc {
        ///Register `R8_UART0_RFC` reader
        pub struct R(crate::R<R8_UART0_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART0_RFC` reader - RO, UART0 receiver FIFO count
        pub type R8_UART0_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver FIFO count
            #[inline(always)]
            pub fn r8_uart0_rfc(&self) -> R8_UART0_RFC_R {
                R8_UART0_RFC_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_rfc](index.html) module
        pub struct R8_UART0_RFC_SPEC;
        impl crate::RegisterSpec for R8_UART0_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_rfc::R](R) reader structure
        impl crate::Readable for R8_UART0_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_RFC to value 0
        impl crate::Resettable for R8_UART0_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_TFC (r) register accessor: an alias for `Reg<R8_UART0_TFC_SPEC>`
    pub type R8_UART0_TFC = crate::Reg<r8_uart0_tfc::R8_UART0_TFC_SPEC>;
    ///RO, UART0 transmitter FIFO count
    pub mod r8_uart0_tfc {
        ///Register `R8_UART0_TFC` reader
        pub struct R(crate::R<R8_UART0_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART0_TFC` reader - RO, UART0 transmitter FIFO count
        pub type R8_UART0_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 transmitter FIFO count
            #[inline(always)]
            pub fn r8_uart0_tfc(&self) -> R8_UART0_TFC_R {
                R8_UART0_TFC_R::new(self.bits)
            }
        }
        ///RO, UART0 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_tfc](index.html) module
        pub struct R8_UART0_TFC_SPEC;
        impl crate::RegisterSpec for R8_UART0_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_tfc::R](R) reader structure
        impl crate::Readable for R8_UART0_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART0_TFC to value 0
        impl crate::Resettable for R8_UART0_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UART0_DL (rw) register accessor: an alias for `Reg<R16_UART0_DL_SPEC>`
    pub type R16_UART0_DL = crate::Reg<r16_uart0_dl::R16_UART0_DL_SPEC>;
    ///RW, UART0 divisor latch
    pub mod r16_uart0_dl {
        ///Register `R16_UART0_DL` reader
        pub struct R(crate::R<R16_UART0_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UART0_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UART0_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UART0_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UART0_DL` writer
        pub struct W(crate::W<R16_UART0_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UART0_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UART0_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UART0_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UART0_DL` reader - RW, UART0 divisor latch
        pub type R16_UART0_DL_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UART0_DL` writer - RW, UART0 divisor latch
        pub type R16_UART0_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UART0_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            pub fn r16_uart0_dl(&self) -> R16_UART0_DL_R {
                R16_UART0_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn r16_uart0_dl(&mut self) -> R16_UART0_DL_W<0> {
                R16_UART0_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uart0_dl](index.html) module
        pub struct R16_UART0_DL_SPEC;
        impl crate::RegisterSpec for R16_UART0_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uart0_dl::R](R) reader structure
        impl crate::Readable for R16_UART0_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uart0_dl::W](W) writer structure
        impl crate::Writable for R16_UART0_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UART0_DL to value 0
        impl crate::Resettable for R16_UART0_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_DIV (rw) register accessor: an alias for `Reg<R8_UART0_DIV_SPEC>`
    pub type R8_UART0_DIV = crate::Reg<r8_uart0_div::R8_UART0_DIV_SPEC>;
    ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    pub mod r8_uart0_div {
        ///Register `R8_UART0_DIV` reader
        pub struct R(crate::R<R8_UART0_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_DIV` writer
        pub struct W(crate::W<R8_UART0_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART0_DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type R8_UART0_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UART0_DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type R8_UART0_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            pub fn r8_uart0_div(&self) -> R8_UART0_DIV_R {
                R8_UART0_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            #[must_use]
            pub fn r8_uart0_div(&mut self) -> R8_UART0_DIV_W<0> {
                R8_UART0_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_div](index.html) module
        pub struct R8_UART0_DIV_SPEC;
        impl crate::RegisterSpec for R8_UART0_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_div::R](R) reader structure
        impl crate::Readable for R8_UART0_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_div::W](W) writer structure
        impl crate::Writable for R8_UART0_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_DIV to value 0
        impl crate::Resettable for R8_UART0_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART0_ADR (rw) register accessor: an alias for `Reg<R8_UART0_ADR_SPEC>`
    pub type R8_UART0_ADR = crate::Reg<r8_uart0_adr::R8_UART0_ADR_SPEC>;
    ///RW, UART0 slave address: 0xFF=disable, other=enable
    pub mod r8_uart0_adr {
        ///Register `R8_UART0_ADR` reader
        pub struct R(crate::R<R8_UART0_ADR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART0_ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART0_ADR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART0_ADR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART0_ADR` writer
        pub struct W(crate::W<R8_UART0_ADR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART0_ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART0_ADR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART0_ADR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART0_ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type R8_UART0_ADR_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UART0_ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type R8_UART0_ADR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART0_ADR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            pub fn r8_uart0_adr(&self) -> R8_UART0_ADR_R {
                R8_UART0_ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            #[must_use]
            pub fn r8_uart0_adr(&mut self) -> R8_UART0_ADR_W<0> {
                R8_UART0_ADR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 slave address: 0xFF=disable, other=enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart0_adr](index.html) module
        pub struct R8_UART0_ADR_SPEC;
        impl crate::RegisterSpec for R8_UART0_ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart0_adr::R](R) reader structure
        impl crate::Readable for R8_UART0_ADR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart0_adr::W](W) writer structure
        impl crate::Writable for R8_UART0_ADR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART0_ADR to value 0xff
        impl crate::Resettable for R8_UART0_ADR_SPEC {
            const RESET_VALUE: Self::Ux = 0xff;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub mod uart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART1 modem control
        pub r8_uart1_mcr: R8_UART1_MCR,
        ///0x01 - RW, UART1 interrupt enable
        pub r8_uart1_ier: R8_UART1_IER,
        ///0x02 - RW, UART1 FIFO control
        pub r8_uart1_fcr: R8_UART1_FCR,
        ///0x03 - RW, UART1 line control
        pub r8_uart1_lcr: R8_UART1_LCR,
        ///0x04 - RO, UART1 interrupt identification
        pub r8_uart1_iir: R8_UART1_IIR,
        ///0x05 - RO, UART1 line status
        pub r8_uart1_lsr: R8_UART1_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_r8_uart1: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART1 receiver FIFO count
        pub r8_uart1_rfc: R8_UART1_RFC,
        ///0x0b - RO, UART1 transmitter FIFO count
        pub r8_uart1_tfc: R8_UART1_TFC,
        ///0x0c - RW, UART1 divisor latch
        pub r16_uart1_dl: R16_UART1_DL,
        ///0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub r8_uart1_div: R8_UART1_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART1 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn r8_uart1_thr(&self) -> &R8_UART1_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART1 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn r8_uart1_rbr(&self) -> &R8_UART1_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///R8_UART1_MCR (rw) register accessor: an alias for `Reg<R8_UART1_MCR_SPEC>`
    pub type R8_UART1_MCR = crate::Reg<r8_uart1_mcr::R8_UART1_MCR_SPEC>;
    ///RW, UART1 modem control
    pub mod r8_uart1_mcr {
        ///Register `R8_UART1_MCR` reader
        pub struct R(crate::R<R8_UART1_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART1_MCR` writer
        pub struct W(crate::W<R8_UART1_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&self) -> RB_MCR_OUT2__RB_MCR_INT_OE_R {
                RB_MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&mut self) -> RB_MCR_OUT2__RB_MCR_INT_OE_W<3> {
                RB_MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_mcr](index.html) module
        pub struct R8_UART1_MCR_SPEC;
        impl crate::RegisterSpec for R8_UART1_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_mcr::R](R) reader structure
        impl crate::Readable for R8_UART1_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart1_mcr::W](W) writer structure
        impl crate::Writable for R8_UART1_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_MCR to value 0
        impl crate::Resettable for R8_UART1_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_IER (rw) register accessor: an alias for `Reg<R8_UART1_IER_SPEC>`
    pub type R8_UART1_IER = crate::Reg<r8_uart1_ier::R8_UART1_IER_SPEC>;
    ///RW, UART1 interrupt enable
    pub mod r8_uart1_ier {
        ///Register `R8_UART1_IER` reader
        pub struct R(crate::R<R8_UART1_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART1_IER` writer
        pub struct W(crate::W<R8_UART1_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `RB_IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_IER_SPEC, bool, O>;
        ///Field `RB_IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `RB_IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_IER_SPEC, bool, O>;
        ///Field `RB_IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `RB_IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_IER_SPEC, bool, O>;
        ///Field `RB_IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_IER_SPEC, bool, O>;
        ///Field `RB_IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_R = crate::BitReader<bool>;
        ///Field `RB_IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn rb_ier_recv_rdy(&self) -> RB_IER_RECV_RDY_R {
                RB_IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn rb_ier_thr_empty(&self) -> RB_IER_THR_EMPTY_R {
                RB_IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn rb_ier_line_stat(&self) -> RB_IER_LINE_STAT_R {
                RB_IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn rb_ier_txd_en(&self) -> RB_IER_TXD_EN_R {
                RB_IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn rb_ier_reset(&self) -> RB_IER_RESET_R {
                RB_IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_recv_rdy(&mut self) -> RB_IER_RECV_RDY_W<0> {
                RB_IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_thr_empty(&mut self) -> RB_IER_THR_EMPTY_W<1> {
                RB_IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_line_stat(&mut self) -> RB_IER_LINE_STAT_W<2> {
                RB_IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_txd_en(&mut self) -> RB_IER_TXD_EN_W<6> {
                RB_IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_reset(&mut self) -> RB_IER_RESET_W<7> {
                RB_IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_ier](index.html) module
        pub struct R8_UART1_IER_SPEC;
        impl crate::RegisterSpec for R8_UART1_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_ier::R](R) reader structure
        impl crate::Readable for R8_UART1_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart1_ier::W](W) writer structure
        impl crate::Writable for R8_UART1_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_IER to value 0
        impl crate::Resettable for R8_UART1_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_FCR (rw) register accessor: an alias for `Reg<R8_UART1_FCR_SPEC>`
    pub type R8_UART1_FCR = crate::Reg<r8_uart1_fcr::R8_UART1_FCR_SPEC>;
    ///RW, UART1 FIFO control
    pub mod r8_uart1_fcr {
        ///Register `R8_UART1_FCR` reader
        pub struct R(crate::R<R8_UART1_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART1_FCR` writer
        pub struct W(crate::W<R8_UART1_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `RB_FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `RB_FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART1_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn rb_fcr_fifo_en(&self) -> RB_FCR_FIFO_EN_R {
                RB_FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_rx_fifo_clr(&self) -> RB_FCR_RX_FIFO_CLR_R {
                RB_FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_tx_fifo_clr(&self) -> RB_FCR_TX_FIFO_CLR_R {
                RB_FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn rb_fcr_fifo_trig(&self) -> RB_FCR_FIFO_TRIG_R {
                RB_FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_en(&mut self) -> RB_FCR_FIFO_EN_W<0> {
                RB_FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_rx_fifo_clr(&mut self) -> RB_FCR_RX_FIFO_CLR_W<1> {
                RB_FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_tx_fifo_clr(&mut self) -> RB_FCR_TX_FIFO_CLR_W<2> {
                RB_FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_trig(&mut self) -> RB_FCR_FIFO_TRIG_W<6> {
                RB_FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_fcr](index.html) module
        pub struct R8_UART1_FCR_SPEC;
        impl crate::RegisterSpec for R8_UART1_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_fcr::R](R) reader structure
        impl crate::Readable for R8_UART1_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart1_fcr::W](W) writer structure
        impl crate::Writable for R8_UART1_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_FCR to value 0
        impl crate::Resettable for R8_UART1_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_LCR (rw) register accessor: an alias for `Reg<R8_UART1_LCR_SPEC>`
    pub type R8_UART1_LCR = crate::Reg<r8_uart1_lcr::R8_UART1_LCR_SPEC>;
    ///RW, UART1 line control
    pub mod r8_uart1_lcr {
        ///Register `R8_UART1_LCR` reader
        pub struct R(crate::R<R8_UART1_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART1_LCR` writer
        pub struct W(crate::W<R8_UART1_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART1_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_EN` reader - RW, UART parity enable
        pub type RB_LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_PAR_EN` writer - RW, UART parity enable
        pub type RB_LCR_PAR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART1_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_BREAK_EN` reader - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_BREAK_EN` writer - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART1_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn rb_lcr_word_sz(&self) -> RB_LCR_WORD_SZ_R {
                RB_LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn rb_lcr_stop_bit(&self) -> RB_LCR_STOP_BIT_R {
                RB_LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn rb_lcr_par_en(&self) -> RB_LCR_PAR_EN_R {
                RB_LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn rb_lcr_par_mod(&self) -> RB_LCR_PAR_MOD_R {
                RB_LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn rb_lcr_break_en(&self) -> RB_LCR_BREAK_EN_R {
                RB_LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_R {
                RB_LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_word_sz(&mut self) -> RB_LCR_WORD_SZ_W<0> {
                RB_LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_stop_bit(&mut self) -> RB_LCR_STOP_BIT_W<2> {
                RB_LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_en(&mut self) -> RB_LCR_PAR_EN_W<3> {
                RB_LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_mod(&mut self) -> RB_LCR_PAR_MOD_W<4> {
                RB_LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_break_en(&mut self) -> RB_LCR_BREAK_EN_W<6> {
                RB_LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&mut self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                RB_LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_lcr](index.html) module
        pub struct R8_UART1_LCR_SPEC;
        impl crate::RegisterSpec for R8_UART1_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_lcr::R](R) reader structure
        impl crate::Readable for R8_UART1_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart1_lcr::W](W) writer structure
        impl crate::Writable for R8_UART1_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_LCR to value 0
        impl crate::Resettable for R8_UART1_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_IIR (r) register accessor: an alias for `Reg<R8_UART1_IIR_SPEC>`
    pub type R8_UART1_IIR = crate::Reg<r8_uart1_iir::R8_UART1_IIR_SPEC>;
    ///RO, UART1 interrupt identification
    pub mod r8_uart1_iir {
        ///Register `R8_UART1_IIR` reader
        pub struct R(crate::R<R8_UART1_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type RB_IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `RB_IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type RB_IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `RB_IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type RB_IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn rb_iir_no_int(&self) -> RB_IIR_NO_INT_R {
                RB_IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn rb_iir_int_mask(&self) -> RB_IIR_INT_MASK_R {
                RB_IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn rb_iir_fifo_id(&self) -> RB_IIR_FIFO_ID_R {
                RB_IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_iir](index.html) module
        pub struct R8_UART1_IIR_SPEC;
        impl crate::RegisterSpec for R8_UART1_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_iir::R](R) reader structure
        impl crate::Readable for R8_UART1_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART1_IIR to value 0x01
        impl crate::Resettable for R8_UART1_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_UART1_LSR (r) register accessor: an alias for `Reg<R8_UART1_LSR_SPEC>`
    pub type R8_UART1_LSR = crate::Reg<r8_uart1_lsr::R8_UART1_LSR_SPEC>;
    ///RO, UART1 line status
    pub mod r8_uart1_lsr {
        ///Register `R8_UART1_LSR` reader
        pub struct R(crate::R<R8_UART1_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type RB_LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `RB_LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type RB_LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type RB_LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type RB_LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type RB_LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type RB_LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type RB_LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type RB_LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn rb_lsr_data_rdy(&self) -> RB_LSR_DATA_RDY_R {
                RB_LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn rb_lsr_over_err(&self) -> RB_LSR_OVER_ERR_R {
                RB_LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn rb_lsr_par_err(&self) -> RB_LSR_PAR_ERR_R {
                RB_LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn rb_lsr_frame_err(&self) -> RB_LSR_FRAME_ERR_R {
                RB_LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn rb_lsr_break_err(&self) -> RB_LSR_BREAK_ERR_R {
                RB_LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn rb_lsr_tx_fifo_emp(&self) -> RB_LSR_TX_FIFO_EMP_R {
                RB_LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn rb_lsr_tx_all_emp(&self) -> RB_LSR_TX_ALL_EMP_R {
                RB_LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn rb_lsr_err_rx_fifo(&self) -> RB_LSR_ERR_RX_FIFO_R {
                RB_LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_lsr](index.html) module
        pub struct R8_UART1_LSR_SPEC;
        impl crate::RegisterSpec for R8_UART1_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_lsr::R](R) reader structure
        impl crate::Readable for R8_UART1_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART1_LSR to value 0x60
        impl crate::Resettable for R8_UART1_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///R8_UART1_RBR (r) register accessor: an alias for `Reg<R8_UART1_RBR_SPEC>`
    pub type R8_UART1_RBR = crate::Reg<r8_uart1_rbr::R8_UART1_RBR_SPEC>;
    ///RO, UART1 receiver buffer, receiving byte
    pub mod r8_uart1_rbr {
        ///Register `R8_UART1_RBR` reader
        pub struct R(crate::R<R8_UART1_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART1_RBR` reader - RO, UART1 receiver buffer, receiving byte
        pub type R8_UART1_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver buffer, receiving byte
            #[inline(always)]
            pub fn r8_uart1_rbr(&self) -> R8_UART1_RBR_R {
                R8_UART1_RBR_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_rbr](index.html) module
        pub struct R8_UART1_RBR_SPEC;
        impl crate::RegisterSpec for R8_UART1_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_rbr::R](R) reader structure
        impl crate::Readable for R8_UART1_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART1_RBR to value 0
        impl crate::Resettable for R8_UART1_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_THR (w) register accessor: an alias for `Reg<R8_UART1_THR_SPEC>`
    pub type R8_UART1_THR = crate::Reg<r8_uart1_thr::R8_UART1_THR_SPEC>;
    ///WO, UART1 transmitter holding, transmittal byte
    pub mod r8_uart1_thr {
        ///Register `R8_UART1_THR` writer
        pub struct W(crate::W<R8_UART1_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART1_RBR` writer - WO, UART1 transmitter holding, transmittal byte
        pub type R8_UART1_RBR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART1_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART1 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn r8_uart1_rbr(&mut self) -> R8_UART1_RBR_W<0> {
                R8_UART1_RBR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART1 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_thr](index.html) module
        pub struct R8_UART1_THR_SPEC;
        impl crate::RegisterSpec for R8_UART1_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [r8_uart1_thr::W](W) writer structure
        impl crate::Writable for R8_UART1_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_THR to value 0
        impl crate::Resettable for R8_UART1_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_RFC (r) register accessor: an alias for `Reg<R8_UART1_RFC_SPEC>`
    pub type R8_UART1_RFC = crate::Reg<r8_uart1_rfc::R8_UART1_RFC_SPEC>;
    ///RO, UART1 receiver FIFO count
    pub mod r8_uart1_rfc {
        ///Register `R8_UART1_RFC` reader
        pub struct R(crate::R<R8_UART1_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART1_RFC` reader - RO, UART1 receiver FIFO count
        pub type R8_UART1_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn r8_uart1_rfc(&self) -> R8_UART1_RFC_R {
                R8_UART1_RFC_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_rfc](index.html) module
        pub struct R8_UART1_RFC_SPEC;
        impl crate::RegisterSpec for R8_UART1_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_rfc::R](R) reader structure
        impl crate::Readable for R8_UART1_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART1_RFC to value 0
        impl crate::Resettable for R8_UART1_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_TFC (r) register accessor: an alias for `Reg<R8_UART1_TFC_SPEC>`
    pub type R8_UART1_TFC = crate::Reg<r8_uart1_tfc::R8_UART1_TFC_SPEC>;
    ///RO, UART1 transmitter FIFO count
    pub mod r8_uart1_tfc {
        ///Register `R8_UART1_TFC` reader
        pub struct R(crate::R<R8_UART1_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART1_TFC` reader - RO, UART1 receiver FIFO count
        pub type R8_UART1_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn r8_uart1_tfc(&self) -> R8_UART1_TFC_R {
                R8_UART1_TFC_R::new(self.bits)
            }
        }
        ///RO, UART1 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_tfc](index.html) module
        pub struct R8_UART1_TFC_SPEC;
        impl crate::RegisterSpec for R8_UART1_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_tfc::R](R) reader structure
        impl crate::Readable for R8_UART1_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART1_TFC to value 0
        impl crate::Resettable for R8_UART1_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UART1_DL (rw) register accessor: an alias for `Reg<R16_UART1_DL_SPEC>`
    pub type R16_UART1_DL = crate::Reg<r16_uart1_dl::R16_UART1_DL_SPEC>;
    ///RW, UART1 divisor latch
    pub mod r16_uart1_dl {
        ///Register `R16_UART1_DL` reader
        pub struct R(crate::R<R16_UART1_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UART1_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UART1_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UART1_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UART1_DL` writer
        pub struct W(crate::W<R16_UART1_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UART1_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UART1_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UART1_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UART1_DL` reader - RW, UART1 divisor latch
        pub type R16_UART1_DL_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UART1_DL` writer - RW, UART1 divisor latch
        pub type R16_UART1_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UART1_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            pub fn r16_uart1_dl(&self) -> R16_UART1_DL_R {
                R16_UART1_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn r16_uart1_dl(&mut self) -> R16_UART1_DL_W<0> {
                R16_UART1_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uart1_dl](index.html) module
        pub struct R16_UART1_DL_SPEC;
        impl crate::RegisterSpec for R16_UART1_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uart1_dl::R](R) reader structure
        impl crate::Readable for R16_UART1_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uart1_dl::W](W) writer structure
        impl crate::Writable for R16_UART1_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UART1_DL to value 0
        impl crate::Resettable for R16_UART1_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART1_DIV (rw) register accessor: an alias for `Reg<R8_UART1_DIV_SPEC>`
    pub type R8_UART1_DIV = crate::Reg<r8_uart1_div::R8_UART1_DIV_SPEC>;
    ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod r8_uart1_div {
        ///Register `R8_UART1_DIV` reader
        pub struct R(crate::R<R8_UART1_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART1_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART1_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART1_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART1_DIV` writer
        pub struct W(crate::W<R8_UART1_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART1_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART1_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART1_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART1_DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART1_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UART1_DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART1_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART1_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn r8_uart1_div(&self) -> R8_UART1_DIV_R {
                R8_UART1_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn r8_uart1_div(&mut self) -> R8_UART1_DIV_W<0> {
                R8_UART1_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart1_div](index.html) module
        pub struct R8_UART1_DIV_SPEC;
        impl crate::RegisterSpec for R8_UART1_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart1_div::R](R) reader structure
        impl crate::Readable for R8_UART1_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart1_div::W](W) writer structure
        impl crate::Writable for R8_UART1_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART1_DIV to value 0
        impl crate::Resettable for R8_UART1_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart2::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub mod uart2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART2 modem control
        pub r8_uart2_mcr: R8_UART2_MCR,
        ///0x01 - RW, UART2 interrupt enable
        pub r8_uart2_ier: R8_UART2_IER,
        ///0x02 - RW, UART2 FIFO control
        pub r8_uart2_fcr: R8_UART2_FCR,
        ///0x03 - RW, UART2 line control
        pub r8_uart2_lcr: R8_UART2_LCR,
        ///0x04 - RO, UART2 interrupt identification
        pub r8_uart2_iir: R8_UART2_IIR,
        ///0x05 - RO, UART2 line status
        pub r8_uart2_lsr: R8_UART2_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_r8_uart2: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART2 receiver FIFO count
        pub r8_uart2_rfc: R8_UART2_RFC,
        ///0x0b - RO, UART2 transmitter FIFO count
        pub r8_uart2_tfc: R8_UART2_TFC,
        ///0x0c - RW, UART2 divisor latch
        pub r16_uart2_dl: R16_UART2_DL,
        ///0x0e - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub r8_uart2_div: R8_UART2_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART2 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn r8_uart2_thr(&self) -> &R8_UART2_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART2 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn r8_uart2_rbr(&self) -> &R8_UART2_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///R8_UART2_MCR (rw) register accessor: an alias for `Reg<R8_UART2_MCR_SPEC>`
    pub type R8_UART2_MCR = crate::Reg<r8_uart2_mcr::R8_UART2_MCR_SPEC>;
    ///RW, UART2 modem control
    pub mod r8_uart2_mcr {
        ///Register `R8_UART2_MCR` reader
        pub struct R(crate::R<R8_UART2_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART2_MCR` writer
        pub struct W(crate::W<R8_UART2_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&self) -> RB_MCR_OUT2__RB_MCR_INT_OE_R {
                RB_MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&mut self) -> RB_MCR_OUT2__RB_MCR_INT_OE_W<3> {
                RB_MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_mcr](index.html) module
        pub struct R8_UART2_MCR_SPEC;
        impl crate::RegisterSpec for R8_UART2_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_mcr::R](R) reader structure
        impl crate::Readable for R8_UART2_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart2_mcr::W](W) writer structure
        impl crate::Writable for R8_UART2_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_MCR to value 0
        impl crate::Resettable for R8_UART2_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_IER (rw) register accessor: an alias for `Reg<R8_UART2_IER_SPEC>`
    pub type R8_UART2_IER = crate::Reg<r8_uart2_ier::R8_UART2_IER_SPEC>;
    ///RW, UART2 interrupt enable
    pub mod r8_uart2_ier {
        ///Register `R8_UART2_IER` reader
        pub struct R(crate::R<R8_UART2_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART2_IER` writer
        pub struct W(crate::W<R8_UART2_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `RB_IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_IER_SPEC, bool, O>;
        ///Field `RB_IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `RB_IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_IER_SPEC, bool, O>;
        ///Field `RB_IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `RB_IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_IER_SPEC, bool, O>;
        ///Field `RB_IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_IER_SPEC, bool, O>;
        ///Field `RB_IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_R = crate::BitReader<bool>;
        ///Field `RB_IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn rb_ier_recv_rdy(&self) -> RB_IER_RECV_RDY_R {
                RB_IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn rb_ier_thr_empty(&self) -> RB_IER_THR_EMPTY_R {
                RB_IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn rb_ier_line_stat(&self) -> RB_IER_LINE_STAT_R {
                RB_IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn rb_ier_txd_en(&self) -> RB_IER_TXD_EN_R {
                RB_IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn rb_ier_reset(&self) -> RB_IER_RESET_R {
                RB_IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_recv_rdy(&mut self) -> RB_IER_RECV_RDY_W<0> {
                RB_IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_thr_empty(&mut self) -> RB_IER_THR_EMPTY_W<1> {
                RB_IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_line_stat(&mut self) -> RB_IER_LINE_STAT_W<2> {
                RB_IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_txd_en(&mut self) -> RB_IER_TXD_EN_W<6> {
                RB_IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_reset(&mut self) -> RB_IER_RESET_W<7> {
                RB_IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_ier](index.html) module
        pub struct R8_UART2_IER_SPEC;
        impl crate::RegisterSpec for R8_UART2_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_ier::R](R) reader structure
        impl crate::Readable for R8_UART2_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart2_ier::W](W) writer structure
        impl crate::Writable for R8_UART2_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_IER to value 0
        impl crate::Resettable for R8_UART2_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_FCR (rw) register accessor: an alias for `Reg<R8_UART2_FCR_SPEC>`
    pub type R8_UART2_FCR = crate::Reg<r8_uart2_fcr::R8_UART2_FCR_SPEC>;
    ///RW, UART2 FIFO control
    pub mod r8_uart2_fcr {
        ///Register `R8_UART2_FCR` reader
        pub struct R(crate::R<R8_UART2_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART2_FCR` writer
        pub struct W(crate::W<R8_UART2_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `RB_FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `RB_FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART2_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn rb_fcr_fifo_en(&self) -> RB_FCR_FIFO_EN_R {
                RB_FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_rx_fifo_clr(&self) -> RB_FCR_RX_FIFO_CLR_R {
                RB_FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_tx_fifo_clr(&self) -> RB_FCR_TX_FIFO_CLR_R {
                RB_FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn rb_fcr_fifo_trig(&self) -> RB_FCR_FIFO_TRIG_R {
                RB_FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_en(&mut self) -> RB_FCR_FIFO_EN_W<0> {
                RB_FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_rx_fifo_clr(&mut self) -> RB_FCR_RX_FIFO_CLR_W<1> {
                RB_FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_tx_fifo_clr(&mut self) -> RB_FCR_TX_FIFO_CLR_W<2> {
                RB_FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_trig(&mut self) -> RB_FCR_FIFO_TRIG_W<6> {
                RB_FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_fcr](index.html) module
        pub struct R8_UART2_FCR_SPEC;
        impl crate::RegisterSpec for R8_UART2_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_fcr::R](R) reader structure
        impl crate::Readable for R8_UART2_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart2_fcr::W](W) writer structure
        impl crate::Writable for R8_UART2_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_FCR to value 0
        impl crate::Resettable for R8_UART2_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_LCR (rw) register accessor: an alias for `Reg<R8_UART2_LCR_SPEC>`
    pub type R8_UART2_LCR = crate::Reg<r8_uart2_lcr::R8_UART2_LCR_SPEC>;
    ///RW, UART2 line control
    pub mod r8_uart2_lcr {
        ///Register `R8_UART2_LCR` reader
        pub struct R(crate::R<R8_UART2_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART2_LCR` writer
        pub struct W(crate::W<R8_UART2_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART2_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_EN` reader - RW, UART parity enable
        pub type RB_LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_PAR_EN` writer - RW, UART parity enable
        pub type RB_LCR_PAR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART2_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_BREAK_EN` reader - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_BREAK_EN` writer - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART2_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn rb_lcr_word_sz(&self) -> RB_LCR_WORD_SZ_R {
                RB_LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn rb_lcr_stop_bit(&self) -> RB_LCR_STOP_BIT_R {
                RB_LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn rb_lcr_par_en(&self) -> RB_LCR_PAR_EN_R {
                RB_LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn rb_lcr_par_mod(&self) -> RB_LCR_PAR_MOD_R {
                RB_LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn rb_lcr_break_en(&self) -> RB_LCR_BREAK_EN_R {
                RB_LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_R {
                RB_LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_word_sz(&mut self) -> RB_LCR_WORD_SZ_W<0> {
                RB_LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_stop_bit(&mut self) -> RB_LCR_STOP_BIT_W<2> {
                RB_LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_en(&mut self) -> RB_LCR_PAR_EN_W<3> {
                RB_LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_mod(&mut self) -> RB_LCR_PAR_MOD_W<4> {
                RB_LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_break_en(&mut self) -> RB_LCR_BREAK_EN_W<6> {
                RB_LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&mut self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                RB_LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_lcr](index.html) module
        pub struct R8_UART2_LCR_SPEC;
        impl crate::RegisterSpec for R8_UART2_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_lcr::R](R) reader structure
        impl crate::Readable for R8_UART2_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart2_lcr::W](W) writer structure
        impl crate::Writable for R8_UART2_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_LCR to value 0
        impl crate::Resettable for R8_UART2_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_IIR (r) register accessor: an alias for `Reg<R8_UART2_IIR_SPEC>`
    pub type R8_UART2_IIR = crate::Reg<r8_uart2_iir::R8_UART2_IIR_SPEC>;
    ///RO, UART2 interrupt identification
    pub mod r8_uart2_iir {
        ///Register `R8_UART2_IIR` reader
        pub struct R(crate::R<R8_UART2_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type RB_IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `RB_IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type RB_IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `RB_IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type RB_IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn rb_iir_no_int(&self) -> RB_IIR_NO_INT_R {
                RB_IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn rb_iir_int_mask(&self) -> RB_IIR_INT_MASK_R {
                RB_IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn rb_iir_fifo_id(&self) -> RB_IIR_FIFO_ID_R {
                RB_IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_iir](index.html) module
        pub struct R8_UART2_IIR_SPEC;
        impl crate::RegisterSpec for R8_UART2_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_iir::R](R) reader structure
        impl crate::Readable for R8_UART2_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART2_IIR to value 0x01
        impl crate::Resettable for R8_UART2_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_UART2_LSR (r) register accessor: an alias for `Reg<R8_UART2_LSR_SPEC>`
    pub type R8_UART2_LSR = crate::Reg<r8_uart2_lsr::R8_UART2_LSR_SPEC>;
    ///RO, UART2 line status
    pub mod r8_uart2_lsr {
        ///Register `R8_UART2_LSR` reader
        pub struct R(crate::R<R8_UART2_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type RB_LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `RB_LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type RB_LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type RB_LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type RB_LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type RB_LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type RB_LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type RB_LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type RB_LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn rb_lsr_data_rdy(&self) -> RB_LSR_DATA_RDY_R {
                RB_LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn rb_lsr_over_err(&self) -> RB_LSR_OVER_ERR_R {
                RB_LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn rb_lsr_par_err(&self) -> RB_LSR_PAR_ERR_R {
                RB_LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn rb_lsr_frame_err(&self) -> RB_LSR_FRAME_ERR_R {
                RB_LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn rb_lsr_break_err(&self) -> RB_LSR_BREAK_ERR_R {
                RB_LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn rb_lsr_tx_fifo_emp(&self) -> RB_LSR_TX_FIFO_EMP_R {
                RB_LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn rb_lsr_tx_all_emp(&self) -> RB_LSR_TX_ALL_EMP_R {
                RB_LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn rb_lsr_err_rx_fifo(&self) -> RB_LSR_ERR_RX_FIFO_R {
                RB_LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_lsr](index.html) module
        pub struct R8_UART2_LSR_SPEC;
        impl crate::RegisterSpec for R8_UART2_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_lsr::R](R) reader structure
        impl crate::Readable for R8_UART2_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART2_LSR to value 0x60
        impl crate::Resettable for R8_UART2_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///R8_UART2_RBR (r) register accessor: an alias for `Reg<R8_UART2_RBR_SPEC>`
    pub type R8_UART2_RBR = crate::Reg<r8_uart2_rbr::R8_UART2_RBR_SPEC>;
    ///RO, UART2 receiver buffer, receiving byte
    pub mod r8_uart2_rbr {
        ///Register `R8_UART2_RBR` reader
        pub struct R(crate::R<R8_UART2_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART2_RBR` reader - RO, UART2 receiver buffer, receiving byte
        pub type R8_UART2_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver buffer, receiving byte
            #[inline(always)]
            pub fn r8_uart2_rbr(&self) -> R8_UART2_RBR_R {
                R8_UART2_RBR_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_rbr](index.html) module
        pub struct R8_UART2_RBR_SPEC;
        impl crate::RegisterSpec for R8_UART2_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_rbr::R](R) reader structure
        impl crate::Readable for R8_UART2_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART2_RBR to value 0
        impl crate::Resettable for R8_UART2_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_THR (w) register accessor: an alias for `Reg<R8_UART2_THR_SPEC>`
    pub type R8_UART2_THR = crate::Reg<r8_uart2_thr::R8_UART2_THR_SPEC>;
    ///WO, UART2 transmitter holding, transmittal byte
    pub mod r8_uart2_thr {
        ///Register `R8_UART2_THR` writer
        pub struct W(crate::W<R8_UART2_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART2_THR` writer - WO, UART2 transmitter holding, transmittal byte
        pub type R8_UART2_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART2_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART2 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn r8_uart2_thr(&mut self) -> R8_UART2_THR_W<0> {
                R8_UART2_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART2 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_thr](index.html) module
        pub struct R8_UART2_THR_SPEC;
        impl crate::RegisterSpec for R8_UART2_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [r8_uart2_thr::W](W) writer structure
        impl crate::Writable for R8_UART2_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_THR to value 0
        impl crate::Resettable for R8_UART2_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_RFC (r) register accessor: an alias for `Reg<R8_UART2_RFC_SPEC>`
    pub type R8_UART2_RFC = crate::Reg<r8_uart2_rfc::R8_UART2_RFC_SPEC>;
    ///RO, UART2 receiver FIFO count
    pub mod r8_uart2_rfc {
        ///Register `R8_UART2_RFC` reader
        pub struct R(crate::R<R8_UART2_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART2_RFC` reader - RO, UART2 receiver FIFO count
        pub type R8_UART2_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver FIFO count
            #[inline(always)]
            pub fn r8_uart2_rfc(&self) -> R8_UART2_RFC_R {
                R8_UART2_RFC_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_rfc](index.html) module
        pub struct R8_UART2_RFC_SPEC;
        impl crate::RegisterSpec for R8_UART2_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_rfc::R](R) reader structure
        impl crate::Readable for R8_UART2_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART2_RFC to value 0
        impl crate::Resettable for R8_UART2_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_TFC (r) register accessor: an alias for `Reg<R8_UART2_TFC_SPEC>`
    pub type R8_UART2_TFC = crate::Reg<r8_uart2_tfc::R8_UART2_TFC_SPEC>;
    ///RO, UART2 transmitter FIFO count
    pub mod r8_uart2_tfc {
        ///Register `R8_UART2_TFC` reader
        pub struct R(crate::R<R8_UART2_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART2_TFC` reader - RO, UART2 transmitter FIFO count
        pub type R8_UART2_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 transmitter FIFO count
            #[inline(always)]
            pub fn r8_uart2_tfc(&self) -> R8_UART2_TFC_R {
                R8_UART2_TFC_R::new(self.bits)
            }
        }
        ///RO, UART2 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_tfc](index.html) module
        pub struct R8_UART2_TFC_SPEC;
        impl crate::RegisterSpec for R8_UART2_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_tfc::R](R) reader structure
        impl crate::Readable for R8_UART2_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART2_TFC to value 0
        impl crate::Resettable for R8_UART2_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UART2_DL (rw) register accessor: an alias for `Reg<R16_UART2_DL_SPEC>`
    pub type R16_UART2_DL = crate::Reg<r16_uart2_dl::R16_UART2_DL_SPEC>;
    ///RW, UART2 divisor latch
    pub mod r16_uart2_dl {
        ///Register `R16_UART2_DL` reader
        pub struct R(crate::R<R16_UART2_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UART2_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UART2_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UART2_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UART2_DL` writer
        pub struct W(crate::W<R16_UART2_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UART2_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UART2_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UART2_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UART2_DL` reader - RW, UART2 divisor latch
        pub type R16_UART2_DL_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UART2_DL` writer - RW, UART2 divisor latch
        pub type R16_UART2_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UART2_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            pub fn r16_uart2_dl(&self) -> R16_UART2_DL_R {
                R16_UART2_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn r16_uart2_dl(&mut self) -> R16_UART2_DL_W<0> {
                R16_UART2_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uart2_dl](index.html) module
        pub struct R16_UART2_DL_SPEC;
        impl crate::RegisterSpec for R16_UART2_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uart2_dl::R](R) reader structure
        impl crate::Readable for R16_UART2_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uart2_dl::W](W) writer structure
        impl crate::Writable for R16_UART2_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UART2_DL to value 0
        impl crate::Resettable for R16_UART2_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART2_DIV (rw) register accessor: an alias for `Reg<R8_UART2_DIV_SPEC>`
    pub type R8_UART2_DIV = crate::Reg<r8_uart2_div::R8_UART2_DIV_SPEC>;
    ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod r8_uart2_div {
        ///Register `R8_UART2_DIV` reader
        pub struct R(crate::R<R8_UART2_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART2_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART2_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART2_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART2_DIV` writer
        pub struct W(crate::W<R8_UART2_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART2_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART2_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART2_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART2_DIV` reader - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART2_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UART2_DIV` writer - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART2_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART2_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn r8_uart2_div(&self) -> R8_UART2_DIV_R {
                R8_UART2_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn r8_uart2_div(&mut self) -> R8_UART2_DIV_W<0> {
                R8_UART2_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart2_div](index.html) module
        pub struct R8_UART2_DIV_SPEC;
        impl crate::RegisterSpec for R8_UART2_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart2_div::R](R) reader structure
        impl crate::Readable for R8_UART2_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart2_div::W](W) writer structure
        impl crate::Writable for R8_UART2_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART2_DIV to value 0
        impl crate::Resettable for R8_UART2_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart3::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub mod uart3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART3 modem control
        pub r8_uart3_mcr: R8_UART3_MCR,
        ///0x01 - RW, UART3 interrupt enable
        pub r8_uart3_ier: R8_UART3_IER,
        ///0x02 - RW, UART3 FIFO control
        pub r8_uart3_fcr: R8_UART3_FCR,
        ///0x03 - RW, UART3 line control
        pub r8_uart3_lcr: R8_UART3_LCR,
        ///0x04 - RO, UART3 interrupt identification
        pub r8_uart3_iir: R8_UART3_IIR,
        ///0x05 - RO, UART3 line status
        pub r8_uart3_lsr: R8_UART3_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_r8_uart3: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART3 receiver FIFO count
        pub r8_uart3_rfc: R8_UART3_RFC,
        ///0x0b - RO, UART3 transmitter FIFO count
        pub r8_uart3_tfc: R8_UART3_TFC,
        ///0x0c - RW, UART3 divisor latch
        pub r16_uart3_dl: R16_UART3_DL,
        ///0x0e - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub r8_uart3_div: R8_UART3_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART3 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn r8_uart3_thr(&self) -> &R8_UART3_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART3 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn r8_uart3_rbr(&self) -> &R8_UART3_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///R8_UART3_MCR (rw) register accessor: an alias for `Reg<R8_UART3_MCR_SPEC>`
    pub type R8_UART3_MCR = crate::Reg<r8_uart3_mcr::R8_UART3_MCR_SPEC>;
    ///RW, UART3 modem control
    pub mod r8_uart3_mcr {
        ///Register `R8_UART3_MCR` reader
        pub struct R(crate::R<R8_UART3_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART3_MCR` writer
        pub struct W(crate::W<R8_UART3_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `RB_MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type RB_MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&self) -> RB_MCR_OUT2__RB_MCR_INT_OE_R {
                RB_MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_mcr_out2__rb_mcr_int_oe(&mut self) -> RB_MCR_OUT2__RB_MCR_INT_OE_W<3> {
                RB_MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_mcr](index.html) module
        pub struct R8_UART3_MCR_SPEC;
        impl crate::RegisterSpec for R8_UART3_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_mcr::R](R) reader structure
        impl crate::Readable for R8_UART3_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart3_mcr::W](W) writer structure
        impl crate::Writable for R8_UART3_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_MCR to value 0
        impl crate::Resettable for R8_UART3_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_IER (rw) register accessor: an alias for `Reg<R8_UART3_IER_SPEC>`
    pub type R8_UART3_IER = crate::Reg<r8_uart3_ier::R8_UART3_IER_SPEC>;
    ///RW, UART3 interrupt enable
    pub mod r8_uart3_ier {
        ///Register `R8_UART3_IER` reader
        pub struct R(crate::R<R8_UART3_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART3_IER` writer
        pub struct W(crate::W<R8_UART3_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `RB_IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RB_IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_IER_SPEC, bool, O>;
        ///Field `RB_IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `RB_IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type RB_IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_IER_SPEC, bool, O>;
        ///Field `RB_IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `RB_IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type RB_IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_IER_SPEC, bool, O>;
        ///Field `RB_IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `RB_IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type RB_IER_TXD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_IER_SPEC, bool, O>;
        ///Field `RB_IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_R = crate::BitReader<bool>;
        ///Field `RB_IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RB_IER_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn rb_ier_recv_rdy(&self) -> RB_IER_RECV_RDY_R {
                RB_IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn rb_ier_thr_empty(&self) -> RB_IER_THR_EMPTY_R {
                RB_IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn rb_ier_line_stat(&self) -> RB_IER_LINE_STAT_R {
                RB_IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn rb_ier_txd_en(&self) -> RB_IER_TXD_EN_R {
                RB_IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn rb_ier_reset(&self) -> RB_IER_RESET_R {
                RB_IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_recv_rdy(&mut self) -> RB_IER_RECV_RDY_W<0> {
                RB_IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_thr_empty(&mut self) -> RB_IER_THR_EMPTY_W<1> {
                RB_IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_line_stat(&mut self) -> RB_IER_LINE_STAT_W<2> {
                RB_IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_txd_en(&mut self) -> RB_IER_TXD_EN_W<6> {
                RB_IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_ier_reset(&mut self) -> RB_IER_RESET_W<7> {
                RB_IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_ier](index.html) module
        pub struct R8_UART3_IER_SPEC;
        impl crate::RegisterSpec for R8_UART3_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_ier::R](R) reader structure
        impl crate::Readable for R8_UART3_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart3_ier::W](W) writer structure
        impl crate::Writable for R8_UART3_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_IER to value 0
        impl crate::Resettable for R8_UART3_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_FCR (rw) register accessor: an alias for `Reg<R8_UART3_FCR_SPEC>`
    pub type R8_UART3_FCR = crate::Reg<r8_uart3_fcr::R8_UART3_FCR_SPEC>;
    ///RW, UART3 FIFO control
    pub mod r8_uart3_fcr {
        ///Register `R8_UART3_FCR` reader
        pub struct R(crate::R<R8_UART3_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART3_FCR` writer
        pub struct W(crate::W<R8_UART3_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `RB_FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type RB_FCR_FIFO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RB_FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `RB_FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type RB_FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_FCR_SPEC, bool, O>;
        ///Field `RB_FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `RB_FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type RB_FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART3_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn rb_fcr_fifo_en(&self) -> RB_FCR_FIFO_EN_R {
                RB_FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_rx_fifo_clr(&self) -> RB_FCR_RX_FIFO_CLR_R {
                RB_FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn rb_fcr_tx_fifo_clr(&self) -> RB_FCR_TX_FIFO_CLR_R {
                RB_FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn rb_fcr_fifo_trig(&self) -> RB_FCR_FIFO_TRIG_R {
                RB_FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_en(&mut self) -> RB_FCR_FIFO_EN_W<0> {
                RB_FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_rx_fifo_clr(&mut self) -> RB_FCR_RX_FIFO_CLR_W<1> {
                RB_FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_tx_fifo_clr(&mut self) -> RB_FCR_TX_FIFO_CLR_W<2> {
                RB_FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn rb_fcr_fifo_trig(&mut self) -> RB_FCR_FIFO_TRIG_W<6> {
                RB_FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_fcr](index.html) module
        pub struct R8_UART3_FCR_SPEC;
        impl crate::RegisterSpec for R8_UART3_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_fcr::R](R) reader structure
        impl crate::Readable for R8_UART3_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart3_fcr::W](W) writer structure
        impl crate::Writable for R8_UART3_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_FCR to value 0
        impl crate::Resettable for R8_UART3_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_LCR (rw) register accessor: an alias for `Reg<R8_UART3_LCR_SPEC>`
    pub type R8_UART3_LCR = crate::Reg<r8_uart3_lcr::R8_UART3_LCR_SPEC>;
    ///RW, UART3 line control
    pub mod r8_uart3_lcr {
        ///Register `R8_UART3_LCR` reader
        pub struct R(crate::R<R8_UART3_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART3_LCR` writer
        pub struct W(crate::W<R8_UART3_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type RB_LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART3_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type RB_LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_EN` reader - RW, UART parity enable
        pub type RB_LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_PAR_EN` writer - RW, UART parity enable
        pub type RB_LCR_PAR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type RB_LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART3_LCR_SPEC, u8, u8, 2, O>;
        ///Field `RB_LCR_BREAK_EN` reader - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `RB_LCR_BREAK_EN` writer - RW, UART break control enable
        pub type RB_LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_LCR_SPEC, bool, O>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `RB_LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type RB_LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UART3_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn rb_lcr_word_sz(&self) -> RB_LCR_WORD_SZ_R {
                RB_LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn rb_lcr_stop_bit(&self) -> RB_LCR_STOP_BIT_R {
                RB_LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn rb_lcr_par_en(&self) -> RB_LCR_PAR_EN_R {
                RB_LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn rb_lcr_par_mod(&self) -> RB_LCR_PAR_MOD_R {
                RB_LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn rb_lcr_break_en(&self) -> RB_LCR_BREAK_EN_R {
                RB_LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_R {
                RB_LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_word_sz(&mut self) -> RB_LCR_WORD_SZ_W<0> {
                RB_LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_stop_bit(&mut self) -> RB_LCR_STOP_BIT_W<2> {
                RB_LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_en(&mut self) -> RB_LCR_PAR_EN_W<3> {
                RB_LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_par_mod(&mut self) -> RB_LCR_PAR_MOD_W<4> {
                RB_LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_break_en(&mut self) -> RB_LCR_BREAK_EN_W<6> {
                RB_LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn rb_lcr_gp_bit__rb_lcr_dlab(&mut self) -> RB_LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                RB_LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_lcr](index.html) module
        pub struct R8_UART3_LCR_SPEC;
        impl crate::RegisterSpec for R8_UART3_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_lcr::R](R) reader structure
        impl crate::Readable for R8_UART3_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart3_lcr::W](W) writer structure
        impl crate::Writable for R8_UART3_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_LCR to value 0
        impl crate::Resettable for R8_UART3_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_IIR (r) register accessor: an alias for `Reg<R8_UART3_IIR_SPEC>`
    pub type R8_UART3_IIR = crate::Reg<r8_uart3_iir::R8_UART3_IIR_SPEC>;
    ///RO, UART3 interrupt identification
    pub mod r8_uart3_iir {
        ///Register `R8_UART3_IIR` reader
        pub struct R(crate::R<R8_UART3_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type RB_IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `RB_IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type RB_IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `RB_IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type RB_IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn rb_iir_no_int(&self) -> RB_IIR_NO_INT_R {
                RB_IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn rb_iir_int_mask(&self) -> RB_IIR_INT_MASK_R {
                RB_IIR_INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn rb_iir_fifo_id(&self) -> RB_IIR_FIFO_ID_R {
                RB_IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_iir](index.html) module
        pub struct R8_UART3_IIR_SPEC;
        impl crate::RegisterSpec for R8_UART3_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_iir::R](R) reader structure
        impl crate::Readable for R8_UART3_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART3_IIR to value 0x01
        impl crate::Resettable for R8_UART3_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///R8_UART3_LSR (r) register accessor: an alias for `Reg<R8_UART3_LSR_SPEC>`
    pub type R8_UART3_LSR = crate::Reg<r8_uart3_lsr::R8_UART3_LSR_SPEC>;
    ///RO, UART3 line status
    pub mod r8_uart3_lsr {
        ///Register `R8_UART3_LSR` reader
        pub struct R(crate::R<R8_UART3_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type RB_LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `RB_LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type RB_LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type RB_LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type RB_LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type RB_LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type RB_LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type RB_LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `RB_LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type RB_LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn rb_lsr_data_rdy(&self) -> RB_LSR_DATA_RDY_R {
                RB_LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn rb_lsr_over_err(&self) -> RB_LSR_OVER_ERR_R {
                RB_LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn rb_lsr_par_err(&self) -> RB_LSR_PAR_ERR_R {
                RB_LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn rb_lsr_frame_err(&self) -> RB_LSR_FRAME_ERR_R {
                RB_LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn rb_lsr_break_err(&self) -> RB_LSR_BREAK_ERR_R {
                RB_LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn rb_lsr_tx_fifo_emp(&self) -> RB_LSR_TX_FIFO_EMP_R {
                RB_LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn rb_lsr_tx_all_emp(&self) -> RB_LSR_TX_ALL_EMP_R {
                RB_LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn rb_lsr_err_rx_fifo(&self) -> RB_LSR_ERR_RX_FIFO_R {
                RB_LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_lsr](index.html) module
        pub struct R8_UART3_LSR_SPEC;
        impl crate::RegisterSpec for R8_UART3_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_lsr::R](R) reader structure
        impl crate::Readable for R8_UART3_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART3_LSR to value 0x60
        impl crate::Resettable for R8_UART3_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///R8_UART3_RBR (r) register accessor: an alias for `Reg<R8_UART3_RBR_SPEC>`
    pub type R8_UART3_RBR = crate::Reg<r8_uart3_rbr::R8_UART3_RBR_SPEC>;
    ///RO, UART3 receiver buffer, receiving byte
    pub mod r8_uart3_rbr {
        ///Register `R8_UART3_RBR` reader
        pub struct R(crate::R<R8_UART3_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART3_RBR` reader - RO, UART3 receiver buffer, receiving byte
        pub type R8_UART3_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver buffer, receiving byte
            #[inline(always)]
            pub fn r8_uart3_rbr(&self) -> R8_UART3_RBR_R {
                R8_UART3_RBR_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_rbr](index.html) module
        pub struct R8_UART3_RBR_SPEC;
        impl crate::RegisterSpec for R8_UART3_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_rbr::R](R) reader structure
        impl crate::Readable for R8_UART3_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART3_RBR to value 0
        impl crate::Resettable for R8_UART3_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_THR (w) register accessor: an alias for `Reg<R8_UART3_THR_SPEC>`
    pub type R8_UART3_THR = crate::Reg<r8_uart3_thr::R8_UART3_THR_SPEC>;
    ///WO, UART3 transmitter holding, transmittal byte
    pub mod r8_uart3_thr {
        ///Register `R8_UART3_THR` writer
        pub struct W(crate::W<R8_UART3_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART3_THR` writer - WO, UART3 transmitter holding, transmittal byte
        pub type R8_UART3_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART3_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART3 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn r8_uart3_thr(&mut self) -> R8_UART3_THR_W<0> {
                R8_UART3_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART3 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_thr](index.html) module
        pub struct R8_UART3_THR_SPEC;
        impl crate::RegisterSpec for R8_UART3_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [r8_uart3_thr::W](W) writer structure
        impl crate::Writable for R8_UART3_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_THR to value 0
        impl crate::Resettable for R8_UART3_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_RFC (r) register accessor: an alias for `Reg<R8_UART3_RFC_SPEC>`
    pub type R8_UART3_RFC = crate::Reg<r8_uart3_rfc::R8_UART3_RFC_SPEC>;
    ///RO, UART3 receiver FIFO count
    pub mod r8_uart3_rfc {
        ///Register `R8_UART3_RFC` reader
        pub struct R(crate::R<R8_UART3_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART3_RFC` reader - RO, UART3 receiver FIFO count
        pub type R8_UART3_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver FIFO count
            #[inline(always)]
            pub fn r8_uart3_rfc(&self) -> R8_UART3_RFC_R {
                R8_UART3_RFC_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_rfc](index.html) module
        pub struct R8_UART3_RFC_SPEC;
        impl crate::RegisterSpec for R8_UART3_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_rfc::R](R) reader structure
        impl crate::Readable for R8_UART3_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART3_RFC to value 0
        impl crate::Resettable for R8_UART3_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_TFC (r) register accessor: an alias for `Reg<R8_UART3_TFC_SPEC>`
    pub type R8_UART3_TFC = crate::Reg<r8_uart3_tfc::R8_UART3_TFC_SPEC>;
    ///RO, UART3 transmitter FIFO count
    pub mod r8_uart3_tfc {
        ///Register `R8_UART3_TFC` reader
        pub struct R(crate::R<R8_UART3_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_UART3_TFC` reader - RO, UART3 transmitter FIFO count
        pub type R8_UART3_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 transmitter FIFO count
            #[inline(always)]
            pub fn r8_uart3_tfc(&self) -> R8_UART3_TFC_R {
                R8_UART3_TFC_R::new(self.bits)
            }
        }
        ///RO, UART3 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_tfc](index.html) module
        pub struct R8_UART3_TFC_SPEC;
        impl crate::RegisterSpec for R8_UART3_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_tfc::R](R) reader structure
        impl crate::Readable for R8_UART3_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_UART3_TFC to value 0
        impl crate::Resettable for R8_UART3_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UART3_DL (rw) register accessor: an alias for `Reg<R16_UART3_DL_SPEC>`
    pub type R16_UART3_DL = crate::Reg<r16_uart3_dl::R16_UART3_DL_SPEC>;
    ///RW, UART3 divisor latch
    pub mod r16_uart3_dl {
        ///Register `R16_UART3_DL` reader
        pub struct R(crate::R<R16_UART3_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UART3_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UART3_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UART3_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UART3_DL` writer
        pub struct W(crate::W<R16_UART3_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UART3_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UART3_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UART3_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UART3_DL` reader - RW, UART3 divisor latch
        pub type R16_UART3_DL_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UART3_DL` writer - RW, UART3 divisor latch
        pub type R16_UART3_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UART3_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            pub fn r16_uart3_dl(&self) -> R16_UART3_DL_R {
                R16_UART3_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn r16_uart3_dl(&mut self) -> R16_UART3_DL_W<0> {
                R16_UART3_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uart3_dl](index.html) module
        pub struct R16_UART3_DL_SPEC;
        impl crate::RegisterSpec for R16_UART3_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uart3_dl::R](R) reader structure
        impl crate::Readable for R16_UART3_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uart3_dl::W](W) writer structure
        impl crate::Writable for R16_UART3_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UART3_DL to value 0
        impl crate::Resettable for R16_UART3_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UART3_DIV (rw) register accessor: an alias for `Reg<R8_UART3_DIV_SPEC>`
    pub type R8_UART3_DIV = crate::Reg<r8_uart3_div::R8_UART3_DIV_SPEC>;
    ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod r8_uart3_div {
        ///Register `R8_UART3_DIV` reader
        pub struct R(crate::R<R8_UART3_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UART3_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UART3_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UART3_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UART3_DIV` writer
        pub struct W(crate::W<R8_UART3_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UART3_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UART3_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UART3_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UART3_DIV` reader - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART3_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UART3_DIV` writer - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type R8_UART3_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UART3_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn r8_uart3_div(&self) -> R8_UART3_DIV_R {
                R8_UART3_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn r8_uart3_div(&mut self) -> R8_UART3_DIV_W<0> {
                R8_UART3_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uart3_div](index.html) module
        pub struct R8_UART3_DIV_SPEC;
        impl crate::RegisterSpec for R8_UART3_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uart3_div::R](R) reader structure
        impl crate::Readable for R8_UART3_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uart3_div::W](W) writer structure
        impl crate::Writable for R8_UART3_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UART3_DIV to value 0
        impl crate::Resettable for R8_UART3_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, SPI0 mode control
        pub r8_spi0_ctrl_mod: R8_SPI0_CTRL_MOD,
        ///0x01 - RW, SPI0 configuration control
        pub r8_spi0_ctrl_cfg: R8_SPI0_CTRL_CFG,
        ///0x02 - RW, SPI0 interrupt enable
        pub r8_spi0_inter_en: R8_SPI0_INTER_EN,
        ///0x03 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub r8_spi0_clock_div__r8_spi0_slave_pre: R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE,
        ///0x04 - RW, SPI0 data buffer
        pub r8_spi0_buffer: R8_SPI0_BUFFER,
        ///0x05 - RO, SPI0 work flag
        pub r8_spi0_run_flag: R8_SPI0_RUN_FLAG,
        ///0x06 - RW1, SPI0 interrupt flag
        pub r8_spi0_int_flag: R8_SPI0_INT_FLAG,
        ///0x07 - RO, SPI0 FIFO count status
        pub r8_spi0_fifo_count: R8_SPI0_FIFO_COUNT,
        _reserved8: [u8; 0x04],
        ///0x0c - RW, SPI0 total byte count, only low 12 bit
        pub r16_spi0_total_cnt: R16_SPI0_TOTAL_CNT,
        _reserved9: [u8; 0x02],
        ///0x10 - RO/WO, SPI0 FIFO register
        pub r8_spi0_fifo: R8_SPI0_FIFO,
        _reserved10: [u8; 0x02],
        ///0x13 - RO, SPI0 FIFO count status
        pub r8_spi0_fifo_count1: R8_SPI0_FIFO_COUNT1,
        ///0x14 - RW, SPI0 DMA current address
        pub r16_spi0_dma_now: R16_SPI0_DMA_NOW,
        _reserved12: [u8; 0x02],
        ///0x18 - RW, SPI0 DMA begin address
        pub r16_spi0_dma_beg: R16_SPI0_DMA_BEG,
        _reserved13: [u8; 0x02],
        ///0x1c - RW, SPI0 DMA end address
        pub r16_spi0_dma_end: R16_SPI0_DMA_END,
    }
    ///R8_SPI0_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_SPI0_CTRL_MOD_SPEC>`
    pub type R8_SPI0_CTRL_MOD = crate::Reg<r8_spi0_ctrl_mod::R8_SPI0_CTRL_MOD_SPEC>;
    ///RW, SPI0 mode control
    pub mod r8_spi0_ctrl_mod {
        ///Register `R8_SPI0_CTRL_MOD` reader
        pub struct R(crate::R<R8_SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_CTRL_MOD` writer
        pub struct W(crate::W<R8_SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type RB_SPI_MODE_SLAVE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type RB_SPI_MODE_SLAVE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type RB_SPI_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type RB_SPI_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type RB_SPI_2WIRE_MOD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type RB_SPI_2WIRE_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type RB_SPI_FIFO_DIR_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type RB_SPI_FIFO_DIR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type RB_SPI_SCK_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type RB_SPI_SCK_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type RB_SPI_MOSI_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type RB_SPI_MOSI_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type RB_SPI_MISO_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type RB_SPI_MISO_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn rb_spi_mode_slave(&self) -> RB_SPI_MODE_SLAVE_R {
                RB_SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn rb_spi_all_clear(&self) -> RB_SPI_ALL_CLEAR_R {
                RB_SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn rb_spi_2wire_mod(&self) -> RB_SPI_2WIRE_MOD_R {
                RB_SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn rb_spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &self,
            ) -> RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R {
                RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn rb_spi_fifo_dir(&self) -> RB_SPI_FIFO_DIR_R {
                RB_SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn rb_spi_sck_oe(&self) -> RB_SPI_SCK_OE_R {
                RB_SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn rb_spi_mosi_oe(&self) -> RB_SPI_MOSI_OE_R {
                RB_SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn rb_spi_miso_oe(&self) -> RB_SPI_MISO_OE_R {
                RB_SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mode_slave(&mut self) -> RB_SPI_MODE_SLAVE_W<0> {
                RB_SPI_MODE_SLAVE_W::new(self)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_all_clear(&mut self) -> RB_SPI_ALL_CLEAR_W<1> {
                RB_SPI_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_2wire_mod(&mut self) -> RB_SPI_2WIRE_MOD_W<2> {
                RB_SPI_2WIRE_MOD_W::new(self)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &mut self,
            ) -> RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<3> {
                RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W::new(self)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_fifo_dir(&mut self) -> RB_SPI_FIFO_DIR_W<4> {
                RB_SPI_FIFO_DIR_W::new(self)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_sck_oe(&mut self) -> RB_SPI_SCK_OE_W<5> {
                RB_SPI_SCK_OE_W::new(self)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mosi_oe(&mut self) -> RB_SPI_MOSI_OE_W<6> {
                RB_SPI_MOSI_OE_W::new(self)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_miso_oe(&mut self) -> RB_SPI_MISO_OE_W<7> {
                RB_SPI_MISO_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_ctrl_mod](index.html) module
        pub struct R8_SPI0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_SPI0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_SPI0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_SPI0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_SPI0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_SPI0_CTRL_CFG (rw) register accessor: an alias for `Reg<R8_SPI0_CTRL_CFG_SPEC>`
    pub type R8_SPI0_CTRL_CFG = crate::Reg<r8_spi0_ctrl_cfg::R8_SPI0_CTRL_CFG_SPEC>;
    ///RW, SPI0 configuration control
    pub mod r8_spi0_ctrl_cfg {
        ///Register `R8_SPI0_CTRL_CFG` reader
        pub struct R(crate::R<R8_SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_CTRL_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_CTRL_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_CTRL_CFG` writer
        pub struct W(crate::W<R8_SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_CTRL_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_CTRL_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type RB_SPI_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type RB_SPI_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type RB_SPI_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type RB_SPI_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type RB_SPI_AUTO_IF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type RB_SPI_AUTO_IF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type RB_SPI_BIT_ORDER_R = crate::BitReader<bool>;
        ///Field `RB_SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type RB_SPI_BIT_ORDER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type RB_SPI_MST_DLY_EN_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type RB_SPI_MST_DLY_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_CTRL_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn rb_spi_dma_enable(&self) -> RB_SPI_DMA_ENABLE_R {
                RB_SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn rb_spi_dma_loop(&self) -> RB_SPI_DMA_LOOP_R {
                RB_SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn rb_spi_auto_if(&self) -> RB_SPI_AUTO_IF_R {
                RB_SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn rb_spi_bit_order(&self) -> RB_SPI_BIT_ORDER_R {
                RB_SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn rb_spi_mst_dly_en(&self) -> RB_SPI_MST_DLY_EN_R {
                RB_SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_dma_enable(&mut self) -> RB_SPI_DMA_ENABLE_W<0> {
                RB_SPI_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_dma_loop(&mut self) -> RB_SPI_DMA_LOOP_W<2> {
                RB_SPI_DMA_LOOP_W::new(self)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_auto_if(&mut self) -> RB_SPI_AUTO_IF_W<4> {
                RB_SPI_AUTO_IF_W::new(self)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_bit_order(&mut self) -> RB_SPI_BIT_ORDER_W<5> {
                RB_SPI_BIT_ORDER_W::new(self)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mst_dly_en(&mut self) -> RB_SPI_MST_DLY_EN_W<6> {
                RB_SPI_MST_DLY_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 configuration control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_ctrl_cfg](index.html) module
        pub struct R8_SPI0_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for R8_SPI0_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_ctrl_cfg::R](R) reader structure
        impl crate::Readable for R8_SPI0_CTRL_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_ctrl_cfg::W](W) writer structure
        impl crate::Writable for R8_SPI0_CTRL_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_CTRL_CFG to value 0
        impl crate::Resettable for R8_SPI0_CTRL_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_INTER_EN (rw) register accessor: an alias for `Reg<R8_SPI0_INTER_EN_SPEC>`
    pub type R8_SPI0_INTER_EN = crate::Reg<r8_spi0_inter_en::R8_SPI0_INTER_EN_SPEC>;
    ///RW, SPI0 interrupt enable
    pub mod r8_spi0_inter_en {
        ///Register `R8_SPI0_INTER_EN` reader
        pub struct R(crate::R<R8_SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_INTER_EN` writer
        pub struct W(crate::W<R8_SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type RB_SPI_IE_CNT_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type RB_SPI_IE_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type RB_SPI_IE_BYTE_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type RB_SPI_IE_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type RB_SPI_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type RB_SPI_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type RB_SPI_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type RB_SPI_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type RB_SPI_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type RB_SPI_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type RB_SPI_IE_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type RB_SPI_IE_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn rb_spi_ie_cnt_end(&self) -> RB_SPI_IE_CNT_END_R {
                RB_SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn rb_spi_ie_byte_end(&self) -> RB_SPI_IE_BYTE_END_R {
                RB_SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn rb_spi_ie_fifo_hf(&self) -> RB_SPI_IE_FIFO_HF_R {
                RB_SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn rb_spi_ie_dma_end(&self) -> RB_SPI_IE_DMA_END_R {
                RB_SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn rb_spi_ie_fifo_ov(&self) -> RB_SPI_IE_FIFO_OV_R {
                RB_SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn rb_spi_ie_fst_byte(&self) -> RB_SPI_IE_FST_BYTE_R {
                RB_SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_cnt_end(&mut self) -> RB_SPI_IE_CNT_END_W<0> {
                RB_SPI_IE_CNT_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_byte_end(&mut self) -> RB_SPI_IE_BYTE_END_W<1> {
                RB_SPI_IE_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fifo_hf(&mut self) -> RB_SPI_IE_FIFO_HF_W<2> {
                RB_SPI_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_dma_end(&mut self) -> RB_SPI_IE_DMA_END_W<3> {
                RB_SPI_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fifo_ov(&mut self) -> RB_SPI_IE_FIFO_OV_W<4> {
                RB_SPI_IE_FIFO_OV_W::new(self)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fst_byte(&mut self) -> RB_SPI_IE_FST_BYTE_W<7> {
                RB_SPI_IE_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_inter_en](index.html) module
        pub struct R8_SPI0_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_SPI0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_inter_en::R](R) reader structure
        impl crate::Readable for R8_SPI0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_inter_en::W](W) writer structure
        impl crate::Writable for R8_SPI0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_INTER_EN to value 0
        impl crate::Resettable for R8_SPI0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE (rw) register accessor: an alias for `Reg<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>`
    pub type R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE =
        crate::Reg<r8_spi0_clock_div__r8_spi0_slave_pre::R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
    ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
    pub mod r8_spi0_clock_div__r8_spi0_slave_pre {
        ///Register `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader
        pub struct R(crate::R<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer
        pub struct W(crate::W<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn r8_spi0_clock_div__r8_spi0_slave_pre(
                &self,
            ) -> R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn r8_spi0_clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<0> {
                R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_clock_div__r8_spi0_slave_pre](index.html) module
        pub struct R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_clock_div__r8_spi0_slave_pre::R](R) reader structure
        impl crate::Readable for R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_clock_div__r8_spi0_slave_pre::W](W) writer structure
        impl crate::Writable for R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE to value 0x10
        impl crate::Resettable for R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    ///R8_SPI0_BUFFER (rw) register accessor: an alias for `Reg<R8_SPI0_BUFFER_SPEC>`
    pub type R8_SPI0_BUFFER = crate::Reg<r8_spi0_buffer::R8_SPI0_BUFFER_SPEC>;
    ///RW, SPI0 data buffer
    pub mod r8_spi0_buffer {
        ///Register `R8_SPI0_BUFFER` reader
        pub struct R(crate::R<R8_SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_BUFFER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_BUFFER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_BUFFER` writer
        pub struct W(crate::W<R8_SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_BUFFER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_BUFFER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI0_BUFFER` reader - RW, SPI0 data buffer
        pub type R8_SPI0_BUFFER_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI0_BUFFER` writer - RW, SPI0 data buffer
        pub type R8_SPI0_BUFFER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI0_BUFFER_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            pub fn r8_spi0_buffer(&self) -> R8_SPI0_BUFFER_R {
                R8_SPI0_BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            #[must_use]
            pub fn r8_spi0_buffer(&mut self) -> R8_SPI0_BUFFER_W<0> {
                R8_SPI0_BUFFER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 data buffer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_buffer](index.html) module
        pub struct R8_SPI0_BUFFER_SPEC;
        impl crate::RegisterSpec for R8_SPI0_BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_buffer::R](R) reader structure
        impl crate::Readable for R8_SPI0_BUFFER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_buffer::W](W) writer structure
        impl crate::Writable for R8_SPI0_BUFFER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_BUFFER to value 0
        impl crate::Resettable for R8_SPI0_BUFFER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_RUN_FLAG (r) register accessor: an alias for `Reg<R8_SPI0_RUN_FLAG_SPEC>`
    pub type R8_SPI0_RUN_FLAG = crate::Reg<r8_spi0_run_flag::R8_SPI0_RUN_FLAG_SPEC>;
    ///RO, SPI0 work flag
    pub mod r8_spi0_run_flag {
        ///Register `R8_SPI0_RUN_FLAG` reader
        pub struct R(crate::R<R8_SPI0_RUN_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_RUN_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_RUN_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_RUN_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type RB_SPI_SLV_CMD_ACT_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type RB_SPI_FIFO_READY_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type RB_SPI_SLV_CS_LOAD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type RB_SPI_SLV_SELECT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn rb_spi_slv_cmd_act(&self) -> RB_SPI_SLV_CMD_ACT_R {
                RB_SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn rb_spi_fifo_ready(&self) -> RB_SPI_FIFO_READY_R {
                RB_SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn rb_spi_slv_cs_load(&self) -> RB_SPI_SLV_CS_LOAD_R {
                RB_SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn rb_spi_slv_select(&self) -> RB_SPI_SLV_SELECT_R {
                RB_SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI0 work flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_run_flag](index.html) module
        pub struct R8_SPI0_RUN_FLAG_SPEC;
        impl crate::RegisterSpec for R8_SPI0_RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_run_flag::R](R) reader structure
        impl crate::Readable for R8_SPI0_RUN_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI0_RUN_FLAG to value 0
        impl crate::Resettable for R8_SPI0_RUN_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_INT_FLAG (rw) register accessor: an alias for `Reg<R8_SPI0_INT_FLAG_SPEC>`
    pub type R8_SPI0_INT_FLAG = crate::Reg<r8_spi0_int_flag::R8_SPI0_INT_FLAG_SPEC>;
    ///RW1, SPI0 interrupt flag
    pub mod r8_spi0_int_flag {
        ///Register `R8_SPI0_INT_FLAG` reader
        pub struct R(crate::R<R8_SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_INT_FLAG` writer
        pub struct W(crate::W<R8_SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type RB_SPI_IF_CNT_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type RB_SPI_IF_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type RB_SPI_IF_BYTE_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type RB_SPI_IF_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type RB_SPI_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type RB_SPI_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type RB_SPI_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type RB_SPI_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type RB_SPI_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type RB_SPI_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_FREE` reader - RO, current SPI free status
        pub type RB_SPI_FREE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FREE` writer - RO, current SPI free status
        pub type RB_SPI_FREE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type RB_SPI_IF_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type RB_SPI_IF_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI0_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn rb_spi_if_cnt_end(&self) -> RB_SPI_IF_CNT_END_R {
                RB_SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn rb_spi_if_byte_end(&self) -> RB_SPI_IF_BYTE_END_R {
                RB_SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn rb_spi_if_fifo_hf(&self) -> RB_SPI_IF_FIFO_HF_R {
                RB_SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn rb_spi_if_dma_end(&self) -> RB_SPI_IF_DMA_END_R {
                RB_SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn rb_spi_if_fifo_ov(&self) -> RB_SPI_IF_FIFO_OV_R {
                RB_SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn rb_spi_free(&self) -> RB_SPI_FREE_R {
                RB_SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn rb_spi_if_fst_byte(&self) -> RB_SPI_IF_FST_BYTE_R {
                RB_SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_cnt_end(&mut self) -> RB_SPI_IF_CNT_END_W<0> {
                RB_SPI_IF_CNT_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_byte_end(&mut self) -> RB_SPI_IF_BYTE_END_W<1> {
                RB_SPI_IF_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fifo_hf(&mut self) -> RB_SPI_IF_FIFO_HF_W<2> {
                RB_SPI_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_dma_end(&mut self) -> RB_SPI_IF_DMA_END_W<3> {
                RB_SPI_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fifo_ov(&mut self) -> RB_SPI_IF_FIFO_OV_W<4> {
                RB_SPI_IF_FIFO_OV_W::new(self)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_free(&mut self) -> RB_SPI_FREE_W<6> {
                RB_SPI_FREE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fst_byte(&mut self) -> RB_SPI_IF_FST_BYTE_W<7> {
                RB_SPI_IF_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, SPI0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_int_flag](index.html) module
        pub struct R8_SPI0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_SPI0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_int_flag::R](R) reader structure
        impl crate::Readable for R8_SPI0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_int_flag::W](W) writer structure
        impl crate::Writable for R8_SPI0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_INT_FLAG to value 0x40
        impl crate::Resettable for R8_SPI0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///R8_SPI0_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_SPI0_FIFO_COUNT_SPEC>`
    pub type R8_SPI0_FIFO_COUNT = crate::Reg<r8_spi0_fifo_count::R8_SPI0_FIFO_COUNT_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod r8_spi0_fifo_count {
        ///Register `R8_SPI0_FIFO_COUNT` reader
        pub struct R(crate::R<R8_SPI0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type R8_SPI0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn r8_spi0_fifo_count(&self) -> R8_SPI0_FIFO_COUNT_R {
                R8_SPI0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_fifo_count](index.html) module
        pub struct R8_SPI0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_SPI0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_fifo_count::R](R) reader structure
        impl crate::Readable for R8_SPI0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI0_FIFO_COUNT to value 0
        impl crate::Resettable for R8_SPI0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_SPI0_TOTAL_CNT (rw) register accessor: an alias for `Reg<R16_SPI0_TOTAL_CNT_SPEC>`
    pub type R16_SPI0_TOTAL_CNT = crate::Reg<r16_spi0_total_cnt::R16_SPI0_TOTAL_CNT_SPEC>;
    ///RW, SPI0 total byte count, only low 12 bit
    pub mod r16_spi0_total_cnt {
        ///Register `R16_SPI0_TOTAL_CNT` reader
        pub struct R(crate::R<R16_SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_SPI0_TOTAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_SPI0_TOTAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_SPI0_TOTAL_CNT` writer
        pub struct W(crate::W<R16_SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_SPI0_TOTAL_CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_SPI0_TOTAL_CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_SPI0_TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit
        pub type R16_SPI0_TOTAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `R16_SPI0_TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit
        pub type R16_SPI0_TOTAL_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_SPI0_TOTAL_CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            pub fn r16_spi0_total_cnt(&self) -> R16_SPI0_TOTAL_CNT_R {
                R16_SPI0_TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn r16_spi0_total_cnt(&mut self) -> R16_SPI0_TOTAL_CNT_W<0> {
                R16_SPI0_TOTAL_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 total byte count, only low 12 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_spi0_total_cnt](index.html) module
        pub struct R16_SPI0_TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for R16_SPI0_TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_spi0_total_cnt::R](R) reader structure
        impl crate::Readable for R16_SPI0_TOTAL_CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_spi0_total_cnt::W](W) writer structure
        impl crate::Writable for R16_SPI0_TOTAL_CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_SPI0_TOTAL_CNT to value 0
        impl crate::Resettable for R16_SPI0_TOTAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_FIFO (rw) register accessor: an alias for `Reg<R8_SPI0_FIFO_SPEC>`
    pub type R8_SPI0_FIFO = crate::Reg<r8_spi0_fifo::R8_SPI0_FIFO_SPEC>;
    ///RO/WO, SPI0 FIFO register
    pub mod r8_spi0_fifo {
        ///Register `R8_SPI0_FIFO` reader
        pub struct R(crate::R<R8_SPI0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI0_FIFO` writer
        pub struct W(crate::W<R8_SPI0_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI0_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI0_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI0_FIFO` reader - RO/WO, SPI0 FIFO register
        pub type R8_SPI0_FIFO_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI0_FIFO` writer - RO/WO, SPI0 FIFO register
        pub type R8_SPI0_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI0_FIFO_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            pub fn r8_spi0_fifo(&self) -> R8_SPI0_FIFO_R {
                R8_SPI0_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn r8_spi0_fifo(&mut self) -> R8_SPI0_FIFO_W<0> {
                R8_SPI0_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, SPI0 FIFO register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_fifo](index.html) module
        pub struct R8_SPI0_FIFO_SPEC;
        impl crate::RegisterSpec for R8_SPI0_FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_fifo::R](R) reader structure
        impl crate::Readable for R8_SPI0_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi0_fifo::W](W) writer structure
        impl crate::Writable for R8_SPI0_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI0_FIFO to value 0
        impl crate::Resettable for R8_SPI0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI0_FIFO_COUNT1 (r) register accessor: an alias for `Reg<R8_SPI0_FIFO_COUNT1_SPEC>`
    pub type R8_SPI0_FIFO_COUNT1 = crate::Reg<r8_spi0_fifo_count1::R8_SPI0_FIFO_COUNT1_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod r8_spi0_fifo_count1 {
        ///Register `R8_SPI0_FIFO_COUNT1` reader
        pub struct R(crate::R<R8_SPI0_FIFO_COUNT1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI0_FIFO_COUNT1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI0_FIFO_COUNT1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI0_FIFO_COUNT1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SPI0_FIFO_COUNT1` reader - RO, SPI0 FIFO count status
        pub type R8_SPI0_FIFO_COUNT1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn r8_spi0_fifo_count1(&self) -> R8_SPI0_FIFO_COUNT1_R {
                R8_SPI0_FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi0_fifo_count1](index.html) module
        pub struct R8_SPI0_FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for R8_SPI0_FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi0_fifo_count1::R](R) reader structure
        impl crate::Readable for R8_SPI0_FIFO_COUNT1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI0_FIFO_COUNT1 to value 0
        impl crate::Resettable for R8_SPI0_FIFO_COUNT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_SPI0_DMA_NOW (rw) register accessor: an alias for `Reg<R16_SPI0_DMA_NOW_SPEC>`
    pub type R16_SPI0_DMA_NOW = crate::Reg<r16_spi0_dma_now::R16_SPI0_DMA_NOW_SPEC>;
    ///RW, SPI0 DMA current address
    pub mod r16_spi0_dma_now {
        ///Register `R16_SPI0_DMA_NOW` reader
        pub struct R(crate::R<R16_SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_SPI0_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_SPI0_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_SPI0_DMA_NOW` writer
        pub struct W(crate::W<R16_SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_SPI0_DMA_NOW_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_SPI0_DMA_NOW_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_SPI0_DMA_NOW` reader - RW, SPI0 DMA current address
        pub type R16_SPI0_DMA_NOW_R = crate::FieldReader<u16, u16>;
        ///Field `R16_SPI0_DMA_NOW` writer - RW, SPI0 DMA current address
        pub type R16_SPI0_DMA_NOW_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_SPI0_DMA_NOW_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            pub fn r16_spi0_dma_now(&self) -> R16_SPI0_DMA_NOW_R {
                R16_SPI0_DMA_NOW_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            #[must_use]
            pub fn r16_spi0_dma_now(&mut self) -> R16_SPI0_DMA_NOW_W<0> {
                R16_SPI0_DMA_NOW_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_spi0_dma_now](index.html) module
        pub struct R16_SPI0_DMA_NOW_SPEC;
        impl crate::RegisterSpec for R16_SPI0_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_spi0_dma_now::R](R) reader structure
        impl crate::Readable for R16_SPI0_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_spi0_dma_now::W](W) writer structure
        impl crate::Writable for R16_SPI0_DMA_NOW_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_SPI0_DMA_NOW to value 0
        impl crate::Resettable for R16_SPI0_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_SPI0_DMA_BEG (rw) register accessor: an alias for `Reg<R16_SPI0_DMA_BEG_SPEC>`
    pub type R16_SPI0_DMA_BEG = crate::Reg<r16_spi0_dma_beg::R16_SPI0_DMA_BEG_SPEC>;
    ///RW, SPI0 DMA begin address
    pub mod r16_spi0_dma_beg {
        ///Register `R16_SPI0_DMA_BEG` reader
        pub struct R(crate::R<R16_SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_SPI0_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_SPI0_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_SPI0_DMA_BEG` writer
        pub struct W(crate::W<R16_SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_SPI0_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_SPI0_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_SPI0_DMA_BEG` reader - RW, SPI0 DMA begin address
        pub type R16_SPI0_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `R16_SPI0_DMA_BEG` writer - RW, SPI0 DMA begin address
        pub type R16_SPI0_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_SPI0_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            pub fn r16_spi0_dma_beg(&self) -> R16_SPI0_DMA_BEG_R {
                R16_SPI0_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn r16_spi0_dma_beg(&mut self) -> R16_SPI0_DMA_BEG_W<0> {
                R16_SPI0_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_spi0_dma_beg](index.html) module
        pub struct R16_SPI0_DMA_BEG_SPEC;
        impl crate::RegisterSpec for R16_SPI0_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_spi0_dma_beg::R](R) reader structure
        impl crate::Readable for R16_SPI0_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_spi0_dma_beg::W](W) writer structure
        impl crate::Writable for R16_SPI0_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_SPI0_DMA_BEG to value 0
        impl crate::Resettable for R16_SPI0_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_SPI0_DMA_END (rw) register accessor: an alias for `Reg<R16_SPI0_DMA_END_SPEC>`
    pub type R16_SPI0_DMA_END = crate::Reg<r16_spi0_dma_end::R16_SPI0_DMA_END_SPEC>;
    ///RW, SPI0 DMA end address
    pub mod r16_spi0_dma_end {
        ///Register `R16_SPI0_DMA_END` reader
        pub struct R(crate::R<R16_SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_SPI0_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_SPI0_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_SPI0_DMA_END` writer
        pub struct W(crate::W<R16_SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_SPI0_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_SPI0_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_SPI0_DMA_END` reader - RW, SPI0 DMA end address
        pub type R16_SPI0_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `R16_SPI0_DMA_END` writer - RW, SPI0 DMA end address
        pub type R16_SPI0_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_SPI0_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            pub fn r16_spi0_dma_end(&self) -> R16_SPI0_DMA_END_R {
                R16_SPI0_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn r16_spi0_dma_end(&mut self) -> R16_SPI0_DMA_END_W<0> {
                R16_SPI0_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_spi0_dma_end](index.html) module
        pub struct R16_SPI0_DMA_END_SPEC;
        impl crate::RegisterSpec for R16_SPI0_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_spi0_dma_end::R](R) reader structure
        impl crate::Readable for R16_SPI0_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_spi0_dma_end::W](W) writer structure
        impl crate::Writable for R16_SPI0_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_SPI0_DMA_END to value 0
        impl crate::Resettable for R16_SPI0_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///SPI1 register
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///SPI1 register
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, SPI1 mode control
        pub r8_spi1_ctrl_mod: R8_SPI1_CTRL_MOD,
        ///0x01 - RW, SPI1 configuration control
        pub r8_spi1_ctrl_cfg: R8_SPI1_CTRL_CFG,
        ///0x02 - RW, SPI1 interrupt enable
        pub r8_spi1_inter_en: R8_SPI1_INTER_EN,
        ///0x03 - RW, SPI1 master clock divisor;
        pub r8_spi1_clock_div: R8_SPI1_CLOCK_DIV,
        ///0x04 - RW, SPI1 data buffer
        pub r8_spi1_buffer: R8_SPI1_BUFFER,
        ///0x05 - RO, SPI1 work flag
        pub r8_spi1_run_flag: R8_SPI1_RUN_FLAG,
        ///0x06 - RW1, SPI1 interrupt flag
        pub r8_spi1_int_flag: R8_SPI1_INT_FLAG,
        ///0x07 - RO, SPI1 FIFO count status
        pub r8_spi1_fifo_count: R8_SPI1_FIFO_COUNT,
        _reserved8: [u8; 0x04],
        ///0x0c - RW, SPI1 total byte count, only low 12 bit
        pub r16_spi1_total_cnt: R16_SPI1_TOTAL_CNT,
        _reserved9: [u8; 0x02],
        ///0x10 - RO/WO, SPI1 FIFO register
        pub r8_spi1_fifo: R8_SPI1_FIFO,
        _reserved10: [u8; 0x02],
        ///0x13 - RO, SPI1 FIFO count status
        pub r8_spi1_fifo_count1: R8_SPI1_FIFO_COUNT1,
    }
    ///R8_SPI1_CTRL_MOD (rw) register accessor: an alias for `Reg<R8_SPI1_CTRL_MOD_SPEC>`
    pub type R8_SPI1_CTRL_MOD = crate::Reg<r8_spi1_ctrl_mod::R8_SPI1_CTRL_MOD_SPEC>;
    ///RW, SPI1 mode control
    pub mod r8_spi1_ctrl_mod {
        ///Register `R8_SPI1_CTRL_MOD` reader
        pub struct R(crate::R<R8_SPI1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_CTRL_MOD` writer
        pub struct W(crate::W<R8_SPI1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type RB_SPI_MODE_SLAVE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type RB_SPI_MODE_SLAVE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type RB_SPI_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `RB_SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type RB_SPI_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type RB_SPI_2WIRE_MOD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type RB_SPI_2WIRE_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type RB_SPI_FIFO_DIR_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type RB_SPI_FIFO_DIR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type RB_SPI_SCK_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type RB_SPI_SCK_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type RB_SPI_MOSI_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type RB_SPI_MOSI_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `RB_SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type RB_SPI_MISO_OE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type RB_SPI_MISO_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn rb_spi_mode_slave(&self) -> RB_SPI_MODE_SLAVE_R {
                RB_SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn rb_spi_all_clear(&self) -> RB_SPI_ALL_CLEAR_R {
                RB_SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn rb_spi_2wire_mod(&self) -> RB_SPI_2WIRE_MOD_R {
                RB_SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn rb_spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &self,
            ) -> RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R {
                RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn rb_spi_fifo_dir(&self) -> RB_SPI_FIFO_DIR_R {
                RB_SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn rb_spi_sck_oe(&self) -> RB_SPI_SCK_OE_R {
                RB_SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn rb_spi_mosi_oe(&self) -> RB_SPI_MOSI_OE_R {
                RB_SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn rb_spi_miso_oe(&self) -> RB_SPI_MISO_OE_R {
                RB_SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mode_slave(&mut self) -> RB_SPI_MODE_SLAVE_W<0> {
                RB_SPI_MODE_SLAVE_W::new(self)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_all_clear(&mut self) -> RB_SPI_ALL_CLEAR_W<1> {
                RB_SPI_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_2wire_mod(&mut self) -> RB_SPI_2WIRE_MOD_W<2> {
                RB_SPI_2WIRE_MOD_W::new(self)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &mut self,
            ) -> RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<3> {
                RB_SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W::new(self)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_fifo_dir(&mut self) -> RB_SPI_FIFO_DIR_W<4> {
                RB_SPI_FIFO_DIR_W::new(self)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_sck_oe(&mut self) -> RB_SPI_SCK_OE_W<5> {
                RB_SPI_SCK_OE_W::new(self)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mosi_oe(&mut self) -> RB_SPI_MOSI_OE_W<6> {
                RB_SPI_MOSI_OE_W::new(self)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_miso_oe(&mut self) -> RB_SPI_MISO_OE_W<7> {
                RB_SPI_MISO_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_ctrl_mod](index.html) module
        pub struct R8_SPI1_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for R8_SPI1_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_ctrl_mod::R](R) reader structure
        impl crate::Readable for R8_SPI1_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_ctrl_mod::W](W) writer structure
        impl crate::Writable for R8_SPI1_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_CTRL_MOD to value 0x02
        impl crate::Resettable for R8_SPI1_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///R8_SPI1_CTRL_CFG (rw) register accessor: an alias for `Reg<R8_SPI1_CTRL_CFG_SPEC>`
    pub type R8_SPI1_CTRL_CFG = crate::Reg<r8_spi1_ctrl_cfg::R8_SPI1_CTRL_CFG_SPEC>;
    ///RW, SPI1 configuration control
    pub mod r8_spi1_ctrl_cfg {
        ///Register `R8_SPI1_CTRL_CFG` reader
        pub struct R(crate::R<R8_SPI1_CTRL_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_CTRL_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_CTRL_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_CTRL_CFG` writer
        pub struct W(crate::W<R8_SPI1_CTRL_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_CTRL_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_CTRL_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type RB_SPI_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type RB_SPI_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type RB_SPI_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `RB_SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type RB_SPI_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type RB_SPI_AUTO_IF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type RB_SPI_AUTO_IF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type RB_SPI_BIT_ORDER_R = crate::BitReader<bool>;
        ///Field `RB_SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type RB_SPI_BIT_ORDER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `RB_SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type RB_SPI_MST_DLY_EN_R = crate::BitReader<bool>;
        ///Field `RB_SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type RB_SPI_MST_DLY_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_CTRL_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn rb_spi_dma_enable(&self) -> RB_SPI_DMA_ENABLE_R {
                RB_SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn rb_spi_dma_loop(&self) -> RB_SPI_DMA_LOOP_R {
                RB_SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn rb_spi_auto_if(&self) -> RB_SPI_AUTO_IF_R {
                RB_SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn rb_spi_bit_order(&self) -> RB_SPI_BIT_ORDER_R {
                RB_SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn rb_spi_mst_dly_en(&self) -> RB_SPI_MST_DLY_EN_R {
                RB_SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_dma_enable(&mut self) -> RB_SPI_DMA_ENABLE_W<0> {
                RB_SPI_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_dma_loop(&mut self) -> RB_SPI_DMA_LOOP_W<2> {
                RB_SPI_DMA_LOOP_W::new(self)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_auto_if(&mut self) -> RB_SPI_AUTO_IF_W<4> {
                RB_SPI_AUTO_IF_W::new(self)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_bit_order(&mut self) -> RB_SPI_BIT_ORDER_W<5> {
                RB_SPI_BIT_ORDER_W::new(self)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_mst_dly_en(&mut self) -> RB_SPI_MST_DLY_EN_W<6> {
                RB_SPI_MST_DLY_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 configuration control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_ctrl_cfg](index.html) module
        pub struct R8_SPI1_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for R8_SPI1_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_ctrl_cfg::R](R) reader structure
        impl crate::Readable for R8_SPI1_CTRL_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_ctrl_cfg::W](W) writer structure
        impl crate::Writable for R8_SPI1_CTRL_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_CTRL_CFG to value 0
        impl crate::Resettable for R8_SPI1_CTRL_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_INTER_EN (rw) register accessor: an alias for `Reg<R8_SPI1_INTER_EN_SPEC>`
    pub type R8_SPI1_INTER_EN = crate::Reg<r8_spi1_inter_en::R8_SPI1_INTER_EN_SPEC>;
    ///RW, SPI1 interrupt enable
    pub mod r8_spi1_inter_en {
        ///Register `R8_SPI1_INTER_EN` reader
        pub struct R(crate::R<R8_SPI1_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_INTER_EN` writer
        pub struct W(crate::W<R8_SPI1_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type RB_SPI_IE_CNT_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type RB_SPI_IE_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type RB_SPI_IE_BYTE_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type RB_SPI_IE_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type RB_SPI_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type RB_SPI_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type RB_SPI_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type RB_SPI_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type RB_SPI_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type RB_SPI_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `RB_SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type RB_SPI_IE_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type RB_SPI_IE_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn rb_spi_ie_cnt_end(&self) -> RB_SPI_IE_CNT_END_R {
                RB_SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn rb_spi_ie_byte_end(&self) -> RB_SPI_IE_BYTE_END_R {
                RB_SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn rb_spi_ie_fifo_hf(&self) -> RB_SPI_IE_FIFO_HF_R {
                RB_SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn rb_spi_ie_dma_end(&self) -> RB_SPI_IE_DMA_END_R {
                RB_SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn rb_spi_ie_fifo_ov(&self) -> RB_SPI_IE_FIFO_OV_R {
                RB_SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn rb_spi_ie_fst_byte(&self) -> RB_SPI_IE_FST_BYTE_R {
                RB_SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_cnt_end(&mut self) -> RB_SPI_IE_CNT_END_W<0> {
                RB_SPI_IE_CNT_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_byte_end(&mut self) -> RB_SPI_IE_BYTE_END_W<1> {
                RB_SPI_IE_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fifo_hf(&mut self) -> RB_SPI_IE_FIFO_HF_W<2> {
                RB_SPI_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_dma_end(&mut self) -> RB_SPI_IE_DMA_END_W<3> {
                RB_SPI_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fifo_ov(&mut self) -> RB_SPI_IE_FIFO_OV_W<4> {
                RB_SPI_IE_FIFO_OV_W::new(self)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_ie_fst_byte(&mut self) -> RB_SPI_IE_FST_BYTE_W<7> {
                RB_SPI_IE_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_inter_en](index.html) module
        pub struct R8_SPI1_INTER_EN_SPEC;
        impl crate::RegisterSpec for R8_SPI1_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_inter_en::R](R) reader structure
        impl crate::Readable for R8_SPI1_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_inter_en::W](W) writer structure
        impl crate::Writable for R8_SPI1_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_INTER_EN to value 0
        impl crate::Resettable for R8_SPI1_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_CLOCK_DIV (rw) register accessor: an alias for `Reg<R8_SPI1_CLOCK_DIV_SPEC>`
    pub type R8_SPI1_CLOCK_DIV = crate::Reg<r8_spi1_clock_div::R8_SPI1_CLOCK_DIV_SPEC>;
    ///RW, SPI1 master clock divisor;
    pub mod r8_spi1_clock_div {
        ///Register `R8_SPI1_CLOCK_DIV` reader
        pub struct R(crate::R<R8_SPI1_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_CLOCK_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_CLOCK_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_CLOCK_DIV` writer
        pub struct W(crate::W<R8_SPI1_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_CLOCK_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_CLOCK_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI1_CLOCK_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn r8_spi0_clock_div__r8_spi0_slave_pre(
                &self,
            ) -> R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn r8_spi0_clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<0> {
                R8_SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 master clock divisor;
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_clock_div](index.html) module
        pub struct R8_SPI1_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for R8_SPI1_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_clock_div::R](R) reader structure
        impl crate::Readable for R8_SPI1_CLOCK_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_clock_div::W](W) writer structure
        impl crate::Writable for R8_SPI1_CLOCK_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_CLOCK_DIV to value 0x10
        impl crate::Resettable for R8_SPI1_CLOCK_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    ///R8_SPI1_BUFFER (rw) register accessor: an alias for `Reg<R8_SPI1_BUFFER_SPEC>`
    pub type R8_SPI1_BUFFER = crate::Reg<r8_spi1_buffer::R8_SPI1_BUFFER_SPEC>;
    ///RW, SPI1 data buffer
    pub mod r8_spi1_buffer {
        ///Register `R8_SPI1_BUFFER` reader
        pub struct R(crate::R<R8_SPI1_BUFFER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_BUFFER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_BUFFER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_BUFFER` writer
        pub struct W(crate::W<R8_SPI1_BUFFER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_BUFFER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_BUFFER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI1_BUFFER` reader - RW, SPI1 data buffer
        pub type R8_SPI1_BUFFER_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI1_BUFFER` writer - RW, SPI1 data buffer
        pub type R8_SPI1_BUFFER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI1_BUFFER_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            pub fn r8_spi1_buffer(&self) -> R8_SPI1_BUFFER_R {
                R8_SPI1_BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            #[must_use]
            pub fn r8_spi1_buffer(&mut self) -> R8_SPI1_BUFFER_W<0> {
                R8_SPI1_BUFFER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 data buffer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_buffer](index.html) module
        pub struct R8_SPI1_BUFFER_SPEC;
        impl crate::RegisterSpec for R8_SPI1_BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_buffer::R](R) reader structure
        impl crate::Readable for R8_SPI1_BUFFER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_buffer::W](W) writer structure
        impl crate::Writable for R8_SPI1_BUFFER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_BUFFER to value 0
        impl crate::Resettable for R8_SPI1_BUFFER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_RUN_FLAG (r) register accessor: an alias for `Reg<R8_SPI1_RUN_FLAG_SPEC>`
    pub type R8_SPI1_RUN_FLAG = crate::Reg<r8_spi1_run_flag::R8_SPI1_RUN_FLAG_SPEC>;
    ///RO, SPI1 work flag
    pub mod r8_spi1_run_flag {
        ///Register `R8_SPI1_RUN_FLAG` reader
        pub struct R(crate::R<R8_SPI1_RUN_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_RUN_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_RUN_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_RUN_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type RB_SPI_SLV_CMD_ACT_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type RB_SPI_FIFO_READY_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type RB_SPI_SLV_CS_LOAD_R = crate::BitReader<bool>;
        ///Field `RB_SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type RB_SPI_SLV_SELECT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn rb_spi_slv_cmd_act(&self) -> RB_SPI_SLV_CMD_ACT_R {
                RB_SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn rb_spi_fifo_ready(&self) -> RB_SPI_FIFO_READY_R {
                RB_SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn rb_spi_slv_cs_load(&self) -> RB_SPI_SLV_CS_LOAD_R {
                RB_SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn rb_spi_slv_select(&self) -> RB_SPI_SLV_SELECT_R {
                RB_SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI1 work flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_run_flag](index.html) module
        pub struct R8_SPI1_RUN_FLAG_SPEC;
        impl crate::RegisterSpec for R8_SPI1_RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_run_flag::R](R) reader structure
        impl crate::Readable for R8_SPI1_RUN_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI1_RUN_FLAG to value 0
        impl crate::Resettable for R8_SPI1_RUN_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_INT_FLAG (rw) register accessor: an alias for `Reg<R8_SPI1_INT_FLAG_SPEC>`
    pub type R8_SPI1_INT_FLAG = crate::Reg<r8_spi1_int_flag::R8_SPI1_INT_FLAG_SPEC>;
    ///RW1, SPI1 interrupt flag
    pub mod r8_spi1_int_flag {
        ///Register `R8_SPI1_INT_FLAG` reader
        pub struct R(crate::R<R8_SPI1_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_INT_FLAG` writer
        pub struct W(crate::W<R8_SPI1_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type RB_SPI_IF_CNT_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type RB_SPI_IF_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type RB_SPI_IF_BYTE_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type RB_SPI_IF_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type RB_SPI_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type RB_SPI_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type RB_SPI_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type RB_SPI_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type RB_SPI_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type RB_SPI_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_FREE` reader - RO, current SPI free status
        pub type RB_SPI_FREE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_FREE` writer - RO, current SPI free status
        pub type RB_SPI_FREE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `RB_SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type RB_SPI_IF_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `RB_SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type RB_SPI_IF_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_SPI1_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn rb_spi_if_cnt_end(&self) -> RB_SPI_IF_CNT_END_R {
                RB_SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn rb_spi_if_byte_end(&self) -> RB_SPI_IF_BYTE_END_R {
                RB_SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn rb_spi_if_fifo_hf(&self) -> RB_SPI_IF_FIFO_HF_R {
                RB_SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn rb_spi_if_dma_end(&self) -> RB_SPI_IF_DMA_END_R {
                RB_SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn rb_spi_if_fifo_ov(&self) -> RB_SPI_IF_FIFO_OV_R {
                RB_SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn rb_spi_free(&self) -> RB_SPI_FREE_R {
                RB_SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn rb_spi_if_fst_byte(&self) -> RB_SPI_IF_FST_BYTE_R {
                RB_SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_cnt_end(&mut self) -> RB_SPI_IF_CNT_END_W<0> {
                RB_SPI_IF_CNT_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_byte_end(&mut self) -> RB_SPI_IF_BYTE_END_W<1> {
                RB_SPI_IF_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fifo_hf(&mut self) -> RB_SPI_IF_FIFO_HF_W<2> {
                RB_SPI_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_dma_end(&mut self) -> RB_SPI_IF_DMA_END_W<3> {
                RB_SPI_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fifo_ov(&mut self) -> RB_SPI_IF_FIFO_OV_W<4> {
                RB_SPI_IF_FIFO_OV_W::new(self)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_free(&mut self) -> RB_SPI_FREE_W<6> {
                RB_SPI_FREE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn rb_spi_if_fst_byte(&mut self) -> RB_SPI_IF_FST_BYTE_W<7> {
                RB_SPI_IF_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, SPI1 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_int_flag](index.html) module
        pub struct R8_SPI1_INT_FLAG_SPEC;
        impl crate::RegisterSpec for R8_SPI1_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_int_flag::R](R) reader structure
        impl crate::Readable for R8_SPI1_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_int_flag::W](W) writer structure
        impl crate::Writable for R8_SPI1_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_INT_FLAG to value 0x40
        impl crate::Resettable for R8_SPI1_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///R8_SPI1_FIFO_COUNT (r) register accessor: an alias for `Reg<R8_SPI1_FIFO_COUNT_SPEC>`
    pub type R8_SPI1_FIFO_COUNT = crate::Reg<r8_spi1_fifo_count::R8_SPI1_FIFO_COUNT_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod r8_spi1_fifo_count {
        ///Register `R8_SPI1_FIFO_COUNT` reader
        pub struct R(crate::R<R8_SPI1_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SPI1_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type R8_SPI1_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn r8_spi1_fifo_count(&self) -> R8_SPI1_FIFO_COUNT_R {
                R8_SPI1_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_fifo_count](index.html) module
        pub struct R8_SPI1_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for R8_SPI1_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_fifo_count::R](R) reader structure
        impl crate::Readable for R8_SPI1_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI1_FIFO_COUNT to value 0
        impl crate::Resettable for R8_SPI1_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_SPI1_TOTAL_CNT (rw) register accessor: an alias for `Reg<R16_SPI1_TOTAL_CNT_SPEC>`
    pub type R16_SPI1_TOTAL_CNT = crate::Reg<r16_spi1_total_cnt::R16_SPI1_TOTAL_CNT_SPEC>;
    ///RW, SPI1 total byte count, only low 12 bit
    pub mod r16_spi1_total_cnt {
        ///Register `R16_SPI1_TOTAL_CNT` reader
        pub struct R(crate::R<R16_SPI1_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_SPI1_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_SPI1_TOTAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_SPI1_TOTAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_SPI1_TOTAL_CNT` writer
        pub struct W(crate::W<R16_SPI1_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_SPI1_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_SPI1_TOTAL_CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_SPI1_TOTAL_CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_SPI1_TOTAL_CNT` reader - RW, SPI1 total byte count, only low 12 bit
        pub type R16_SPI1_TOTAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `R16_SPI1_TOTAL_CNT` writer - RW, SPI1 total byte count, only low 12 bit
        pub type R16_SPI1_TOTAL_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_SPI1_TOTAL_CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            pub fn r16_spi1_total_cnt(&self) -> R16_SPI1_TOTAL_CNT_R {
                R16_SPI1_TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn r16_spi1_total_cnt(&mut self) -> R16_SPI1_TOTAL_CNT_W<0> {
                R16_SPI1_TOTAL_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 total byte count, only low 12 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_spi1_total_cnt](index.html) module
        pub struct R16_SPI1_TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for R16_SPI1_TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_spi1_total_cnt::R](R) reader structure
        impl crate::Readable for R16_SPI1_TOTAL_CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_spi1_total_cnt::W](W) writer structure
        impl crate::Writable for R16_SPI1_TOTAL_CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_SPI1_TOTAL_CNT to value 0
        impl crate::Resettable for R16_SPI1_TOTAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_FIFO (rw) register accessor: an alias for `Reg<R8_SPI1_FIFO_SPEC>`
    pub type R8_SPI1_FIFO = crate::Reg<r8_spi1_fifo::R8_SPI1_FIFO_SPEC>;
    ///RO/WO, SPI1 FIFO register
    pub mod r8_spi1_fifo {
        ///Register `R8_SPI1_FIFO` reader
        pub struct R(crate::R<R8_SPI1_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_SPI1_FIFO` writer
        pub struct W(crate::W<R8_SPI1_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_SPI1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_SPI1_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_SPI1_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_SPI1_FIFO` reader - RO/WO, SPI1 FIFO register
        pub type R8_SPI1_FIFO_R = crate::FieldReader<u8, u8>;
        ///Field `R8_SPI1_FIFO` writer - RO/WO, SPI1 FIFO register
        pub type R8_SPI1_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_SPI1_FIFO_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            pub fn r8_spi1_fifo(&self) -> R8_SPI1_FIFO_R {
                R8_SPI1_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn r8_spi1_fifo(&mut self) -> R8_SPI1_FIFO_W<0> {
                R8_SPI1_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, SPI1 FIFO register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_fifo](index.html) module
        pub struct R8_SPI1_FIFO_SPEC;
        impl crate::RegisterSpec for R8_SPI1_FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_fifo::R](R) reader structure
        impl crate::Readable for R8_SPI1_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_spi1_fifo::W](W) writer structure
        impl crate::Writable for R8_SPI1_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_SPI1_FIFO to value 0
        impl crate::Resettable for R8_SPI1_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_SPI1_FIFO_COUNT1 (r) register accessor: an alias for `Reg<R8_SPI1_FIFO_COUNT1_SPEC>`
    pub type R8_SPI1_FIFO_COUNT1 = crate::Reg<r8_spi1_fifo_count1::R8_SPI1_FIFO_COUNT1_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod r8_spi1_fifo_count1 {
        ///Register `R8_SPI1_FIFO_COUNT1` reader
        pub struct R(crate::R<R8_SPI1_FIFO_COUNT1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_SPI1_FIFO_COUNT1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_SPI1_FIFO_COUNT1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_SPI1_FIFO_COUNT1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SPI1_FIFO_COUNT1` reader - RO, SPI1 FIFO count status
        pub type R8_SPI1_FIFO_COUNT1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI1 FIFO count status
            #[inline(always)]
            pub fn r8_spi1_fifo_count1(&self) -> R8_SPI1_FIFO_COUNT1_R {
                R8_SPI1_FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_spi1_fifo_count1](index.html) module
        pub struct R8_SPI1_FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for R8_SPI1_FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_spi1_fifo_count1::R](R) reader structure
        impl crate::Readable for R8_SPI1_FIFO_COUNT1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_SPI1_FIFO_COUNT1 to value 0
        impl crate::Resettable for R8_SPI1_FIFO_COUNT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///I2C register
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    ///Pointer to the register block
    pub const PTR: *const i2c::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
///I2C register
pub mod i2c {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, I2C control 1
        pub r16_i2c_ctrl1: R16_I2C_CTRL1,
        _reserved1: [u8; 0x02],
        ///0x04 - RW, I2C control 2
        pub r16_i2c_ctrl2: R16_I2C_CTRL2,
        _reserved2: [u8; 0x02],
        ///0x08 - RW, I2C own address register 1
        pub r16_i2c_oaddr1: R16_I2C_OADDR1,
        _reserved3: [u8; 0x02],
        ///0x0c - RW, I2C own address register 2
        pub r16_i2c_oaddr2: R16_I2C_OADDR2,
        _reserved4: [u8; 0x02],
        ///0x10 - RW, I2C data register
        pub r16_i2c_datar: R16_I2C_DATAR,
        _reserved5: [u8; 0x02],
        ///0x14 - R0, I2C stauts register 1
        pub r16_i2c_star1: R16_I2C_STAR1,
        _reserved6: [u8; 0x02],
        _reserved_6_r8_i2c_pec: [u8; 0x02],
        _reserved7: [u8; 0x02],
        ///0x1c - RW, I2C clock control register
        pub r16_i2c_ckcfgr: R16_I2C_CKCFGR,
        _reserved8: [u8; 0x02],
        ///0x20 - RW, I2C trise register
        pub r16_i2c_rtr: R16_I2C_RTR,
    }
    impl RegisterBlock {
        ///0x18 - R0, I2C status register 2
        #[inline(always)]
        pub const fn r16_i2c_star2(&self) -> &R16_I2C_STAR2 {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x19 - R0, I2C Packet error checking register
        #[inline(always)]
        pub const fn r8_i2c_pec(&self) -> &R8_I2C_PEC {
            unsafe { &*(self as *const Self).cast::<u8>().add(25usize).cast() }
        }
    }
    ///R16_I2C_CTRL1 (rw) register accessor: an alias for `Reg<R16_I2C_CTRL1_SPEC>`
    pub type R16_I2C_CTRL1 = crate::Reg<r16_i2c_ctrl1::R16_I2C_CTRL1_SPEC>;
    ///RW, I2C control 1
    pub mod r16_i2c_ctrl1 {
        ///Register `R16_I2C_CTRL1` reader
        pub struct R(crate::R<R16_I2C_CTRL1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_CTRL1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_CTRL1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_CTRL1` writer
        pub struct W(crate::W<R16_I2C_CTRL1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_CTRL1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_CTRL1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_PE` reader - RW, Peripheral enable
        pub type RB_I2C_PE_R = crate::BitReader<bool>;
        ///Field `RB_I2C_PE` writer - RW, Peripheral enable
        pub type RB_I2C_PE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type RB_I2C_SMBUS_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type RB_I2C_SMBUS_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host
        pub type RB_I2C_SMBTYPE_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host
        pub type RB_I2C_SMBTYPE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_EBARP` reader - RW, ARP enable
        pub type RB_I2C_EBARP_R = crate::BitReader<bool>;
        ///Field `RB_I2C_EBARP` writer - RW, ARP enable
        pub type RB_I2C_EBARP_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_ENPEC` reader - RW, PEC ebable
        pub type RB_I2C_ENPEC_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ENPEC` writer - RW, PEC ebable
        pub type RB_I2C_ENPEC_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_ENGC` reader - RW, General call enable
        pub type RB_I2C_ENGC_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ENGC` writer - RW, General call enable
        pub type RB_I2C_ENGC_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)
        pub type RB_I2C_NOSTRETCH_R = crate::BitReader<bool>;
        ///Field `RB_I2C_NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)
        pub type RB_I2C_NOSTRETCH_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type RB_I2C_START_R = crate::BitReader<bool>;
        ///Field `RB_I2C_START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type RB_I2C_START_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type RB_I2C_STOP_R = crate::BitReader<bool>;
        ///Field `RB_I2C_STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type RB_I2C_STOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_ACK` reader - RW, Acknowledge enable
        pub type RB_I2C_ACK_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ACK` writer - RW, Acknowledge enable
        pub type RB_I2C_ACK_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_POS` reader - RW, Acknowledge/PEC Position (for data reception)
        pub type RB_I2C_POS_R = crate::BitReader<bool>;
        ///Field `RB_I2C_POS` writer - RW, Acknowledge/PEC Position (for data reception)
        pub type RB_I2C_POS_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type RB_I2C_PEC_R = crate::BitReader<bool>;
        ///Field `RB_I2C_PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type RB_I2C_PEC_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type RB_I2C_ALERT_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type RB_I2C_ALERT_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        ///Field `RB_I2C_SWRST` reader - RW, Software reset
        pub type RB_I2C_SWRST_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SWRST` writer - RW, Software reset
        pub type RB_I2C_SWRST_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            pub fn rb_i2c_pe(&self) -> RB_I2C_PE_R {
                RB_I2C_PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            pub fn rb_i2c_smbus(&self) -> RB_I2C_SMBUS_R {
                RB_I2C_SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            pub fn rb_i2c_smbtype(&self) -> RB_I2C_SMBTYPE_R {
                RB_I2C_SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            pub fn rb_i2c_ebarp(&self) -> RB_I2C_EBARP_R {
                RB_I2C_EBARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            pub fn rb_i2c_enpec(&self) -> RB_I2C_ENPEC_R {
                RB_I2C_ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            pub fn rb_i2c_engc(&self) -> RB_I2C_ENGC_R {
                RB_I2C_ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn rb_i2c_nostretch(&self) -> RB_I2C_NOSTRETCH_R {
                RB_I2C_NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            pub fn rb_i2c_start(&self) -> RB_I2C_START_R {
                RB_I2C_START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            pub fn rb_i2c_stop(&self) -> RB_I2C_STOP_R {
                RB_I2C_STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            pub fn rb_i2c_ack(&self) -> RB_I2C_ACK_R {
                RB_I2C_ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn rb_i2c_pos(&self) -> RB_I2C_POS_R {
                RB_I2C_POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            pub fn rb_i2c_pec(&self) -> RB_I2C_PEC_R {
                RB_I2C_PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            pub fn rb_i2c_alert(&self) -> RB_I2C_ALERT_R {
                RB_I2C_ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            pub fn rb_i2c_swrst(&self) -> RB_I2C_SWRST_R {
                RB_I2C_SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_pe(&mut self) -> RB_I2C_PE_W<0> {
                RB_I2C_PE_W::new(self)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_smbus(&mut self) -> RB_I2C_SMBUS_W<1> {
                RB_I2C_SMBUS_W::new(self)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_smbtype(&mut self) -> RB_I2C_SMBTYPE_W<3> {
                RB_I2C_SMBTYPE_W::new(self)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_ebarp(&mut self) -> RB_I2C_EBARP_W<4> {
                RB_I2C_EBARP_W::new(self)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_enpec(&mut self) -> RB_I2C_ENPEC_W<5> {
                RB_I2C_ENPEC_W::new(self)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_engc(&mut self) -> RB_I2C_ENGC_W<6> {
                RB_I2C_ENGC_W::new(self)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_nostretch(&mut self) -> RB_I2C_NOSTRETCH_W<7> {
                RB_I2C_NOSTRETCH_W::new(self)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_start(&mut self) -> RB_I2C_START_W<8> {
                RB_I2C_START_W::new(self)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_stop(&mut self) -> RB_I2C_STOP_W<9> {
                RB_I2C_STOP_W::new(self)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_ack(&mut self) -> RB_I2C_ACK_W<10> {
                RB_I2C_ACK_W::new(self)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_pos(&mut self) -> RB_I2C_POS_W<11> {
                RB_I2C_POS_W::new(self)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_pec(&mut self) -> RB_I2C_PEC_W<12> {
                RB_I2C_PEC_W::new(self)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_alert(&mut self) -> RB_I2C_ALERT_W<13> {
                RB_I2C_ALERT_W::new(self)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_swrst(&mut self) -> RB_I2C_SWRST_W<15> {
                RB_I2C_SWRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_ctrl1](index.html) module
        pub struct R16_I2C_CTRL1_SPEC;
        impl crate::RegisterSpec for R16_I2C_CTRL1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_ctrl1::R](R) reader structure
        impl crate::Readable for R16_I2C_CTRL1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_ctrl1::W](W) writer structure
        impl crate::Writable for R16_I2C_CTRL1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_CTRL1 to value 0
        impl crate::Resettable for R16_I2C_CTRL1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_CTRL2 (rw) register accessor: an alias for `Reg<R16_I2C_CTRL2_SPEC>`
    pub type R16_I2C_CTRL2 = crate::Reg<r16_i2c_ctrl2::R16_I2C_CTRL2_SPEC>;
    ///RW, I2C control 2
    pub mod r16_i2c_ctrl2 {
        ///Register `R16_I2C_CTRL2` reader
        pub struct R(crate::R<R16_I2C_CTRL2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_CTRL2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_CTRL2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_CTRL2` writer
        pub struct W(crate::W<R16_I2C_CTRL2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_CTRL2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_CTRL2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type RB_I2C_FREQ_R = crate::FieldReader<u8, u8>;
        ///Field `RB_I2C_FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type RB_I2C_FREQ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_CTRL2_SPEC, u8, u8, 6, O>;
        ///Field `RB_I2C_ITERREN` reader - RW, Error interrupt enable
        pub type RB_I2C_ITERREN_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ITERREN` writer - RW, Error interrupt enable
        pub type RB_I2C_ITERREN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL2_SPEC, bool, O>;
        ///Field `RB_I2C_ITEVTEN` reader - RW, Event interrupt enable
        pub type RB_I2C_ITEVTEN_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ITEVTEN` writer - RW, Event interrupt enable
        pub type RB_I2C_ITEVTEN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL2_SPEC, bool, O>;
        ///Field `RB_I2C_ITBUFEN` reader - RW, Buffer interrupt enable
        pub type RB_I2C_ITBUFEN_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ITBUFEN` writer - RW, Buffer interrupt enable
        pub type RB_I2C_ITBUFEN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CTRL2_SPEC, bool, O>;
        impl R {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            pub fn rb_i2c_freq(&self) -> RB_I2C_FREQ_R {
                RB_I2C_FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            pub fn rb_i2c_iterren(&self) -> RB_I2C_ITERREN_R {
                RB_I2C_ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            pub fn rb_i2c_itevten(&self) -> RB_I2C_ITEVTEN_R {
                RB_I2C_ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            pub fn rb_i2c_itbufen(&self) -> RB_I2C_ITBUFEN_R {
                RB_I2C_ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_freq(&mut self) -> RB_I2C_FREQ_W<0> {
                RB_I2C_FREQ_W::new(self)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_iterren(&mut self) -> RB_I2C_ITERREN_W<8> {
                RB_I2C_ITERREN_W::new(self)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_itevten(&mut self) -> RB_I2C_ITEVTEN_W<9> {
                RB_I2C_ITEVTEN_W::new(self)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_itbufen(&mut self) -> RB_I2C_ITBUFEN_W<10> {
                RB_I2C_ITBUFEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_ctrl2](index.html) module
        pub struct R16_I2C_CTRL2_SPEC;
        impl crate::RegisterSpec for R16_I2C_CTRL2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_ctrl2::R](R) reader structure
        impl crate::Readable for R16_I2C_CTRL2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_ctrl2::W](W) writer structure
        impl crate::Writable for R16_I2C_CTRL2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_CTRL2 to value 0
        impl crate::Resettable for R16_I2C_CTRL2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_OADDR1 (rw) register accessor: an alias for `Reg<R16_I2C_OADDR1_SPEC>`
    pub type R16_I2C_OADDR1 = crate::Reg<r16_i2c_oaddr1::R16_I2C_OADDR1_SPEC>;
    ///RW, I2C own address register 1
    pub mod r16_i2c_oaddr1 {
        ///Register `R16_I2C_OADDR1` reader
        pub struct R(crate::R<R16_I2C_OADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_OADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_OADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_OADDR1` writer
        pub struct W(crate::W<R16_I2C_OADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_OADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_OADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_ADD0` reader - RW, bit0 of address in 10-bit addressing mode
        pub type RB_I2C_ADD0_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ADD0` writer - RW, bit0 of address in 10-bit addressing mode
        pub type RB_I2C_ADD0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_OADDR1_SPEC, bool, O>;
        ///Field `RB_I2C_ADD7_1` reader - RW, bit\[7:1\]
        ///of address
        pub type RB_I2C_ADD7_1_R = crate::FieldReader<u8, u8>;
        ///Field `RB_I2C_ADD7_1` writer - RW, bit\[7:1\]
        ///of address
        pub type RB_I2C_ADD7_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_OADDR1_SPEC, u8, u8, 7, O>;
        ///Field `RB_I2C_ADD9_8` reader - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type RB_I2C_ADD9_8_R = crate::FieldReader<u8, u8>;
        ///Field `RB_I2C_ADD9_8` writer - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type RB_I2C_ADD9_8_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_OADDR1_SPEC, u8, u8, 2, O>;
        ///Field `RB_I2C_MUST1` reader - RW, Should always be kept at 1
        pub type RB_I2C_MUST1_R = crate::BitReader<bool>;
        ///Field `RB_I2C_MUST1` writer - RW, Should always be kept at 1
        pub type RB_I2C_MUST1_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_OADDR1_SPEC, bool, O>;
        ///Field `RB_I2C_ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type RB_I2C_ADDMODE_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type RB_I2C_ADDMODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_OADDR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            pub fn rb_i2c_add0(&self) -> RB_I2C_ADD0_R {
                RB_I2C_ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            pub fn rb_i2c_add7_1(&self) -> RB_I2C_ADD7_1_R {
                RB_I2C_ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            pub fn rb_i2c_add9_8(&self) -> RB_I2C_ADD9_8_R {
                RB_I2C_ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            pub fn rb_i2c_must1(&self) -> RB_I2C_MUST1_R {
                RB_I2C_MUST1_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            pub fn rb_i2c_addmode(&self) -> RB_I2C_ADDMODE_R {
                RB_I2C_ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_add0(&mut self) -> RB_I2C_ADD0_W<0> {
                RB_I2C_ADD0_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_add7_1(&mut self) -> RB_I2C_ADD7_1_W<1> {
                RB_I2C_ADD7_1_W::new(self)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_add9_8(&mut self) -> RB_I2C_ADD9_8_W<8> {
                RB_I2C_ADD9_8_W::new(self)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_must1(&mut self) -> RB_I2C_MUST1_W<14> {
                RB_I2C_MUST1_W::new(self)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_addmode(&mut self) -> RB_I2C_ADDMODE_W<15> {
                RB_I2C_ADDMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_oaddr1](index.html) module
        pub struct R16_I2C_OADDR1_SPEC;
        impl crate::RegisterSpec for R16_I2C_OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_oaddr1::R](R) reader structure
        impl crate::Readable for R16_I2C_OADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_oaddr1::W](W) writer structure
        impl crate::Writable for R16_I2C_OADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_OADDR1 to value 0
        impl crate::Resettable for R16_I2C_OADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_OADDR2 (rw) register accessor: an alias for `Reg<R16_I2C_OADDR2_SPEC>`
    pub type R16_I2C_OADDR2 = crate::Reg<r16_i2c_oaddr2::R16_I2C_OADDR2_SPEC>;
    ///RW, I2C own address register 2
    pub mod r16_i2c_oaddr2 {
        ///Register `R16_I2C_OADDR2` reader
        pub struct R(crate::R<R16_I2C_OADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_OADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_OADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_OADDR2` writer
        pub struct W(crate::W<R16_I2C_OADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_OADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_OADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_ENDUAL` reader - RW, Dual addressing mode enable
        pub type RB_I2C_ENDUAL_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ENDUAL` writer - RW, Dual addressing mode enable
        pub type RB_I2C_ENDUAL_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_OADDR2_SPEC, bool, O>;
        ///Field `RB_I2C_ADD2` reader - RW, bit\[7:1\]
        ///of address2
        pub type RB_I2C_ADD2_R = crate::FieldReader<u8, u8>;
        ///Field `RB_I2C_ADD2` writer - RW, bit\[7:1\]
        ///of address2
        pub type RB_I2C_ADD2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_OADDR2_SPEC, u8, u8, 7, O>;
        impl R {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            pub fn rb_i2c_endual(&self) -> RB_I2C_ENDUAL_R {
                RB_I2C_ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            pub fn rb_i2c_add2(&self) -> RB_I2C_ADD2_R {
                RB_I2C_ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_endual(&mut self) -> RB_I2C_ENDUAL_W<0> {
                RB_I2C_ENDUAL_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_add2(&mut self) -> RB_I2C_ADD2_W<1> {
                RB_I2C_ADD2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_oaddr2](index.html) module
        pub struct R16_I2C_OADDR2_SPEC;
        impl crate::RegisterSpec for R16_I2C_OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_oaddr2::R](R) reader structure
        impl crate::Readable for R16_I2C_OADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_oaddr2::W](W) writer structure
        impl crate::Writable for R16_I2C_OADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_OADDR2 to value 0
        impl crate::Resettable for R16_I2C_OADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_DATAR (rw) register accessor: an alias for `Reg<R16_I2C_DATAR_SPEC>`
    pub type R16_I2C_DATAR = crate::Reg<r16_i2c_datar::R16_I2C_DATAR_SPEC>;
    ///RW, I2C data register
    pub mod r16_i2c_datar {
        ///Register `R16_I2C_DATAR` reader
        pub struct R(crate::R<R16_I2C_DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_DATAR` writer
        pub struct W(crate::W<R16_I2C_DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_I2C_DATAR` reader - RW, I2C data register
        pub type R16_I2C_DATAR_R = crate::FieldReader<u8, u8>;
        ///Field `R16_I2C_DATAR` writer - RW, I2C data register
        pub type R16_I2C_DATAR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_DATAR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            pub fn r16_i2c_datar(&self) -> R16_I2C_DATAR_R {
                R16_I2C_DATAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            #[must_use]
            pub fn r16_i2c_datar(&mut self) -> R16_I2C_DATAR_W<0> {
                R16_I2C_DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_datar](index.html) module
        pub struct R16_I2C_DATAR_SPEC;
        impl crate::RegisterSpec for R16_I2C_DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_datar::R](R) reader structure
        impl crate::Readable for R16_I2C_DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_datar::W](W) writer structure
        impl crate::Writable for R16_I2C_DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_DATAR to value 0
        impl crate::Resettable for R16_I2C_DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_STAR1 (r) register accessor: an alias for `Reg<R16_I2C_STAR1_SPEC>`
    pub type R16_I2C_STAR1 = crate::Reg<r16_i2c_star1::R16_I2C_STAR1_SPEC>;
    ///R0, I2C stauts register 1
    pub mod r16_i2c_star1 {
        ///Register `R16_I2C_STAR1` reader
        pub struct R(crate::R<R16_I2C_STAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_STAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_STAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_I2C_SB` reader - RW0, Start bit flag (Master mode)
        pub type RB_I2C_SB_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag
        pub type RB_I2C_ADDR_R = crate::BitReader<bool>;
        ///Field `RB_I2C_BTF` reader - RO, Byte transfer finished flag
        pub type RB_I2C_BTF_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ADD10` reader - RO, 10-bit header sent flag (Master mode)
        pub type RB_I2C_ADD10_R = crate::BitReader<bool>;
        ///Field `RB_I2C_STOPF` reader - RO, Stop detection flag (slave mode)
        pub type RB_I2C_STOPF_R = crate::BitReader<bool>;
        ///Field `RB_I2C_RxNE` reader - RO, Data register not empty flag (receivers)
        pub type RB_I2C_RX_NE_R = crate::BitReader<bool>;
        ///Field `RB_I2C_TxE` reader - RO, Data register empty flag (transmitters)
        pub type RB_I2C_TX_E_R = crate::BitReader<bool>;
        ///Field `RB_I2C_BERR` reader - RW0, Bus error flag
        pub type RB_I2C_BERR_R = crate::BitReader<bool>;
        ///Field `RB_I2C_ARLO` reader - RW0, Arbitration lost flag (master mode)
        pub type RB_I2C_ARLO_R = crate::BitReader<bool>;
        ///Field `RB_I2C_AF` reader - RW0, Acknowledge failure flag
        pub type RB_I2C_AF_R = crate::BitReader<bool>;
        ///Field `RB_I2C_OVR` reader - RW0, Overrun/Underrun flag
        pub type RB_I2C_OVR_R = crate::BitReader<bool>;
        ///Field `RB_I2C_PECERR` reader - RW0, PEC Error flag in reception
        pub type RB_I2C_PECERR_R = crate::BitReader<bool>;
        ///Field `RB_I2C_TIMEOUT` reader - RW0, Timeout or Tlow error flag
        pub type RB_I2C_TIMEOUT_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SMBALERT` reader - RW0, SMBus alert flag
        pub type RB_I2C_SMBALERT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW0, Start bit flag (Master mode)
            #[inline(always)]
            pub fn rb_i2c_sb(&self) -> RB_I2C_SB_R {
                RB_I2C_SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag
            #[inline(always)]
            pub fn rb_i2c_addr(&self) -> RB_I2C_ADDR_R {
                RB_I2C_ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Byte transfer finished flag
            #[inline(always)]
            pub fn rb_i2c_btf(&self) -> RB_I2C_BTF_R {
                RB_I2C_BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, 10-bit header sent flag (Master mode)
            #[inline(always)]
            pub fn rb_i2c_add10(&self) -> RB_I2C_ADD10_R {
                RB_I2C_ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, Stop detection flag (slave mode)
            #[inline(always)]
            pub fn rb_i2c_stopf(&self) -> RB_I2C_STOPF_R {
                RB_I2C_STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, Data register not empty flag (receivers)
            #[inline(always)]
            pub fn rb_i2c_rx_ne(&self) -> RB_I2C_RX_NE_R {
                RB_I2C_RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Data register empty flag (transmitters)
            #[inline(always)]
            pub fn rb_i2c_tx_e(&self) -> RB_I2C_TX_E_R {
                RB_I2C_TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW0, Bus error flag
            #[inline(always)]
            pub fn rb_i2c_berr(&self) -> RB_I2C_BERR_R {
                RB_I2C_BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW0, Arbitration lost flag (master mode)
            #[inline(always)]
            pub fn rb_i2c_arlo(&self) -> RB_I2C_ARLO_R {
                RB_I2C_ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW0, Acknowledge failure flag
            #[inline(always)]
            pub fn rb_i2c_af(&self) -> RB_I2C_AF_R {
                RB_I2C_AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW0, Overrun/Underrun flag
            #[inline(always)]
            pub fn rb_i2c_ovr(&self) -> RB_I2C_OVR_R {
                RB_I2C_OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW0, PEC Error flag in reception
            #[inline(always)]
            pub fn rb_i2c_pecerr(&self) -> RB_I2C_PECERR_R {
                RB_I2C_PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW0, Timeout or Tlow error flag
            #[inline(always)]
            pub fn rb_i2c_timeout(&self) -> RB_I2C_TIMEOUT_R {
                RB_I2C_TIMEOUT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW0, SMBus alert flag
            #[inline(always)]
            pub fn rb_i2c_smbalert(&self) -> RB_I2C_SMBALERT_R {
                RB_I2C_SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///R0, I2C stauts register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_star1](index.html) module
        pub struct R16_I2C_STAR1_SPEC;
        impl crate::RegisterSpec for R16_I2C_STAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_star1::R](R) reader structure
        impl crate::Readable for R16_I2C_STAR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_I2C_STAR1 to value 0
        impl crate::Resettable for R16_I2C_STAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_STAR2 (r) register accessor: an alias for `Reg<R16_I2C_STAR2_SPEC>`
    pub type R16_I2C_STAR2 = crate::Reg<r16_i2c_star2::R16_I2C_STAR2_SPEC>;
    ///R0, I2C status register 2
    pub mod r16_i2c_star2 {
        ///Register `R16_I2C_STAR2` reader
        pub struct R(crate::R<R16_I2C_STAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_STAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_STAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_STAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_I2C_MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode
        pub type RB_I2C_MSL_R = crate::BitReader<bool>;
        ///Field `RB_I2C_BUSY` reader - RO, Bus busy flag
        pub type RB_I2C_BUSY_R = crate::BitReader<bool>;
        ///Field `RB_I2C_TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
        pub type RB_I2C_TRA_R = crate::BitReader<bool>;
        ///Field `RB_I2C_GENCALL` reader - RO, General call address (Slave mode) received flag
        pub type RB_I2C_GENCALL_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag
        pub type RB_I2C_SMBDEFAULT_R = crate::BitReader<bool>;
        ///Field `RB_I2C_SMBHOST` reader - RO, SMBus host header (Slave mode) received flag
        pub type RB_I2C_SMBHOST_R = crate::BitReader<bool>;
        ///Field `RB_I2C_DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
        pub type RB_I2C_DUALF_R = crate::BitReader<bool>;
        ///Field `RB_I2C_PECX` reader - RO, Packet error checking register
        pub type RB_I2C_PECX_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode
            #[inline(always)]
            pub fn rb_i2c_msl(&self) -> RB_I2C_MSL_R {
                RB_I2C_MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, Bus busy flag
            #[inline(always)]
            pub fn rb_i2c_busy(&self) -> RB_I2C_BUSY_R {
                RB_I2C_BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
            #[inline(always)]
            pub fn rb_i2c_tra(&self) -> RB_I2C_TRA_R {
                RB_I2C_TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RO, General call address (Slave mode) received flag
            #[inline(always)]
            pub fn rb_i2c_gencall(&self) -> RB_I2C_GENCALL_R {
                RB_I2C_GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SMBus device default address (Slave mode) received flag
            #[inline(always)]
            pub fn rb_i2c_smbdefault(&self) -> RB_I2C_SMBDEFAULT_R {
                RB_I2C_SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SMBus host header (Slave mode) received flag
            #[inline(always)]
            pub fn rb_i2c_smbhost(&self) -> RB_I2C_SMBHOST_R {
                RB_I2C_SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
            #[inline(always)]
            pub fn rb_i2c_dualf(&self) -> RB_I2C_DUALF_R {
                RB_I2C_DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - RO, Packet error checking register
            #[inline(always)]
            pub fn rb_i2c_pecx(&self) -> RB_I2C_PECX_R {
                RB_I2C_PECX_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///R0, I2C status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_star2](index.html) module
        pub struct R16_I2C_STAR2_SPEC;
        impl crate::RegisterSpec for R16_I2C_STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_star2::R](R) reader structure
        impl crate::Readable for R16_I2C_STAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R16_I2C_STAR2 to value 0
        impl crate::Resettable for R16_I2C_STAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_I2C_PEC (r) register accessor: an alias for `Reg<R8_I2C_PEC_SPEC>`
    pub type R8_I2C_PEC = crate::Reg<r8_i2c_pec::R8_I2C_PEC_SPEC>;
    ///R0, I2C Packet error checking register
    pub mod r8_i2c_pec {
        ///Register `R8_I2C_PEC` reader
        pub struct R(crate::R<R8_I2C_PEC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_I2C_PEC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_I2C_PEC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_I2C_PEC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type R8_SPI0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn r8_spi0_fifo_count(&self) -> R8_SPI0_FIFO_COUNT_R {
                R8_SPI0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///R0, I2C Packet error checking register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_i2c_pec](index.html) module
        pub struct R8_I2C_PEC_SPEC;
        impl crate::RegisterSpec for R8_I2C_PEC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_i2c_pec::R](R) reader structure
        impl crate::Readable for R8_I2C_PEC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_I2C_PEC to value 0
        impl crate::Resettable for R8_I2C_PEC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_CKCFGR (rw) register accessor: an alias for `Reg<R16_I2C_CKCFGR_SPEC>`
    pub type R16_I2C_CKCFGR = crate::Reg<r16_i2c_ckcfgr::R16_I2C_CKCFGR_SPEC>;
    ///RW, I2C clock control register
    pub mod r16_i2c_ckcfgr {
        ///Register `R16_I2C_CKCFGR` reader
        pub struct R(crate::R<R16_I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_CKCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_CKCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_CKCFGR` writer
        pub struct W(crate::W<R16_I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_CKCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_CKCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type RB_I2C_CCR_R = crate::FieldReader<u16, u16>;
        ///Field `RB_I2C_CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type RB_I2C_CCR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_CKCFGR_SPEC, u16, u16, 12, O>;
        ///Field `RB_I2C_DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type RB_I2C_DUTY_R = crate::BitReader<bool>;
        ///Field `RB_I2C_DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type RB_I2C_DUTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CKCFGR_SPEC, bool, O>;
        ///Field `RB_I2C_F_S` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type RB_I2C_F_S_R = crate::BitReader<bool>;
        ///Field `RB_I2C_F_S` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type RB_I2C_F_S_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, R16_I2C_CKCFGR_SPEC, bool, O>;
        impl R {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn rb_i2c_ccr(&self) -> RB_I2C_CCR_R {
                RB_I2C_CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            pub fn rb_i2c_duty(&self) -> RB_I2C_DUTY_R {
                RB_I2C_DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            pub fn rb_i2c_f_s(&self) -> RB_I2C_F_S_R {
                RB_I2C_F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_ccr(&mut self) -> RB_I2C_CCR_W<0> {
                RB_I2C_CCR_W::new(self)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_duty(&mut self) -> RB_I2C_DUTY_W<14> {
                RB_I2C_DUTY_W::new(self)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_f_s(&mut self) -> RB_I2C_F_S_W<15> {
                RB_I2C_F_S_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_ckcfgr](index.html) module
        pub struct R16_I2C_CKCFGR_SPEC;
        impl crate::RegisterSpec for R16_I2C_CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_ckcfgr::R](R) reader structure
        impl crate::Readable for R16_I2C_CKCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_ckcfgr::W](W) writer structure
        impl crate::Writable for R16_I2C_CKCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_CKCFGR to value 0
        impl crate::Resettable for R16_I2C_CKCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_I2C_RTR (rw) register accessor: an alias for `Reg<R16_I2C_RTR_SPEC>`
    pub type R16_I2C_RTR = crate::Reg<r16_i2c_rtr::R16_I2C_RTR_SPEC>;
    ///RW, I2C trise register
    pub mod r16_i2c_rtr {
        ///Register `R16_I2C_RTR` reader
        pub struct R(crate::R<R16_I2C_RTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_I2C_RTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_I2C_RTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_I2C_RTR` writer
        pub struct W(crate::W<R16_I2C_RTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_I2C_RTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_I2C_RTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_I2C_TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type RB_I2C_TRISE_R = crate::FieldReader<u8, u8>;
        ///Field `RB_I2C_TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type RB_I2C_TRISE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_I2C_RTR_SPEC, u8, u8, 6, O>;
        impl R {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn rb_i2c_trise(&self) -> RB_I2C_TRISE_R {
                RB_I2C_TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn rb_i2c_trise(&mut self) -> RB_I2C_TRISE_W<0> {
                RB_I2C_TRISE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C trise register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_i2c_rtr](index.html) module
        pub struct R16_I2C_RTR_SPEC;
        impl crate::RegisterSpec for R16_I2C_RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_i2c_rtr::R](R) reader structure
        impl crate::Readable for R16_I2C_RTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_i2c_rtr::W](W) writer structure
        impl crate::Writable for R16_I2C_RTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_I2C_RTR to value 0x02
        impl crate::Resettable for R16_I2C_RTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
}
///PWMx register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMx register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, PWM output enable control
        pub r8_pwm_out_en: R8_PWM_OUT_EN,
        ///0x01 - RW, PWM output polarity control
        pub r8_pwm_polar: R8_PWM_POLAR,
        ///0x02 - RW, PWM configuration
        pub r8_pwm_config: R8_PWM_CONFIG,
        ///0x03 - RW, PWM clock divisor
        pub r8_pwm_clock_div: R8_PWM_CLOCK_DIV,
        ///0x04 - RW, PWM4 data holding
        pub r8_pwm4_data: R8_PWM4_DATA,
        ///0x05 - RW, PWM5 data holding
        pub r8_pwm5_data: R8_PWM5_DATA,
        ///0x06 - RW, PWM6 data holding
        pub r8_pwm6_data: R8_PWM6_DATA,
        ///0x07 - RW, PWM7 data holding
        pub r8_pwm7_data: R8_PWM7_DATA,
        ///0x08 - RW, PWM8 data holding
        pub r8_pwm8_data: R8_PWM8_DATA,
        ///0x09 - RW, PWM9 data holding
        pub r8_pwm9_data: R8_PWM9_DATA,
        ///0x0a - RW, PWM10 data holding
        pub r8_pwm10_data: R8_PWM10_DATA,
        ///0x0b - RW, PWM11 data holding
        pub r8_pwm11_data: R8_PWM11_DATA,
        ///0x0c - RW, PWM interrupt control
        pub r8_pwm_int_ctrl: R8_PWM_INT_CTRL,
    }
    ///R8_PWM_OUT_EN (rw) register accessor: an alias for `Reg<R8_PWM_OUT_EN_SPEC>`
    pub type R8_PWM_OUT_EN = crate::Reg<r8_pwm_out_en::R8_PWM_OUT_EN_SPEC>;
    ///RW, PWM output enable control
    pub mod r8_pwm_out_en {
        ///Register `R8_PWM_OUT_EN` reader
        pub struct R(crate::R<R8_PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM_OUT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM_OUT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM_OUT_EN` writer
        pub struct W(crate::W<R8_PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM_OUT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM_OUT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PWM4_OUT_EN` reader - RW, PWM4 output enable
        pub type RB_PWM4_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM4_OUT_EN` writer - RW, PWM4 output enable
        pub type RB_PWM4_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM5_OUT_EN` reader - RW, PWM5 output enable
        pub type RB_PWM5_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM5_OUT_EN` writer - RW, PWM5 output enable
        pub type RB_PWM5_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM6_OUT_EN` reader - RW, PWM6 output enable
        pub type RB_PWM6_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM6_OUT_EN` writer - RW, PWM6 output enable
        pub type RB_PWM6_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM7_OUT_EN` reader - RW, PWM7 output enable
        pub type RB_PWM7_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM7_OUT_EN` writer - RW, PWM7 output enable
        pub type RB_PWM7_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM8_OUT_EN` reader - RW, PWM8 output enable
        pub type RB_PWM8_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM8_OUT_EN` writer - RW, PWM8 output enable
        pub type RB_PWM8_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM9_OUT_EN` reader - RW, PWM9 output enable
        pub type RB_PWM9_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM9_OUT_EN` writer - RW, PWM9 output enable
        pub type RB_PWM9_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM10_OUT_EN` reader - RW, PWM10 output enable
        pub type RB_PWM10_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM10_OUT_EN` writer - RW, PWM10 output enable
        pub type RB_PWM10_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        ///Field `RB_PWM11_OUT_EN` reader - RW, PWM11 output enable
        pub type RB_PWM11_OUT_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM11_OUT_EN` writer - RW, PWM11 output enable
        pub type RB_PWM11_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_OUT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            pub fn rb_pwm4_out_en(&self) -> RB_PWM4_OUT_EN_R {
                RB_PWM4_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            pub fn rb_pwm5_out_en(&self) -> RB_PWM5_OUT_EN_R {
                RB_PWM5_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            pub fn rb_pwm6_out_en(&self) -> RB_PWM6_OUT_EN_R {
                RB_PWM6_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            pub fn rb_pwm7_out_en(&self) -> RB_PWM7_OUT_EN_R {
                RB_PWM7_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            pub fn rb_pwm8_out_en(&self) -> RB_PWM8_OUT_EN_R {
                RB_PWM8_OUT_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            pub fn rb_pwm9_out_en(&self) -> RB_PWM9_OUT_EN_R {
                RB_PWM9_OUT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            pub fn rb_pwm10_out_en(&self) -> RB_PWM10_OUT_EN_R {
                RB_PWM10_OUT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            pub fn rb_pwm11_out_en(&self) -> RB_PWM11_OUT_EN_R {
                RB_PWM11_OUT_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm4_out_en(&mut self) -> RB_PWM4_OUT_EN_W<0> {
                RB_PWM4_OUT_EN_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm5_out_en(&mut self) -> RB_PWM5_OUT_EN_W<1> {
                RB_PWM5_OUT_EN_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm6_out_en(&mut self) -> RB_PWM6_OUT_EN_W<2> {
                RB_PWM6_OUT_EN_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm7_out_en(&mut self) -> RB_PWM7_OUT_EN_W<3> {
                RB_PWM7_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm8_out_en(&mut self) -> RB_PWM8_OUT_EN_W<4> {
                RB_PWM8_OUT_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm9_out_en(&mut self) -> RB_PWM9_OUT_EN_W<5> {
                RB_PWM9_OUT_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm10_out_en(&mut self) -> RB_PWM10_OUT_EN_W<6> {
                RB_PWM10_OUT_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm11_out_en(&mut self) -> RB_PWM11_OUT_EN_W<7> {
                RB_PWM11_OUT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output enable control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm_out_en](index.html) module
        pub struct R8_PWM_OUT_EN_SPEC;
        impl crate::RegisterSpec for R8_PWM_OUT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm_out_en::R](R) reader structure
        impl crate::Readable for R8_PWM_OUT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm_out_en::W](W) writer structure
        impl crate::Writable for R8_PWM_OUT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM_OUT_EN to value 0
        impl crate::Resettable for R8_PWM_OUT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM_POLAR (rw) register accessor: an alias for `Reg<R8_PWM_POLAR_SPEC>`
    pub type R8_PWM_POLAR = crate::Reg<r8_pwm_polar::R8_PWM_POLAR_SPEC>;
    ///RW, PWM output polarity control
    pub mod r8_pwm_polar {
        ///Register `R8_PWM_POLAR` reader
        pub struct R(crate::R<R8_PWM_POLAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM_POLAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM_POLAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM_POLAR` writer
        pub struct W(crate::W<R8_PWM_POLAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM_POLAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM_POLAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM4_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM4_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM5_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM5_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM6_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM6_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM7_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM7_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM8_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM8_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM9_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM9_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM10_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM10_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        ///Field `RB_PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM11_POLAR_R = crate::BitReader<bool>;
        ///Field `RB_PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type RB_PWM11_POLAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_POLAR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm4_polar(&self) -> RB_PWM4_POLAR_R {
                RB_PWM4_POLAR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm5_polar(&self) -> RB_PWM5_POLAR_R {
                RB_PWM5_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm6_polar(&self) -> RB_PWM6_POLAR_R {
                RB_PWM6_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm7_polar(&self) -> RB_PWM7_POLAR_R {
                RB_PWM7_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm8_polar(&self) -> RB_PWM8_POLAR_R {
                RB_PWM8_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm9_polar(&self) -> RB_PWM9_POLAR_R {
                RB_PWM9_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm10_polar(&self) -> RB_PWM10_POLAR_R {
                RB_PWM10_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn rb_pwm11_polar(&self) -> RB_PWM11_POLAR_R {
                RB_PWM11_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm4_polar(&mut self) -> RB_PWM4_POLAR_W<0> {
                RB_PWM4_POLAR_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm5_polar(&mut self) -> RB_PWM5_POLAR_W<1> {
                RB_PWM5_POLAR_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm6_polar(&mut self) -> RB_PWM6_POLAR_W<2> {
                RB_PWM6_POLAR_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm7_polar(&mut self) -> RB_PWM7_POLAR_W<3> {
                RB_PWM7_POLAR_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm8_polar(&mut self) -> RB_PWM8_POLAR_W<4> {
                RB_PWM8_POLAR_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm9_polar(&mut self) -> RB_PWM9_POLAR_W<5> {
                RB_PWM9_POLAR_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm10_polar(&mut self) -> RB_PWM10_POLAR_W<6> {
                RB_PWM10_POLAR_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm11_polar(&mut self) -> RB_PWM11_POLAR_W<7> {
                RB_PWM11_POLAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output polarity control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm_polar](index.html) module
        pub struct R8_PWM_POLAR_SPEC;
        impl crate::RegisterSpec for R8_PWM_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm_polar::R](R) reader structure
        impl crate::Readable for R8_PWM_POLAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm_polar::W](W) writer structure
        impl crate::Writable for R8_PWM_POLAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM_POLAR to value 0
        impl crate::Resettable for R8_PWM_POLAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM_CONFIG (rw) register accessor: an alias for `Reg<R8_PWM_CONFIG_SPEC>`
    pub type R8_PWM_CONFIG = crate::Reg<r8_pwm_config::R8_PWM_CONFIG_SPEC>;
    ///RW, PWM configuration
    pub mod r8_pwm_config {
        ///Register `R8_PWM_CONFIG` reader
        pub struct R(crate::R<R8_PWM_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM_CONFIG` writer
        pub struct W(crate::W<R8_PWM_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type RB_PWM_CYCLE_SEL_R = crate::BitReader<bool>;
        ///Field `RB_PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type RB_PWM_CYCLE_SEL_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_CONFIG_SPEC, bool, O>;
        ///Field `RB_PWM_STAG_ST` reader - RO, PWM stagger cycle status
        pub type RB_PWM_STAG_ST_R = crate::BitReader<bool>;
        ///Field `RB_PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type RB_PWM_CYC_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `RB_PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type RB_PWM_CYC_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM_CONFIG_SPEC, u8, u8, 2, O>;
        ///Field `RB_PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM4_5_STAG_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM4_5_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_CONFIG_SPEC, bool, O>;
        ///Field `RB_PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM6_7_STAG_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM6_7_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_CONFIG_SPEC, bool, O>;
        ///Field `RB_PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM8_9_STAG_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM8_9_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_CONFIG_SPEC, bool, O>;
        ///Field `RB_PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM10_11_STAG_EN_R = crate::BitReader<bool>;
        ///Field `RB_PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type RB_PWM10_11_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_CONFIG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            pub fn rb_pwm_cycle_sel(&self) -> RB_PWM_CYCLE_SEL_R {
                RB_PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, PWM stagger cycle status
            #[inline(always)]
            pub fn rb_pwm_stag_st(&self) -> RB_PWM_STAG_ST_R {
                RB_PWM_STAG_ST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            pub fn rb_pwm_cyc_mod(&self) -> RB_PWM_CYC_MOD_R {
                RB_PWM_CYC_MOD_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn rb_pwm4_5_stag_en(&self) -> RB_PWM4_5_STAG_EN_R {
                RB_PWM4_5_STAG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn rb_pwm6_7_stag_en(&self) -> RB_PWM6_7_STAG_EN_R {
                RB_PWM6_7_STAG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn rb_pwm8_9_stag_en(&self) -> RB_PWM8_9_STAG_EN_R {
                RB_PWM8_9_STAG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn rb_pwm10_11_stag_en(&self) -> RB_PWM10_11_STAG_EN_R {
                RB_PWM10_11_STAG_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm_cycle_sel(&mut self) -> RB_PWM_CYCLE_SEL_W<0> {
                RB_PWM_CYCLE_SEL_W::new(self)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm_cyc_mod(&mut self) -> RB_PWM_CYC_MOD_W<2> {
                RB_PWM_CYC_MOD_W::new(self)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm4_5_stag_en(&mut self) -> RB_PWM4_5_STAG_EN_W<4> {
                RB_PWM4_5_STAG_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm6_7_stag_en(&mut self) -> RB_PWM6_7_STAG_EN_W<5> {
                RB_PWM6_7_STAG_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm8_9_stag_en(&mut self) -> RB_PWM8_9_STAG_EN_W<6> {
                RB_PWM8_9_STAG_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm10_11_stag_en(&mut self) -> RB_PWM10_11_STAG_EN_W<7> {
                RB_PWM10_11_STAG_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm_config](index.html) module
        pub struct R8_PWM_CONFIG_SPEC;
        impl crate::RegisterSpec for R8_PWM_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm_config::R](R) reader structure
        impl crate::Readable for R8_PWM_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm_config::W](W) writer structure
        impl crate::Writable for R8_PWM_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM_CONFIG to value 0
        impl crate::Resettable for R8_PWM_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM_CLOCK_DIV (rw) register accessor: an alias for `Reg<R8_PWM_CLOCK_DIV_SPEC>`
    pub type R8_PWM_CLOCK_DIV = crate::Reg<r8_pwm_clock_div::R8_PWM_CLOCK_DIV_SPEC>;
    ///RW, PWM clock divisor
    pub mod r8_pwm_clock_div {
        ///Register `R8_PWM_CLOCK_DIV` reader
        pub struct R(crate::R<R8_PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM_CLOCK_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM_CLOCK_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM_CLOCK_DIV` writer
        pub struct W(crate::W<R8_PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM_CLOCK_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM_CLOCK_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM_CLOCK_DIV` reader - RW, PWM clock divisor
        pub type R8_PWM_CLOCK_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM_CLOCK_DIV` writer - RW, PWM clock divisor
        pub type R8_PWM_CLOCK_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM_CLOCK_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            pub fn r8_pwm_clock_div(&self) -> R8_PWM_CLOCK_DIV_R {
                R8_PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm_clock_div(&mut self) -> R8_PWM_CLOCK_DIV_W<0> {
                R8_PWM_CLOCK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM clock divisor
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm_clock_div](index.html) module
        pub struct R8_PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for R8_PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm_clock_div::R](R) reader structure
        impl crate::Readable for R8_PWM_CLOCK_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm_clock_div::W](W) writer structure
        impl crate::Writable for R8_PWM_CLOCK_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM_CLOCK_DIV to value 0
        impl crate::Resettable for R8_PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM4_DATA (rw) register accessor: an alias for `Reg<R8_PWM4_DATA_SPEC>`
    pub type R8_PWM4_DATA = crate::Reg<r8_pwm4_data::R8_PWM4_DATA_SPEC>;
    ///RW, PWM4 data holding
    pub mod r8_pwm4_data {
        ///Register `R8_PWM4_DATA` reader
        pub struct R(crate::R<R8_PWM4_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM4_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM4_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM4_DATA` writer
        pub struct W(crate::W<R8_PWM4_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM4_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM4_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM4_DATA` reader - RW, PWM4 data holding
        pub type R8_PWM4_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM4_DATA` writer - RW, PWM4 data holding
        pub type R8_PWM4_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM4_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            pub fn r8_pwm4_data(&self) -> R8_PWM4_DATA_R {
                R8_PWM4_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm4_data(&mut self) -> R8_PWM4_DATA_W<0> {
                R8_PWM4_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM4 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm4_data](index.html) module
        pub struct R8_PWM4_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM4_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm4_data::R](R) reader structure
        impl crate::Readable for R8_PWM4_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm4_data::W](W) writer structure
        impl crate::Writable for R8_PWM4_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM4_DATA to value 0
        impl crate::Resettable for R8_PWM4_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM5_DATA (rw) register accessor: an alias for `Reg<R8_PWM5_DATA_SPEC>`
    pub type R8_PWM5_DATA = crate::Reg<r8_pwm5_data::R8_PWM5_DATA_SPEC>;
    ///RW, PWM5 data holding
    pub mod r8_pwm5_data {
        ///Register `R8_PWM5_DATA` reader
        pub struct R(crate::R<R8_PWM5_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM5_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM5_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM5_DATA` writer
        pub struct W(crate::W<R8_PWM5_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM5_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM5_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM5_DATA` reader - RW, PWM5 data holding
        pub type R8_PWM5_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM5_DATA` writer - RW, PWM5 data holding
        pub type R8_PWM5_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM5_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            pub fn r8_pwm5_data(&self) -> R8_PWM5_DATA_R {
                R8_PWM5_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm5_data(&mut self) -> R8_PWM5_DATA_W<0> {
                R8_PWM5_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM5 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm5_data](index.html) module
        pub struct R8_PWM5_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM5_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm5_data::R](R) reader structure
        impl crate::Readable for R8_PWM5_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm5_data::W](W) writer structure
        impl crate::Writable for R8_PWM5_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM5_DATA to value 0
        impl crate::Resettable for R8_PWM5_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM6_DATA (rw) register accessor: an alias for `Reg<R8_PWM6_DATA_SPEC>`
    pub type R8_PWM6_DATA = crate::Reg<r8_pwm6_data::R8_PWM6_DATA_SPEC>;
    ///RW, PWM6 data holding
    pub mod r8_pwm6_data {
        ///Register `R8_PWM6_DATA` reader
        pub struct R(crate::R<R8_PWM6_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM6_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM6_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM6_DATA` writer
        pub struct W(crate::W<R8_PWM6_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM6_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM6_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM6_DATA` reader - RW, PWM6 data holding
        pub type R8_PWM6_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM6_DATA` writer - RW, PWM6 data holding
        pub type R8_PWM6_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM6_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            pub fn r8_pwm6_data(&self) -> R8_PWM6_DATA_R {
                R8_PWM6_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm6_data(&mut self) -> R8_PWM6_DATA_W<0> {
                R8_PWM6_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM6 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm6_data](index.html) module
        pub struct R8_PWM6_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM6_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm6_data::R](R) reader structure
        impl crate::Readable for R8_PWM6_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm6_data::W](W) writer structure
        impl crate::Writable for R8_PWM6_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM6_DATA to value 0
        impl crate::Resettable for R8_PWM6_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM7_DATA (rw) register accessor: an alias for `Reg<R8_PWM7_DATA_SPEC>`
    pub type R8_PWM7_DATA = crate::Reg<r8_pwm7_data::R8_PWM7_DATA_SPEC>;
    ///RW, PWM7 data holding
    pub mod r8_pwm7_data {
        ///Register `R8_PWM7_DATA` reader
        pub struct R(crate::R<R8_PWM7_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM7_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM7_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM7_DATA` writer
        pub struct W(crate::W<R8_PWM7_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM7_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM7_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM7_DATA` reader - RW, PWM7 data holding
        pub type R8_PWM7_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM7_DATA` writer - RW, PWM7 data holding
        pub type R8_PWM7_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM7_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            pub fn r8_pwm7_data(&self) -> R8_PWM7_DATA_R {
                R8_PWM7_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm7_data(&mut self) -> R8_PWM7_DATA_W<0> {
                R8_PWM7_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM7 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm7_data](index.html) module
        pub struct R8_PWM7_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM7_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm7_data::R](R) reader structure
        impl crate::Readable for R8_PWM7_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm7_data::W](W) writer structure
        impl crate::Writable for R8_PWM7_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM7_DATA to value 0
        impl crate::Resettable for R8_PWM7_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM8_DATA (rw) register accessor: an alias for `Reg<R8_PWM8_DATA_SPEC>`
    pub type R8_PWM8_DATA = crate::Reg<r8_pwm8_data::R8_PWM8_DATA_SPEC>;
    ///RW, PWM8 data holding
    pub mod r8_pwm8_data {
        ///Register `R8_PWM8_DATA` reader
        pub struct R(crate::R<R8_PWM8_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM8_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM8_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM8_DATA` writer
        pub struct W(crate::W<R8_PWM8_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM8_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM8_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM8_DATA` reader - RW, PWM8 data holding
        pub type R8_PWM8_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM8_DATA` writer - RW, PWM8 data holding
        pub type R8_PWM8_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM8_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            pub fn r8_pwm8_data(&self) -> R8_PWM8_DATA_R {
                R8_PWM8_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm8_data(&mut self) -> R8_PWM8_DATA_W<0> {
                R8_PWM8_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM8 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm8_data](index.html) module
        pub struct R8_PWM8_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM8_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm8_data::R](R) reader structure
        impl crate::Readable for R8_PWM8_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm8_data::W](W) writer structure
        impl crate::Writable for R8_PWM8_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM8_DATA to value 0
        impl crate::Resettable for R8_PWM8_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM9_DATA (rw) register accessor: an alias for `Reg<R8_PWM9_DATA_SPEC>`
    pub type R8_PWM9_DATA = crate::Reg<r8_pwm9_data::R8_PWM9_DATA_SPEC>;
    ///RW, PWM9 data holding
    pub mod r8_pwm9_data {
        ///Register `R8_PWM9_DATA` reader
        pub struct R(crate::R<R8_PWM9_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM9_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM9_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM9_DATA` writer
        pub struct W(crate::W<R8_PWM9_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM9_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM9_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM9_DATA` reader - RW, PWM9 data holding
        pub type R8_PWM9_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM9_DATA` writer - RW, PWM9 data holding
        pub type R8_PWM9_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM9_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            pub fn r8_pwm9_data(&self) -> R8_PWM9_DATA_R {
                R8_PWM9_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm9_data(&mut self) -> R8_PWM9_DATA_W<0> {
                R8_PWM9_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM9 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm9_data](index.html) module
        pub struct R8_PWM9_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM9_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm9_data::R](R) reader structure
        impl crate::Readable for R8_PWM9_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm9_data::W](W) writer structure
        impl crate::Writable for R8_PWM9_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM9_DATA to value 0
        impl crate::Resettable for R8_PWM9_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM10_DATA (rw) register accessor: an alias for `Reg<R8_PWM10_DATA_SPEC>`
    pub type R8_PWM10_DATA = crate::Reg<r8_pwm10_data::R8_PWM10_DATA_SPEC>;
    ///RW, PWM10 data holding
    pub mod r8_pwm10_data {
        ///Register `R8_PWM10_DATA` reader
        pub struct R(crate::R<R8_PWM10_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM10_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM10_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM10_DATA` writer
        pub struct W(crate::W<R8_PWM10_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM10_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM10_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM10_DATA` reader - RW, PWM10 data holding
        pub type R8_PWM10_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM10_DATA` writer - RW, PWM10 data holding
        pub type R8_PWM10_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM10_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            pub fn r8_pwm10_data(&self) -> R8_PWM10_DATA_R {
                R8_PWM10_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm10_data(&mut self) -> R8_PWM10_DATA_W<0> {
                R8_PWM10_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM10 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm10_data](index.html) module
        pub struct R8_PWM10_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM10_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm10_data::R](R) reader structure
        impl crate::Readable for R8_PWM10_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm10_data::W](W) writer structure
        impl crate::Writable for R8_PWM10_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM10_DATA to value 0
        impl crate::Resettable for R8_PWM10_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM11_DATA (rw) register accessor: an alias for `Reg<R8_PWM11_DATA_SPEC>`
    pub type R8_PWM11_DATA = crate::Reg<r8_pwm11_data::R8_PWM11_DATA_SPEC>;
    ///RW, PWM11 data holding
    pub mod r8_pwm11_data {
        ///Register `R8_PWM11_DATA` reader
        pub struct R(crate::R<R8_PWM11_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM11_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM11_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM11_DATA` writer
        pub struct W(crate::W<R8_PWM11_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM11_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM11_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_PWM11_DATA` reader - RW, PWM11 data holding
        pub type R8_PWM11_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `R8_PWM11_DATA` writer - RW, PWM11 data holding
        pub type R8_PWM11_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_PWM11_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            pub fn r8_pwm11_data(&self) -> R8_PWM11_DATA_R {
                R8_PWM11_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            #[must_use]
            pub fn r8_pwm11_data(&mut self) -> R8_PWM11_DATA_W<0> {
                R8_PWM11_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM11 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm11_data](index.html) module
        pub struct R8_PWM11_DATA_SPEC;
        impl crate::RegisterSpec for R8_PWM11_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm11_data::R](R) reader structure
        impl crate::Readable for R8_PWM11_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm11_data::W](W) writer structure
        impl crate::Writable for R8_PWM11_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM11_DATA to value 0
        impl crate::Resettable for R8_PWM11_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_PWM_INT_CTRL (rw) register accessor: an alias for `Reg<R8_PWM_INT_CTRL_SPEC>`
    pub type R8_PWM_INT_CTRL = crate::Reg<r8_pwm_int_ctrl::R8_PWM_INT_CTRL_SPEC>;
    ///RW, PWM interrupt control
    pub mod r8_pwm_int_ctrl {
        ///Register `R8_PWM_INT_CTRL` reader
        pub struct R(crate::R<R8_PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_PWM_INT_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_PWM_INT_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_PWM_INT_CTRL` writer
        pub struct W(crate::W<R8_PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_PWM_INT_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_PWM_INT_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end
        pub type RB_PWM_IE_CYC_R = crate::BitReader<bool>;
        ///Field `RB_PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end
        pub type RB_PWM_IE_CYC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_INT_CTRL_SPEC, bool, O>;
        ///Field `RB_PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point
        pub type RB_PWM_CYC_PRE_R = crate::BitReader<bool>;
        ///Field `RB_PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point
        pub type RB_PWM_CYC_PRE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_INT_CTRL_SPEC, bool, O>;
        ///Field `RB_PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end
        pub type RB_PWM_IF_CYC_R = crate::BitReader<bool>;
        ///Field `RB_PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end
        pub type RB_PWM_IF_CYC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_PWM_INT_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            pub fn rb_pwm_ie_cyc(&self) -> RB_PWM_IE_CYC_R {
                RB_PWM_IE_CYC_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            pub fn rb_pwm_cyc_pre(&self) -> RB_PWM_CYC_PRE_R {
                RB_PWM_CYC_PRE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            pub fn rb_pwm_if_cyc(&self) -> RB_PWM_IF_CYC_R {
                RB_PWM_IF_CYC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm_ie_cyc(&mut self) -> RB_PWM_IE_CYC_W<0> {
                RB_PWM_IE_CYC_W::new(self)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm_cyc_pre(&mut self) -> RB_PWM_CYC_PRE_W<1> {
                RB_PWM_CYC_PRE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn rb_pwm_if_cyc(&mut self) -> RB_PWM_IF_CYC_W<7> {
                RB_PWM_IF_CYC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM interrupt control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_pwm_int_ctrl](index.html) module
        pub struct R8_PWM_INT_CTRL_SPEC;
        impl crate::RegisterSpec for R8_PWM_INT_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_pwm_int_ctrl::R](R) reader structure
        impl crate::Readable for R8_PWM_INT_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_pwm_int_ctrl::W](W) writer structure
        impl crate::Writable for R8_PWM_INT_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_PWM_INT_CTRL to value 0
        impl crate::Resettable for R8_PWM_INT_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB register
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    ///Pointer to the register block
    pub const PTR: *const usb::RegisterBlock = 0x4000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
///USB register
pub mod usb {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB base control
        pub r8_usb_ctrl: R8_USB_CTRL,
        ///0x01 - USB device physical prot control
        pub r8_udev_ctrl__r8_uhost_ctrl: R8_UDEV_CTRL__R8_UHOST_CTRL,
        ///0x02 - USB interrupt enable
        pub r8_usb_int_en: R8_USB_INT_EN,
        ///0x03 - USB device address
        pub r8_usb_dev_ad: R8_USB_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB miscellaneous status
        pub r8_usb_mis_st: R8_USB_MIS_ST,
        ///0x06 - USB interrupt flag
        pub r8_usb_int_fg: R8_USB_INT_FG,
        ///0x07 - USB interrupt status
        pub r8_usb_int_st: R8_USB_INT_ST,
        ///0x08 - USB receiving length
        pub r8_usb_rx_len: R8_USB_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 4/1 mode
        pub r8_uep4_1_mod: R8_UEP4_1_MOD,
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        pub r8_uep2_3_mod__r8_uh_ep_mod: R8_UEP2_3_MOD__R8_UH_EP_MOD,
        ///0x0e - endpoint 5/6/7 mode
        pub r8_uep567_mod: R8_UEP567_MOD,
        _reserved11: [u8; 0x01],
        ///0x10 - endpoint 0 DMA buffer address
        pub r16_uep0_dma: R16_UEP0_DMA,
        _reserved12: [u8; 0x02],
        ///0x14 - endpoint 1 DMA buffer address
        pub r16_uep1_dma: R16_UEP1_DMA,
        _reserved13: [u8; 0x02],
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub r16_uep2_dma__r16_uh_rx_dma: R16_UEP2_DMA__R16_UH_RX_DMA,
        _reserved14: [u8; 0x02],
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub r16_uep3_dma__r16_uh_tx_dma: R16_UEP3_DMA__R16_UH_TX_DMA,
        _reserved15: [u8; 0x02],
        ///0x20 - endpoint 0 transmittal length
        pub r8_uep0_t_len: R8_UEP0_T_LEN,
        _reserved16: [u8; 0x01],
        ///0x22 - endpoint 0 control
        pub r8_uep0_ctrl: R8_UEP0_CTRL,
        _reserved17: [u8; 0x01],
        ///0x24 - endpoint 1 transmittal length
        pub r8_uep1_t_len: R8_UEP1_T_LEN,
        _reserved18: [u8; 0x01],
        ///0x26 - endpoint 1 control;host aux setup
        pub r8_uep1_ctrl__r8_uh_setup: R8_UEP1_CTRL__R8_UH_SETUP,
        _reserved19: [u8; 0x01],
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        pub r8_uep2_t_len_r8_uh_ep_pid: R8_UEP2_T_LEN_R8_UH_EP_PID,
        _reserved20: [u8; 0x01],
        ///0x2a - endpoint 2 control;host receiver endpoint control
        pub r8_uep2_ctrl_r8_uh_rx_ctrl: R8_UEP2_CTRL_R8_UH_RX_CTRL,
        _reserved21: [u8; 0x01],
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub r8_uep3_t_len__r8_uh_tx_len: R8_UEP3_T_LEN__R8_UH_TX_LEN,
        _reserved22: [u8; 0x01],
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        pub r8_uep3_ctrl__r8_uh_tx_ctrl: R8_UEP3_CTRL__R8_UH_TX_CTRL,
        _reserved23: [u8; 0x01],
        ///0x30 - endpoint 4 transmittal length
        pub r8_uep4_t_len: R8_UEP4_T_LEN,
        _reserved24: [u8; 0x01],
        ///0x32 - endpoint 4 control
        pub r8_uep4_ctrl: R8_UEP4_CTRL,
        _reserved25: [u8; 0x21],
        ///0x54 - endpoint 5 DMA buffer address
        pub r16_uep5_dma: R16_UEP5_DMA,
        _reserved26: [u8; 0x02],
        ///0x58 - endpoint 6 DMA buffer address
        pub r16_uep6_dma: R16_UEP6_DMA,
        _reserved27: [u8; 0x02],
        ///0x5c - endpoint 7 DMA buffer address
        pub r16_uep7_dma: R16_UEP7_DMA,
        _reserved28: [u8; 0x06],
        ///0x64 - endpoint 5 transmittal length
        pub r8_uep5_t_len: R8_UEP5_T_LEN,
        _reserved29: [u8; 0x01],
        ///0x66 - endpoint 5 control
        pub r8_uep5_ctrl: R8_UEP5_CTRL,
        _reserved30: [u8; 0x01],
        ///0x68 - endpoint 6 transmittal length
        pub r8_uep6_t_len: R8_UEP6_T_LEN,
        _reserved31: [u8; 0x01],
        ///0x6a - endpoint 6 control
        pub r8_uep6_ctrl: R8_UEP6_CTRL,
        _reserved32: [u8; 0x01],
        ///0x6c - endpoint 7 transmittal length
        pub r8_uep7_t_len: R8_UEP7_T_LEN,
        _reserved33: [u8; 0x01],
        ///0x6e - endpoint 7 control
        pub r8_uep7_ctrl: R8_UEP7_CTRL,
    }
    ///R8_USB_CTRL (rw) register accessor: an alias for `Reg<R8_USB_CTRL_SPEC>`
    pub type R8_USB_CTRL = crate::Reg<r8_usb_ctrl::R8_USB_CTRL_SPEC>;
    ///USB base control
    pub mod r8_usb_ctrl {
        ///Register `R8_USB_CTRL` reader
        pub struct R(crate::R<R8_USB_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB_CTRL` writer
        pub struct W(crate::W<R8_USB_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type RB_UC_DMA_EN_R = crate::BitReader<bool>;
        ///Field `RB_UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type RB_UC_DMA_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type RB_UC_CLR_ALL_R = crate::BitReader<bool>;
        ///Field `RB_UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type RB_UC_CLR_ALL_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type RB_UC_RESET_SIE_R = crate::BitReader<bool>;
        ///Field `RB_UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type RB_UC_RESET_SIE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type RB_UC_INT_BUSY_R = crate::BitReader<bool>;
        ///Field `RB_UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type RB_UC_INT_BUSY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_USB_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type RB_UC_DEV_PU_EN_R = crate::BitReader<bool>;
        ///Field `RB_UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type RB_UC_DEV_PU_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type RB_UC_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `RB_UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type RB_UC_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type RB_UC_HOST_MODE_R = crate::BitReader<bool>;
        ///Field `RB_UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type RB_UC_HOST_MODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn rb_uc_dma_en(&self) -> RB_UC_DMA_EN_R {
                RB_UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn rb_uc_clr_all(&self) -> RB_UC_CLR_ALL_R {
                RB_UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn rb_uc_reset_sie(&self) -> RB_UC_RESET_SIE_R {
                RB_UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn rb_uc_int_busy(&self) -> RB_UC_INT_BUSY_R {
                RB_UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn rb_uc_dev_pu_en(&self) -> RB_UC_DEV_PU_EN_R {
                RB_UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn rb_uc_low_speed(&self) -> RB_UC_LOW_SPEED_R {
                RB_UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn rb_uc_host_mode(&self) -> RB_UC_HOST_MODE_R {
                RB_UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_dma_en(&mut self) -> RB_UC_DMA_EN_W<0> {
                RB_UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_clr_all(&mut self) -> RB_UC_CLR_ALL_W<1> {
                RB_UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_reset_sie(&mut self) -> RB_UC_RESET_SIE_W<2> {
                RB_UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_int_busy(&mut self) -> RB_UC_INT_BUSY_W<3> {
                RB_UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_dev_pu_en(&mut self) -> RB_UC_DEV_PU_EN_W<5> {
                RB_UC_DEV_PU_EN_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_low_speed(&mut self) -> RB_UC_LOW_SPEED_W<6> {
                RB_UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_host_mode(&mut self) -> RB_UC_HOST_MODE_W<7> {
                RB_UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_ctrl](index.html) module
        pub struct R8_USB_CTRL_SPEC;
        impl crate::RegisterSpec for R8_USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_ctrl::R](R) reader structure
        impl crate::Readable for R8_USB_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb_ctrl::W](W) writer structure
        impl crate::Writable for R8_USB_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB_CTRL to value 0x06
        impl crate::Resettable for R8_USB_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x06;
        }
    }
    ///R8_UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: an alias for `Reg<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>`
    pub type R8_UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<r8_udev_ctrl__r8_uhost_ctrl::R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod r8_udev_ctrl__r8_uhost_ctrl {
        ///Register `R8_UDEV_CTRL__R8_UHOST_CTRL` reader
        pub struct R(crate::R<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UDEV_CTRL__R8_UHOST_CTRL` writer
        pub struct W(crate::W<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type RB_UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader<bool>;
        ///Field `RB_UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type RB_UD_PORT_EN__RB_UH_PORT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type RB_UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `RB_UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type RB_UD_GP_BIT__RB_UH_BUS_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `RB_UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type RB_UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader<bool>;
        ///Field `RB_UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type RB_UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader<bool>;
        ///Field `RB_UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type RB_UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn rb_ud_port_en__rb_uh_port_en(&self) -> RB_UD_PORT_EN__RB_UH_PORT_EN_R {
                RB_UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn rb_ud_gp_bit__rb_uh_bus_reset(&self) -> RB_UD_GP_BIT__RB_UH_BUS_RESET_R {
                RB_UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn rb_ud_low_speed__rb_uh_low_speed(&self) -> RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn rb_ud_dm_pin__rb_uh_dm_pin(&self) -> RB_UD_DM_PIN__RB_UH_DM_PIN_R {
                RB_UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn rb_ud_dp_pin__rb_uh_dp_pin(&self) -> RB_UD_DP_PIN__RB_UH_DP_PIN_R {
                RB_UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn rb_ud_pd_dis__rb_uh_pd_dis(&self) -> RB_UD_PD_DIS__RB_UH_PD_DIS_R {
                RB_UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_port_en__rb_uh_port_en(&mut self) -> RB_UD_PORT_EN__RB_UH_PORT_EN_W<0> {
                RB_UD_PORT_EN__RB_UH_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_gp_bit__rb_uh_bus_reset(&mut self) -> RB_UD_GP_BIT__RB_UH_BUS_RESET_W<1> {
                RB_UD_GP_BIT__RB_UH_BUS_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_low_speed__rb_uh_low_speed(
                &mut self,
            ) -> RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W<2> {
                RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_udev_ctrl__r8_uhost_ctrl](index.html) module
        pub struct R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_udev_ctrl__r8_uhost_ctrl::R](R) reader structure
        impl crate::Readable for R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_udev_ctrl__r8_uhost_ctrl::W](W) writer structure
        impl crate::Writable for R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for R8_UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB_INT_EN (rw) register accessor: an alias for `Reg<R8_USB_INT_EN_SPEC>`
    pub type R8_USB_INT_EN = crate::Reg<r8_usb_int_en::R8_USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod r8_usb_int_en {
        ///Register `R8_USB_INT_EN` reader
        pub struct R(crate::R<R8_USB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB_INT_EN` writer
        pub struct W(crate::W<R8_USB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type RB_UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader<bool>;
        ///Field `RB_UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type RB_UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type RB_UIE_TRANSFER_R = crate::BitReader<bool>;
        ///Field `RB_UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type RB_UIE_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type RB_UIE_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type RB_UIE_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type RB_UIE_HST_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type RB_UIE_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type RB_UIE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type RB_UIE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type RB_UIE_DEV_NAK_R = crate::BitReader<bool>;
        ///Field `RB_UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type RB_UIE_DEV_NAK_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type RB_UIE_DEV_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type RB_UIE_DEV_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn rb_uie_bus_rst__rb_uie_detect(&self) -> RB_UIE_BUS_RST__RB_UIE_DETECT_R {
                RB_UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn rb_uie_transfer(&self) -> RB_UIE_TRANSFER_R {
                RB_UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn rb_uie_suspend(&self) -> RB_UIE_SUSPEND_R {
                RB_UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn rb_uie_hst_sof(&self) -> RB_UIE_HST_SOF_R {
                RB_UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn rb_uie_fifo_ov(&self) -> RB_UIE_FIFO_OV_R {
                RB_UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn rb_uie_dev_nak(&self) -> RB_UIE_DEV_NAK_R {
                RB_UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn rb_uie_dev_sof(&self) -> RB_UIE_DEV_SOF_R {
                RB_UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_bus_rst__rb_uie_detect(&mut self) -> RB_UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                RB_UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_transfer(&mut self) -> RB_UIE_TRANSFER_W<1> {
                RB_UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_suspend(&mut self) -> RB_UIE_SUSPEND_W<2> {
                RB_UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_hst_sof(&mut self) -> RB_UIE_HST_SOF_W<3> {
                RB_UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_fifo_ov(&mut self) -> RB_UIE_FIFO_OV_W<4> {
                RB_UIE_FIFO_OV_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_dev_nak(&mut self) -> RB_UIE_DEV_NAK_W<6> {
                RB_UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_dev_sof(&mut self) -> RB_UIE_DEV_SOF_W<7> {
                RB_UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_int_en](index.html) module
        pub struct R8_USB_INT_EN_SPEC;
        impl crate::RegisterSpec for R8_USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_int_en::R](R) reader structure
        impl crate::Readable for R8_USB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb_int_en::W](W) writer structure
        impl crate::Writable for R8_USB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB_INT_EN to value 0
        impl crate::Resettable for R8_USB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB_DEV_AD (rw) register accessor: an alias for `Reg<R8_USB_DEV_AD_SPEC>`
    pub type R8_USB_DEV_AD = crate::Reg<r8_usb_dev_ad::R8_USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod r8_usb_dev_ad {
        ///Register `R8_USB_DEV_AD` reader
        pub struct R(crate::R<R8_USB_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB_DEV_AD` writer
        pub struct W(crate::W<R8_USB_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_USB_DEV_AD_SPEC, u8, u8, 7, O>;
        ///Field `RB_UDA_GP_BIT` reader - general purpose bit
        pub type RB_UDA_GP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_UDA_GP_BIT` writer - general purpose bit
        pub type RB_UDA_GP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_DEV_AD_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn rb_uda_gp_bit(&self) -> RB_UDA_GP_BIT_R {
                RB_UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn rb_uda_gp_bit(&mut self) -> RB_UDA_GP_BIT_W<7> {
                RB_UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_dev_ad](index.html) module
        pub struct R8_USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for R8_USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_dev_ad::R](R) reader structure
        impl crate::Readable for R8_USB_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb_dev_ad::W](W) writer structure
        impl crate::Writable for R8_USB_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB_DEV_AD to value 0
        impl crate::Resettable for R8_USB_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB_MIS_ST (r) register accessor: an alias for `Reg<R8_USB_MIS_ST_SPEC>`
    pub type R8_USB_MIS_ST = crate::Reg<r8_usb_mis_st::R8_USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod r8_usb_mis_st {
        ///Register `R8_USB_MIS_ST` reader
        pub struct R(crate::R<R8_USB_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type RB_UMS_DEV_ATTACH_R = crate::BitReader<bool>;
        ///Field `RB_UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type RB_UMS_DM_LEVEL_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type RB_UMS_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type RB_UMS_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `RB_UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type RB_UMS_R_FIFO_RDY_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type RB_UMS_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type RB_UMS_SOF_ACT_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type RB_UMS_SOF_PRES_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn rb_ums_dev_attach(&self) -> RB_UMS_DEV_ATTACH_R {
                RB_UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn rb_ums_dm_level(&self) -> RB_UMS_DM_LEVEL_R {
                RB_UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn rb_ums_suspend(&self) -> RB_UMS_SUSPEND_R {
                RB_UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn rb_ums_bus_reset(&self) -> RB_UMS_BUS_RESET_R {
                RB_UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn rb_ums_r_fifo_rdy(&self) -> RB_UMS_R_FIFO_RDY_R {
                RB_UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn rb_ums_sie_free(&self) -> RB_UMS_SIE_FREE_R {
                RB_UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn rb_ums_sof_act(&self) -> RB_UMS_SOF_ACT_R {
                RB_UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn rb_ums_sof_pres(&self) -> RB_UMS_SOF_PRES_R {
                RB_UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_mis_st](index.html) module
        pub struct R8_USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for R8_USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_mis_st::R](R) reader structure
        impl crate::Readable for R8_USB_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB_MIS_ST to value 0
        impl crate::Resettable for R8_USB_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB_INT_FG (rw) register accessor: an alias for `Reg<R8_USB_INT_FG_SPEC>`
    pub type R8_USB_INT_FG = crate::Reg<r8_usb_int_fg::R8_USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod r8_usb_int_fg {
        ///Register `R8_USB_INT_FG` reader
        pub struct R(crate::R<R8_USB_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB_INT_FG` writer
        pub struct W(crate::W<R8_USB_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type RB_UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader<bool>;
        ///Field `RB_UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type RB_UIF_BUS_RST__RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_TRANSFER_R = crate::BitReader<bool>;
        ///Field `RB_UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type RB_UIF_HST_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type RB_UIF_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type RB_UIF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type RB_UIF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB_INT_FG_SPEC, bool, O>;
        ///Field `RB_U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type RB_U_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `RB_U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type RB_U_TOG_OK_R = crate::BitReader<bool>;
        ///Field `RB_U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type RB_U_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_bus_rst__rb_uif_detect(&self) -> RB_UIF_BUS_RST__RB_UIF_DETECT_R {
                RB_UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_transfer(&self) -> RB_UIF_TRANSFER_R {
                RB_UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_suspend(&self) -> RB_UIF_SUSPEND_R {
                RB_UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_hst_sof(&self) -> RB_UIF_HST_SOF_R {
                RB_UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_fifo_ov(&self) -> RB_UIF_FIFO_OV_R {
                RB_UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn rb_u_sie_free(&self) -> RB_U_SIE_FREE_R {
                RB_U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn rb_u_tog_ok(&self) -> RB_U_TOG_OK_R {
                RB_U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn rb_u_is_nak(&self) -> RB_U_IS_NAK_R {
                RB_U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_bus_rst__rb_uif_detect(&mut self) -> RB_UIF_BUS_RST__RB_UIF_DETECT_W<0> {
                RB_UIF_BUS_RST__RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_transfer(&mut self) -> RB_UIF_TRANSFER_W<1> {
                RB_UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_suspend(&mut self) -> RB_UIF_SUSPEND_W<2> {
                RB_UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_hst_sof(&mut self) -> RB_UIF_HST_SOF_W<3> {
                RB_UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_fifo_ov(&mut self) -> RB_UIF_FIFO_OV_W<4> {
                RB_UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_int_fg](index.html) module
        pub struct R8_USB_INT_FG_SPEC;
        impl crate::RegisterSpec for R8_USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_int_fg::R](R) reader structure
        impl crate::Readable for R8_USB_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb_int_fg::W](W) writer structure
        impl crate::Writable for R8_USB_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB_INT_FG to value 0x20
        impl crate::Resettable for R8_USB_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///R8_USB_INT_ST (r) register accessor: an alias for `Reg<R8_USB_INT_ST_SPEC>`
    pub type R8_USB_INT_ST = crate::Reg<r8_usb_int_st::R8_USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod r8_usb_int_st {
        ///Register `R8_USB_INT_ST` reader
        pub struct R(crate::R<R8_USB_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `RB_UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type RB_UIS_TOG_OK_R = crate::BitReader<bool>;
        ///Field `RB_UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type RB_UIS_SETUP_ACT_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn rb_uis_tog_ok(&self) -> RB_UIS_TOG_OK_R {
                RB_UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn rb_uis_setup_act(&self) -> RB_UIS_SETUP_ACT_R {
                RB_UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_int_st](index.html) module
        pub struct R8_USB_INT_ST_SPEC;
        impl crate::RegisterSpec for R8_USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_int_st::R](R) reader structure
        impl crate::Readable for R8_USB_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB_INT_ST to value 0
        impl crate::Resettable for R8_USB_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB_RX_LEN (r) register accessor: an alias for `Reg<R8_USB_RX_LEN_SPEC>`
    pub type R8_USB_RX_LEN = crate::Reg<r8_usb_rx_len::R8_USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod r8_usb_rx_len {
        ///Register `R8_USB_RX_LEN` reader
        pub struct R(crate::R<R8_USB_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_USB_RX_LEN` reader - RO,USB receiving length
        pub type R8_USB_RX_LEN_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn r8_usb_rx_len(&self) -> R8_USB_RX_LEN_R {
                R8_USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb_rx_len](index.html) module
        pub struct R8_USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for R8_USB_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb_rx_len::R](R) reader structure
        impl crate::Readable for R8_USB_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB_RX_LEN to value 0
        impl crate::Resettable for R8_USB_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP4_1_MOD (rw) register accessor: an alias for `Reg<R8_UEP4_1_MOD_SPEC>`
    pub type R8_UEP4_1_MOD = crate::Reg<r8_uep4_1_mod::R8_UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod r8_uep4_1_mod {
        ///Register `R8_UEP4_1_MOD` reader
        pub struct R(crate::R<R8_UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP4_1_MOD` writer
        pub struct W(crate::W<R8_UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type RB_UEP4_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type RB_UEP4_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type RB_UEP4_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type RB_UEP4_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type RB_UEP1_BUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type RB_UEP1_BUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type RB_UEP1_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type RB_UEP1_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type RB_UEP1_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type RB_UEP1_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_1_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep4_tx_en(&self) -> RB_UEP4_TX_EN_R {
                RB_UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep4_rx_en(&self) -> RB_UEP4_RX_EN_R {
                RB_UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn rb_uep1_buf_mod(&self) -> RB_UEP1_BUF_MOD_R {
                RB_UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep1_tx_en(&self) -> RB_UEP1_TX_EN_R {
                RB_UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep1_rx_en(&self) -> RB_UEP1_RX_EN_R {
                RB_UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep4_tx_en(&mut self) -> RB_UEP4_TX_EN_W<2> {
                RB_UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep4_rx_en(&mut self) -> RB_UEP4_RX_EN_W<3> {
                RB_UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_buf_mod(&mut self) -> RB_UEP1_BUF_MOD_W<4> {
                RB_UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_tx_en(&mut self) -> RB_UEP1_TX_EN_W<6> {
                RB_UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_rx_en(&mut self) -> RB_UEP1_RX_EN_W<7> {
                RB_UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep4_1_mod](index.html) module
        pub struct R8_UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for R8_UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep4_1_mod::R](R) reader structure
        impl crate::Readable for R8_UEP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep4_1_mod::W](W) writer structure
        impl crate::Writable for R8_UEP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP4_1_MOD to value 0
        impl crate::Resettable for R8_UEP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: an alias for `Reg<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>`
    pub type R8_UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<r8_uep2_3_mod__r8_uh_ep_mod::R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod r8_uep2_3_mod__r8_uh_ep_mod {
        ///Register `R8_UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub struct R(crate::R<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub struct W(crate::W<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type RB_UEP2_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type RB_UEP2_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type RB_UEP3_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type RB_UEP3_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn rb_uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &self,
            ) -> RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep2_tx_en(&self) -> RB_UEP2_TX_EN_R {
                RB_UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn rb_uep2_rx_en__rb_uh_ep_rx_en(&self) -> RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn rb_uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &self,
            ) -> RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn rb_uep3_tx_en__rb_uh_ep_tx_en(&self) -> RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep3_rx_en(&self) -> RB_UEP3_RX_EN_R {
                RB_UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<0> {
                RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_tx_en(&mut self) -> RB_UEP2_TX_EN_W<2> {
                RB_UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_rx_en__rb_uh_ep_rx_en(&mut self) -> RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W<3> {
                RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<4> {
                RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_tx_en__rb_uh_ep_tx_en(&mut self) -> RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W<6> {
                RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_rx_en(&mut self) -> RB_UEP3_RX_EN_W<7> {
                RB_UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep2_3_mod__r8_uh_ep_mod](index.html) module
        pub struct R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep2_3_mod__r8_uh_ep_mod::R](R) reader structure
        impl crate::Readable for R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep2_3_mod__r8_uh_ep_mod::W](W) writer structure
        impl crate::Writable for R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for R8_UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP567_MOD (rw) register accessor: an alias for `Reg<R8_UEP567_MOD_SPEC>`
    pub type R8_UEP567_MOD = crate::Reg<r8_uep567_mod::R8_UEP567_MOD_SPEC>;
    ///endpoint 5/6/7 mode
    pub mod r8_uep567_mod {
        ///Register `R8_UEP567_MOD` reader
        pub struct R(crate::R<R8_UEP567_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP567_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP567_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP567_MOD` writer
        pub struct W(crate::W<R8_UEP567_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP567_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP567_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type RB_UEP5_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type RB_UEP5_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type RB_UEP5_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type RB_UEP5_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type RB_UEP6_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type RB_UEP6_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type RB_UEP6_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type RB_UEP6_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type RB_UEP7_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type RB_UEP7_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type RB_UEP7_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type RB_UEP7_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP567_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep5_tx_en(&self) -> RB_UEP5_TX_EN_R {
                RB_UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep5_rx_en(&self) -> RB_UEP5_RX_EN_R {
                RB_UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep6_tx_en(&self) -> RB_UEP6_TX_EN_R {
                RB_UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep6_rx_en(&self) -> RB_UEP6_RX_EN_R {
                RB_UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep7_tx_en(&self) -> RB_UEP7_TX_EN_R {
                RB_UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep7_rx_en(&self) -> RB_UEP7_RX_EN_R {
                RB_UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep5_tx_en(&mut self) -> RB_UEP5_TX_EN_W<0> {
                RB_UEP5_TX_EN_W::new(self)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep5_rx_en(&mut self) -> RB_UEP5_RX_EN_W<1> {
                RB_UEP5_RX_EN_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep6_tx_en(&mut self) -> RB_UEP6_TX_EN_W<2> {
                RB_UEP6_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep6_rx_en(&mut self) -> RB_UEP6_RX_EN_W<3> {
                RB_UEP6_RX_EN_W::new(self)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep7_tx_en(&mut self) -> RB_UEP7_TX_EN_W<4> {
                RB_UEP7_TX_EN_W::new(self)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep7_rx_en(&mut self) -> RB_UEP7_RX_EN_W<5> {
                RB_UEP7_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5/6/7 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep567_mod](index.html) module
        pub struct R8_UEP567_MOD_SPEC;
        impl crate::RegisterSpec for R8_UEP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep567_mod::R](R) reader structure
        impl crate::Readable for R8_UEP567_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep567_mod::W](W) writer structure
        impl crate::Writable for R8_UEP567_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP567_MOD to value 0
        impl crate::Resettable for R8_UEP567_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP0_DMA (rw) register accessor: an alias for `Reg<R16_UEP0_DMA_SPEC>`
    pub type R16_UEP0_DMA = crate::Reg<r16_uep0_dma::R16_UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod r16_uep0_dma {
        ///Register `R16_UEP0_DMA` reader
        pub struct R(crate::R<R16_UEP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP0_DMA` writer
        pub struct W(crate::W<R16_UEP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type R16_UEP0_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type R16_UEP0_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP0_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn r16_uep0_dma(&self) -> R16_UEP0_DMA_R {
                R16_UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep0_dma(&mut self) -> R16_UEP0_DMA_W<0> {
                R16_UEP0_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep0_dma](index.html) module
        pub struct R16_UEP0_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep0_dma::R](R) reader structure
        impl crate::Readable for R16_UEP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep0_dma::W](W) writer structure
        impl crate::Writable for R16_UEP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP0_DMA to value 0
        impl crate::Resettable for R16_UEP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP1_DMA (rw) register accessor: an alias for `Reg<R16_UEP1_DMA_SPEC>`
    pub type R16_UEP1_DMA = crate::Reg<r16_uep1_dma::R16_UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod r16_uep1_dma {
        ///Register `R16_UEP1_DMA` reader
        pub struct R(crate::R<R16_UEP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP1_DMA` writer
        pub struct W(crate::W<R16_UEP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type R16_UEP1_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type R16_UEP1_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP1_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn r16_uep1_dma(&self) -> R16_UEP1_DMA_R {
                R16_UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep1_dma(&mut self) -> R16_UEP1_DMA_W<0> {
                R16_UEP1_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep1_dma](index.html) module
        pub struct R16_UEP1_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep1_dma::R](R) reader structure
        impl crate::Readable for R16_UEP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep1_dma::W](W) writer structure
        impl crate::Writable for R16_UEP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP1_DMA to value 0
        impl crate::Resettable for R16_UEP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: an alias for `Reg<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>`
    pub type R16_UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<r16_uep2_dma__r16_uh_rx_dma::R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod r16_uep2_dma__r16_uh_rx_dma {
        ///Register `R16_UEP2_DMA__R16_UH_RX_DMA` reader
        pub struct R(crate::R<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP2_DMA__R16_UH_RX_DMA` writer
        pub struct W(crate::W<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP2_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP2_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP2_DMA__R16_UH_RX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep2_dma(&self) -> R16_UEP2_DMA_R {
                R16_UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep2_dma(&mut self) -> R16_UEP2_DMA_W<0> {
                R16_UEP2_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep2_dma__r16_uh_rx_dma](index.html) module
        pub struct R16_UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep2_dma__r16_uh_rx_dma::R](R) reader structure
        impl crate::Readable for R16_UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep2_dma__r16_uh_rx_dma::W](W) writer structure
        impl crate::Writable for R16_UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for R16_UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: an alias for `Reg<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>`
    pub type R16_UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<r16_uep3_dma__r16_uh_tx_dma::R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod r16_uep3_dma__r16_uh_tx_dma {
        ///Register `R16_UEP3_DMA__R16_UH_TX_DMA` reader
        pub struct R(crate::R<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP3_DMA__R16_UH_TX_DMA` writer
        pub struct W(crate::W<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP3_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP3_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP3_DMA__R16_UH_TX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep3_dma(&self) -> R16_UEP3_DMA_R {
                R16_UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep3_dma(&mut self) -> R16_UEP3_DMA_W<0> {
                R16_UEP3_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep3_dma__r16_uh_tx_dma](index.html) module
        pub struct R16_UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep3_dma__r16_uh_tx_dma::R](R) reader structure
        impl crate::Readable for R16_UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep3_dma__r16_uh_tx_dma::W](W) writer structure
        impl crate::Writable for R16_UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for R16_UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP5_DMA (rw) register accessor: an alias for `Reg<R16_UEP5_DMA_SPEC>`
    pub type R16_UEP5_DMA = crate::Reg<r16_uep5_dma::R16_UEP5_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod r16_uep5_dma {
        ///Register `R16_UEP5_DMA` reader
        pub struct R(crate::R<R16_UEP5_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP5_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP5_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP5_DMA` writer
        pub struct W(crate::W<R16_UEP5_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP5_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP5_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP5_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP5_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP5_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep5_dma(&self) -> R16_UEP5_DMA_R {
                R16_UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep5_dma(&mut self) -> R16_UEP5_DMA_W<0> {
                R16_UEP5_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep5_dma](index.html) module
        pub struct R16_UEP5_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep5_dma::R](R) reader structure
        impl crate::Readable for R16_UEP5_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep5_dma::W](W) writer structure
        impl crate::Writable for R16_UEP5_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP5_DMA to value 0
        impl crate::Resettable for R16_UEP5_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP6_DMA (rw) register accessor: an alias for `Reg<R16_UEP6_DMA_SPEC>`
    pub type R16_UEP6_DMA = crate::Reg<r16_uep6_dma::R16_UEP6_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod r16_uep6_dma {
        ///Register `R16_UEP6_DMA` reader
        pub struct R(crate::R<R16_UEP6_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP6_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP6_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP6_DMA` writer
        pub struct W(crate::W<R16_UEP6_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP6_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP6_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP6_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP6_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP6_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep6_dma(&self) -> R16_UEP6_DMA_R {
                R16_UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep6_dma(&mut self) -> R16_UEP6_DMA_W<0> {
                R16_UEP6_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep6_dma](index.html) module
        pub struct R16_UEP6_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep6_dma::R](R) reader structure
        impl crate::Readable for R16_UEP6_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep6_dma::W](W) writer structure
        impl crate::Writable for R16_UEP6_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP6_DMA to value 0
        impl crate::Resettable for R16_UEP6_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_UEP7_DMA (rw) register accessor: an alias for `Reg<R16_UEP7_DMA_SPEC>`
    pub type R16_UEP7_DMA = crate::Reg<r16_uep7_dma::R16_UEP7_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod r16_uep7_dma {
        ///Register `R16_UEP7_DMA` reader
        pub struct R(crate::R<R16_UEP7_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_UEP7_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_UEP7_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_UEP7_DMA` writer
        pub struct W(crate::W<R16_UEP7_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_UEP7_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_UEP7_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP7_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP7_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_UEP7_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep7_dma(&self) -> R16_UEP7_DMA_R {
                R16_UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep7_dma(&mut self) -> R16_UEP7_DMA_W<0> {
                R16_UEP7_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_uep7_dma](index.html) module
        pub struct R16_UEP7_DMA_SPEC;
        impl crate::RegisterSpec for R16_UEP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_uep7_dma::R](R) reader structure
        impl crate::Readable for R16_UEP7_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_uep7_dma::W](W) writer structure
        impl crate::Writable for R16_UEP7_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_UEP7_DMA to value 0
        impl crate::Resettable for R16_UEP7_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP0_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP0_T_LEN_SPEC>`
    pub type R8_UEP0_T_LEN = crate::Reg<r8_uep0_t_len::R8_UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod r8_uep0_t_len {
        ///Register `R8_UEP0_T_LEN` reader
        pub struct R(crate::R<R8_UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP0_T_LEN` writer
        pub struct W(crate::W<R8_UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type R8_UEP0_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type R8_UEP0_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP0_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn r8_uep0_t_len(&self) -> R8_UEP0_T_LEN_R {
                R8_UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep0_t_len(&mut self) -> R8_UEP0_T_LEN_W<0> {
                R8_UEP0_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep0_t_len](index.html) module
        pub struct R8_UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep0_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep0_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP0_T_LEN to value 0
        impl crate::Resettable for R8_UEP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP0_CTRL (rw) register accessor: an alias for `Reg<R8_UEP0_CTRL_SPEC>`
    pub type R8_UEP0_CTRL = crate::Reg<r8_uep0_ctrl::R8_UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod r8_uep0_ctrl {
        ///Register `R8_UEP0_CTRL` reader
        pub struct R(crate::R<R8_UEP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP0_CTRL` writer
        pub struct W(crate::W<R8_UEP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP0_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP0_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP0_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep0_ctrl](index.html) module
        pub struct R8_UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep0_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep0_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP0_CTRL to value 0
        impl crate::Resettable for R8_UEP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP1_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP1_T_LEN_SPEC>`
    pub type R8_UEP1_T_LEN = crate::Reg<r8_uep1_t_len::R8_UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod r8_uep1_t_len {
        ///Register `R8_UEP1_T_LEN` reader
        pub struct R(crate::R<R8_UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP1_T_LEN` writer
        pub struct W(crate::W<R8_UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type R8_UEP1_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type R8_UEP1_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP1_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn r8_uep1_t_len(&self) -> R8_UEP1_T_LEN_R {
                R8_UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep1_t_len(&mut self) -> R8_UEP1_T_LEN_W<0> {
                R8_UEP1_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep1_t_len](index.html) module
        pub struct R8_UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep1_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep1_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP1_T_LEN to value 0
        impl crate::Resettable for R8_UEP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP1_CTRL__R8_UH_SETUP (rw) register accessor: an alias for `Reg<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>`
    pub type R8_UEP1_CTRL__R8_UH_SETUP =
        crate::Reg<r8_uep1_ctrl__r8_uh_setup::R8_UEP1_CTRL__R8_UH_SETUP_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod r8_uep1_ctrl__r8_uh_setup {
        ///Register `R8_UEP1_CTRL__R8_UH_SETUP` reader
        pub struct R(crate::R<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP1_CTRL__R8_UH_SETUP` writer
        pub struct W(crate::W<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type RB_UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type RB_UEP_T_TOG__RB_UH_SOF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn rb_uep_t_tog__rb_uh_sof_en(&self) -> RB_UEP_T_TOG__RB_UH_SOF_EN_R {
                RB_UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn rb_uep_r_tog__rb_uh_pre_pid_en(&self) -> RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog__rb_uh_sof_en(&mut self) -> RB_UEP_T_TOG__RB_UH_SOF_EN_W<6> {
                RB_UEP_T_TOG__RB_UH_SOF_EN_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W<7> {
                RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep1_ctrl__r8_uh_setup](index.html) module
        pub struct R8_UEP1_CTRL__R8_UH_SETUP_SPEC;
        impl crate::RegisterSpec for R8_UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep1_ctrl__r8_uh_setup::R](R) reader structure
        impl crate::Readable for R8_UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep1_ctrl__r8_uh_setup::W](W) writer structure
        impl crate::Writable for R8_UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP1_CTRL__R8_UH_SETUP to value 0
        impl crate::Resettable for R8_UEP1_CTRL__R8_UH_SETUP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP2_T_LEN_R8_UH_EP_PID (rw) register accessor: an alias for `Reg<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>`
    pub type R8_UEP2_T_LEN_R8_UH_EP_PID =
        crate::Reg<r8_uep2_t_len_r8_uh_ep_pid::R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod r8_uep2_t_len_r8_uh_ep_pid {
        ///Register `R8_UEP2_T_LEN_R8_UH_EP_PID` reader
        pub struct R(crate::R<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP2_T_LEN_R8_UH_EP_PID` writer
        pub struct W(crate::W<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        ///Field `R8_UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type R8_UEP2_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type R8_UEP2_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 8, O>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn r8_uep2_t_len(&self) -> R8_UEP2_T_LEN_R {
                R8_UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<0> {
                MASK_UH_ENDP_W::new(self)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn r8_uep2_t_len(&mut self) -> R8_UEP2_T_LEN_W<0> {
                R8_UEP2_T_LEN_W::new(self)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<4> {
                MASK_UH_TOKEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep2_t_len_r8_uh_ep_pid](index.html) module
        pub struct R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep2_t_len_r8_uh_ep_pid::R](R) reader structure
        impl crate::Readable for R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep2_t_len_r8_uh_ep_pid::W](W) writer structure
        impl crate::Writable for R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP2_T_LEN_R8_UH_EP_PID to value 0
        impl crate::Resettable for R8_UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP2_CTRL_R8_UH_RX_CTRL (rw) register accessor: an alias for `Reg<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>`
    pub type R8_UEP2_CTRL_R8_UH_RX_CTRL =
        crate::Reg<r8_uep2_ctrl_r8_uh_rx_ctrl::R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod r8_uep2_ctrl_r8_uh_rx_ctrl {
        ///Register `R8_UEP2_CTRL_R8_UH_RX_CTRL` reader
        pub struct R(crate::R<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP2_CTRL_R8_UH_RX_CTRL` writer
        pub struct W(crate::W<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader<bool>;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG__RB_UH_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog__rb_uh_r_auto_tog(&self) -> RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog__rb_uh_r_tog(&self) -> RB_UEP_R_TOG__RB_UH_R_TOG_R {
                RB_UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<2> {
                MASK_UH_R_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog__rb_uh_r_tog(&mut self) -> RB_UEP_R_TOG__RB_UH_R_TOG_W<7> {
                RB_UEP_R_TOG__RB_UH_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep2_ctrl_r8_uh_rx_ctrl](index.html) module
        pub struct R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep2_ctrl_r8_uh_rx_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep2_ctrl_r8_uh_rx_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP2_CTRL_R8_UH_RX_CTRL to value 0
        impl crate::Resettable for R8_UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP3_T_LEN__R8_UH_TX_LEN (rw) register accessor: an alias for `Reg<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>`
    pub type R8_UEP3_T_LEN__R8_UH_TX_LEN =
        crate::Reg<r8_uep3_t_len__r8_uh_tx_len::R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod r8_uep3_t_len__r8_uh_tx_len {
        ///Register `R8_UEP3_T_LEN__R8_UH_TX_LEN` reader
        pub struct R(crate::R<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP3_T_LEN__R8_UH_TX_LEN` writer
        pub struct W(crate::W<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type R8_UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type R8_UEP3_T_LEN__R8_UH_TX_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn r8_uep3_t_len__r8_uh_tx_len(&self) -> R8_UEP3_T_LEN__R8_UH_TX_LEN_R {
                R8_UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep3_t_len__r8_uh_tx_len(&mut self) -> R8_UEP3_T_LEN__R8_UH_TX_LEN_W<0> {
                R8_UEP3_T_LEN__R8_UH_TX_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep3_t_len__r8_uh_tx_len](index.html) module
        pub struct R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep3_t_len__r8_uh_tx_len::R](R) reader structure
        impl crate::Readable for R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep3_t_len__r8_uh_tx_len::W](W) writer structure
        impl crate::Writable for R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP3_T_LEN__R8_UH_TX_LEN to value 0
        impl crate::Resettable for R8_UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: an alias for `Reg<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>`
    pub type R8_UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<r8_uep3_ctrl__r8_uh_tx_ctrl::R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod r8_uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `R8_UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub struct R(crate::R<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub struct W(crate::W<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type RB_UH_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `RB_UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type RB_UH_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_RB_UH_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn rb_uh_t_res(&self) -> RB_UH_T_RES_R {
                RB_UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog_rb_uh_t_auto_tog(&self) -> RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog_rb_uh_t_tog(&self) -> RB_UEP_T_TOG_RB_UH_T_TOG_R {
                RB_UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uh_t_res(&mut self) -> RB_UH_T_RES_W<0> {
                RB_UH_T_RES_W::new(self)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog_rb_uh_t_auto_tog(
                &mut self,
            ) -> RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog_rb_uh_t_tog(&mut self) -> RB_UEP_T_TOG_RB_UH_T_TOG_W<6> {
                RB_UEP_T_TOG_RB_UH_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep3_ctrl__r8_uh_tx_ctrl](index.html) module
        pub struct R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep3_ctrl__r8_uh_tx_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep3_ctrl__r8_uh_tx_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for R8_UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP4_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP4_T_LEN_SPEC>`
    pub type R8_UEP4_T_LEN = crate::Reg<r8_uep4_t_len::R8_UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod r8_uep4_t_len {
        ///Register `R8_UEP4_T_LEN` reader
        pub struct R(crate::R<R8_UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP4_T_LEN` writer
        pub struct W(crate::W<R8_UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type R8_UEP4_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type R8_UEP4_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP4_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn r8_uep4_t_len(&self) -> R8_UEP4_T_LEN_R {
                R8_UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep4_t_len(&mut self) -> R8_UEP4_T_LEN_W<0> {
                R8_UEP4_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep4_t_len](index.html) module
        pub struct R8_UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep4_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep4_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP4_T_LEN to value 0
        impl crate::Resettable for R8_UEP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP4_CTRL (rw) register accessor: an alias for `Reg<R8_UEP4_CTRL_SPEC>`
    pub type R8_UEP4_CTRL = crate::Reg<r8_uep4_ctrl::R8_UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod r8_uep4_ctrl {
        ///Register `R8_UEP4_CTRL` reader
        pub struct R(crate::R<R8_UEP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP4_CTRL` writer
        pub struct W(crate::W<R8_UEP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP4_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep4_ctrl](index.html) module
        pub struct R8_UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep4_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep4_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP4_CTRL to value 0
        impl crate::Resettable for R8_UEP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP5_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP5_T_LEN_SPEC>`
    pub type R8_UEP5_T_LEN = crate::Reg<r8_uep5_t_len::R8_UEP5_T_LEN_SPEC>;
    ///endpoint 5 transmittal length
    pub mod r8_uep5_t_len {
        ///Register `R8_UEP5_T_LEN` reader
        pub struct R(crate::R<R8_UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP5_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP5_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP5_T_LEN` writer
        pub struct W(crate::W<R8_UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP5_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP5_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type R8_UEP5_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type R8_UEP5_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP5_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn r8_uep5_t_len(&self) -> R8_UEP5_T_LEN_R {
                R8_UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep5_t_len(&mut self) -> R8_UEP5_T_LEN_W<0> {
                R8_UEP5_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep5_t_len](index.html) module
        pub struct R8_UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep5_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP5_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep5_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP5_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP5_T_LEN to value 0
        impl crate::Resettable for R8_UEP5_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP5_CTRL (rw) register accessor: an alias for `Reg<R8_UEP5_CTRL_SPEC>`
    pub type R8_UEP5_CTRL = crate::Reg<r8_uep5_ctrl::R8_UEP5_CTRL_SPEC>;
    ///endpoint 5 control
    pub mod r8_uep5_ctrl {
        ///Register `R8_UEP5_CTRL` reader
        pub struct R(crate::R<R8_UEP5_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP5_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP5_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP5_CTRL` writer
        pub struct W(crate::W<R8_UEP5_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP5_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP5_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP5_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP5_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP5_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep5_ctrl](index.html) module
        pub struct R8_UEP5_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep5_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP5_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep5_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP5_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP5_CTRL to value 0
        impl crate::Resettable for R8_UEP5_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP6_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP6_T_LEN_SPEC>`
    pub type R8_UEP6_T_LEN = crate::Reg<r8_uep6_t_len::R8_UEP6_T_LEN_SPEC>;
    ///endpoint 6 transmittal length
    pub mod r8_uep6_t_len {
        ///Register `R8_UEP6_T_LEN` reader
        pub struct R(crate::R<R8_UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP6_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP6_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP6_T_LEN` writer
        pub struct W(crate::W<R8_UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP6_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP6_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type R8_UEP6_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type R8_UEP6_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP6_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn r8_uep6_t_len(&self) -> R8_UEP6_T_LEN_R {
                R8_UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep6_t_len(&mut self) -> R8_UEP6_T_LEN_W<0> {
                R8_UEP6_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep6_t_len](index.html) module
        pub struct R8_UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep6_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP6_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep6_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP6_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP6_T_LEN to value 0
        impl crate::Resettable for R8_UEP6_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP6_CTRL (rw) register accessor: an alias for `Reg<R8_UEP6_CTRL_SPEC>`
    pub type R8_UEP6_CTRL = crate::Reg<r8_uep6_ctrl::R8_UEP6_CTRL_SPEC>;
    ///endpoint 6 control
    pub mod r8_uep6_ctrl {
        ///Register `R8_UEP6_CTRL` reader
        pub struct R(crate::R<R8_UEP6_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP6_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP6_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP6_CTRL` writer
        pub struct W(crate::W<R8_UEP6_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP6_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP6_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP6_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP6_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP6_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep6_ctrl](index.html) module
        pub struct R8_UEP6_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep6_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP6_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep6_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP6_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP6_CTRL to value 0
        impl crate::Resettable for R8_UEP6_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP7_T_LEN (rw) register accessor: an alias for `Reg<R8_UEP7_T_LEN_SPEC>`
    pub type R8_UEP7_T_LEN = crate::Reg<r8_uep7_t_len::R8_UEP7_T_LEN_SPEC>;
    ///endpoint 7 transmittal length
    pub mod r8_uep7_t_len {
        ///Register `R8_UEP7_T_LEN` reader
        pub struct R(crate::R<R8_UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP7_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP7_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP7_T_LEN` writer
        pub struct W(crate::W<R8_UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP7_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP7_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type R8_UEP7_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type R8_UEP7_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP7_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn r8_uep7_t_len(&self) -> R8_UEP7_T_LEN_R {
                R8_UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep7_t_len(&mut self) -> R8_UEP7_T_LEN_W<0> {
                R8_UEP7_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep7_t_len](index.html) module
        pub struct R8_UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_UEP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep7_t_len::R](R) reader structure
        impl crate::Readable for R8_UEP7_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep7_t_len::W](W) writer structure
        impl crate::Writable for R8_UEP7_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP7_T_LEN to value 0
        impl crate::Resettable for R8_UEP7_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_UEP7_CTRL (rw) register accessor: an alias for `Reg<R8_UEP7_CTRL_SPEC>`
    pub type R8_UEP7_CTRL = crate::Reg<r8_uep7_ctrl::R8_UEP7_CTRL_SPEC>;
    ///endpoint 7 control
    pub mod r8_uep7_ctrl {
        ///Register `R8_UEP7_CTRL` reader
        pub struct R(crate::R<R8_UEP7_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_UEP7_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_UEP7_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_UEP7_CTRL` writer
        pub struct W(crate::W<R8_UEP7_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_UEP7_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_UEP7_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_UEP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP7_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP7_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_UEP7_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_uep7_ctrl](index.html) module
        pub struct R8_UEP7_CTRL_SPEC;
        impl crate::RegisterSpec for R8_UEP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_uep7_ctrl::R](R) reader structure
        impl crate::Readable for R8_UEP7_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_uep7_ctrl::W](W) writer structure
        impl crate::Writable for R8_UEP7_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_UEP7_CTRL to value 0
        impl crate::Resettable for R8_UEP7_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB2 register
pub struct USB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB2 {}
impl USB2 {
    ///Pointer to the register block
    pub const PTR: *const usb2::RegisterBlock = 0x4000_8400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB2 {
    type Target = usb2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB2").finish()
    }
}
///USB2 register
pub mod usb2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB2 base control
        pub r8_usb2_ctrl: R8_USB2_CTRL,
        ///0x01 - USB2 device physical prot control
        pub r8_u2dev_ctrl__r8_u2host_ctrl: R8_U2DEV_CTRL__R8_U2HOST_CTRL,
        ///0x02 - USB2 interrupt enable
        pub r8_usb2_int_en: R8_USB2_INT_EN,
        ///0x03 - USB2 device address
        pub r8_usb2_dev_ad: R8_USB2_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB2 miscellaneous status
        pub r8_usb2_mis_st: R8_USB2_MIS_ST,
        ///0x06 - USB2 interrupt flag
        pub r8_usb2_int_fg: R8_USB2_INT_FG,
        ///0x07 - USB2 interrupt status
        pub r8_usb2_int_st: R8_USB2_INT_ST,
        ///0x08 - USB2 receiving length
        pub r8_usb2_rx_len: R8_USB2_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 4/1 mode
        pub r8_u2ep4_1_mod: R8_U2EP4_1_MOD,
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        pub r8_u2ep2_3_mod__r8_u2h_ep_mod: R8_U2EP2_3_MOD__R8_U2H_EP_MOD,
        ///0x0e - USB2 endpoint 5/6/7 mode
        pub r8_u2ep567_mod: R8_U2EP567_MOD,
        _reserved11: [u8; 0x01],
        ///0x10 - endpoint 0 DMA buffer address
        pub r16_u2ep0_dma: R16_U2EP0_DMA,
        _reserved12: [u8; 0x02],
        ///0x14 - USB2 endpoint 1 DMA buffer address
        pub r16_u2ep1_dma: R16_U2EP1_DMA,
        _reserved13: [u8; 0x02],
        ///0x18 - USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub r16_u2ep2_dma__r16_u2h_rx_dma: R16_U2EP2_DMA__R16_U2H_RX_DMA,
        _reserved14: [u8; 0x02],
        ///0x1c - USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub r16_u2ep3_dma__r16_u2h_tx_dma: R16_U2EP3_DMA__R16_U2H_TX_DMA,
        _reserved15: [u8; 0x02],
        ///0x20 - USB2 endpoint 0 transmittal length
        pub r8_u2ep0_t_len: R8_U2EP0_T_LEN,
        _reserved16: [u8; 0x01],
        ///0x22 - USB2 endpoint 0 control
        pub r8_u2ep0_ctrl: R8_U2EP0_CTRL,
        _reserved17: [u8; 0x01],
        ///0x24 - USB2 endpoint 1 transmittal length
        pub r8_u2ep1_t_len: R8_U2EP1_T_LEN,
        _reserved18: [u8; 0x01],
        ///0x26 - USB2 endpoint 1 control;host aux setup
        pub r8_u2ep1_ctrl__r8_u2h_setup: R8_U2EP1_CTRL__R8_U2H_SETUP,
        _reserved19: [u8; 0x01],
        ///0x28 - USB2 endpoint 2 transmittal length;host endpoint and PID
        pub r8_u2ep2_t_len_r8_u2h_ep_pid: R8_U2EP2_T_LEN_R8_U2H_EP_PID,
        _reserved20: [u8; 0x01],
        ///0x2a - USB2 endpoint 2 control;host receiver endpoint control
        pub r8_u2ep2_ctrl_r8_u2h_rx_ctrl: R8_U2EP2_CTRL_R8_U2H_RX_CTRL,
        _reserved21: [u8; 0x01],
        ///0x2c - USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub r8_u2ep3_t_len__r8_u2h_tx_len: R8_U2EP3_T_LEN__R8_U2H_TX_LEN,
        _reserved22: [u8; 0x01],
        ///0x2e - USB2 endpoint 3 control;host transmittal endpoint control
        pub r8_u2ep3_ctrl__r8_u2h_tx_ctrl: R8_U2EP3_CTRL__R8_U2H_TX_CTRL,
        _reserved23: [u8; 0x01],
        ///0x30 - USB2 endpoint 4 transmittal length
        pub r8_u2ep4_t_len: R8_U2EP4_T_LEN,
        _reserved24: [u8; 0x01],
        ///0x32 - USB2 endpoint 4 control
        pub r8_u2ep4_ctrl: R8_U2EP4_CTRL,
        _reserved25: [u8; 0x21],
        ///0x54 - USB2 endpoint 5 DMA buffer address
        pub r16_u2ep5_dma: R16_U2EP5_DMA,
        _reserved26: [u8; 0x02],
        ///0x58 - USB2 endpoint 6 DMA buffer address
        pub r16_u2ep6_dma: R16_U2EP6_DMA,
        _reserved27: [u8; 0x02],
        ///0x5c - USB2 endpoint 7 DMA buffer address
        pub r16_u2ep7_dma: R16_U2EP7_DMA,
        _reserved28: [u8; 0x06],
        ///0x64 - USB2 endpoint 5 transmittal length
        pub r8_u2ep5_t_len: R8_U2EP5_T_LEN,
        _reserved29: [u8; 0x01],
        ///0x66 - USB2 endpoint 5 control
        pub r8_u2ep5_ctrl: R8_U2EP5_CTRL,
        _reserved30: [u8; 0x01],
        ///0x68 - USB2 endpoint 6 transmittal length
        pub r8_u2ep6_t_len: R8_U2EP6_T_LEN,
        _reserved31: [u8; 0x01],
        ///0x6a - USB2 endpoint 6 control
        pub r8_u2ep6_ctrl: R8_U2EP6_CTRL,
        _reserved32: [u8; 0x01],
        ///0x6c - USB2 endpoint 7 transmittal length
        pub r8_u2ep7_t_len: R8_U2EP7_T_LEN,
        _reserved33: [u8; 0x01],
        ///0x6e - USB2 endpoint 7 control
        pub r8_u2ep7_ctrl: R8_U2EP7_CTRL,
    }
    ///R8_USB2_CTRL (rw) register accessor: an alias for `Reg<R8_USB2_CTRL_SPEC>`
    pub type R8_USB2_CTRL = crate::Reg<r8_usb2_ctrl::R8_USB2_CTRL_SPEC>;
    ///USB2 base control
    pub mod r8_usb2_ctrl {
        ///Register `R8_USB2_CTRL` reader
        pub struct R(crate::R<R8_USB2_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB2_CTRL` writer
        pub struct W(crate::W<R8_USB2_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB2_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB2_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type RB_UC_DMA_EN_R = crate::BitReader<bool>;
        ///Field `RB_UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type RB_UC_DMA_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type RB_UC_CLR_ALL_R = crate::BitReader<bool>;
        ///Field `RB_UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type RB_UC_CLR_ALL_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type RB_UC_RESET_SIE_R = crate::BitReader<bool>;
        ///Field `RB_UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type RB_UC_RESET_SIE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type RB_UC_INT_BUSY_R = crate::BitReader<bool>;
        ///Field `RB_UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type RB_UC_INT_BUSY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_USB2_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type RB_UC_DEV_PU_EN_R = crate::BitReader<bool>;
        ///Field `RB_UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type RB_UC_DEV_PU_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type RB_UC_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `RB_UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type RB_UC_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        ///Field `RB_UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type RB_UC_HOST_MODE_R = crate::BitReader<bool>;
        ///Field `RB_UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type RB_UC_HOST_MODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn rb_uc_dma_en(&self) -> RB_UC_DMA_EN_R {
                RB_UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn rb_uc_clr_all(&self) -> RB_UC_CLR_ALL_R {
                RB_UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn rb_uc_reset_sie(&self) -> RB_UC_RESET_SIE_R {
                RB_UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn rb_uc_int_busy(&self) -> RB_UC_INT_BUSY_R {
                RB_UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn rb_uc_dev_pu_en(&self) -> RB_UC_DEV_PU_EN_R {
                RB_UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn rb_uc_low_speed(&self) -> RB_UC_LOW_SPEED_R {
                RB_UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn rb_uc_host_mode(&self) -> RB_UC_HOST_MODE_R {
                RB_UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_dma_en(&mut self) -> RB_UC_DMA_EN_W<0> {
                RB_UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_clr_all(&mut self) -> RB_UC_CLR_ALL_W<1> {
                RB_UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_reset_sie(&mut self) -> RB_UC_RESET_SIE_W<2> {
                RB_UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_int_busy(&mut self) -> RB_UC_INT_BUSY_W<3> {
                RB_UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_dev_pu_en(&mut self) -> RB_UC_DEV_PU_EN_W<5> {
                RB_UC_DEV_PU_EN_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_low_speed(&mut self) -> RB_UC_LOW_SPEED_W<6> {
                RB_UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uc_host_mode(&mut self) -> RB_UC_HOST_MODE_W<7> {
                RB_UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_ctrl](index.html) module
        pub struct R8_USB2_CTRL_SPEC;
        impl crate::RegisterSpec for R8_USB2_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_ctrl::R](R) reader structure
        impl crate::Readable for R8_USB2_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb2_ctrl::W](W) writer structure
        impl crate::Writable for R8_USB2_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB2_CTRL to value 0x06
        impl crate::Resettable for R8_USB2_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x06;
        }
    }
    ///R8_U2DEV_CTRL__R8_U2HOST_CTRL (rw) register accessor: an alias for `Reg<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>`
    pub type R8_U2DEV_CTRL__R8_U2HOST_CTRL =
        crate::Reg<r8_u2dev_ctrl__r8_u2host_ctrl::R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
    ///USB2 device physical prot control
    pub mod r8_u2dev_ctrl__r8_u2host_ctrl {
        ///Register `R8_U2DEV_CTRL__R8_U2HOST_CTRL` reader
        pub struct R(crate::R<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2DEV_CTRL__R8_U2HOST_CTRL` writer
        pub struct W(crate::W<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type RB_UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader<bool>;
        ///Field `RB_UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type RB_UD_PORT_EN__RB_UH_PORT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type RB_UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `RB_UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type RB_UD_GP_BIT__RB_UH_BUS_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `RB_UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `RB_UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type RB_UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader<bool>;
        ///Field `RB_UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type RB_UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader<bool>;
        ///Field `RB_UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type RB_UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn rb_ud_port_en__rb_uh_port_en(&self) -> RB_UD_PORT_EN__RB_UH_PORT_EN_R {
                RB_UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn rb_ud_gp_bit__rb_uh_bus_reset(&self) -> RB_UD_GP_BIT__RB_UH_BUS_RESET_R {
                RB_UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn rb_ud_low_speed__rb_uh_low_speed(&self) -> RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn rb_ud_dm_pin__rb_uh_dm_pin(&self) -> RB_UD_DM_PIN__RB_UH_DM_PIN_R {
                RB_UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn rb_ud_dp_pin__rb_uh_dp_pin(&self) -> RB_UD_DP_PIN__RB_UH_DP_PIN_R {
                RB_UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn rb_ud_pd_dis__rb_uh_pd_dis(&self) -> RB_UD_PD_DIS__RB_UH_PD_DIS_R {
                RB_UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_port_en__rb_uh_port_en(&mut self) -> RB_UD_PORT_EN__RB_UH_PORT_EN_W<0> {
                RB_UD_PORT_EN__RB_UH_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_gp_bit__rb_uh_bus_reset(&mut self) -> RB_UD_GP_BIT__RB_UH_BUS_RESET_W<1> {
                RB_UD_GP_BIT__RB_UH_BUS_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn rb_ud_low_speed__rb_uh_low_speed(
                &mut self,
            ) -> RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W<2> {
                RB_UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2dev_ctrl__r8_u2host_ctrl](index.html) module
        pub struct R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2dev_ctrl__r8_u2host_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2dev_ctrl__r8_u2host_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2DEV_CTRL__R8_U2HOST_CTRL to value 0
        impl crate::Resettable for R8_U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB2_INT_EN (rw) register accessor: an alias for `Reg<R8_USB2_INT_EN_SPEC>`
    pub type R8_USB2_INT_EN = crate::Reg<r8_usb2_int_en::R8_USB2_INT_EN_SPEC>;
    ///USB2 interrupt enable
    pub mod r8_usb2_int_en {
        ///Register `R8_USB2_INT_EN` reader
        pub struct R(crate::R<R8_USB2_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB2_INT_EN` writer
        pub struct W(crate::W<R8_USB2_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB2_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB2_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB2_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type RB_UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader<bool>;
        ///Field `RB_UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type RB_UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type RB_UIE_TRANSFER_R = crate::BitReader<bool>;
        ///Field `RB_UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type RB_UIE_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type RB_UIE_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type RB_UIE_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type RB_UIE_HST_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type RB_UIE_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type RB_UIE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type RB_UIE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type RB_UIE_DEV_NAK_R = crate::BitReader<bool>;
        ///Field `RB_UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type RB_UIE_DEV_NAK_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        ///Field `RB_UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type RB_UIE_DEV_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type RB_UIE_DEV_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn rb_uie_bus_rst__rb_uie_detect(&self) -> RB_UIE_BUS_RST__RB_UIE_DETECT_R {
                RB_UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn rb_uie_transfer(&self) -> RB_UIE_TRANSFER_R {
                RB_UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn rb_uie_suspend(&self) -> RB_UIE_SUSPEND_R {
                RB_UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn rb_uie_hst_sof(&self) -> RB_UIE_HST_SOF_R {
                RB_UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn rb_uie_fifo_ov(&self) -> RB_UIE_FIFO_OV_R {
                RB_UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn rb_uie_dev_nak(&self) -> RB_UIE_DEV_NAK_R {
                RB_UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn rb_uie_dev_sof(&self) -> RB_UIE_DEV_SOF_R {
                RB_UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_bus_rst__rb_uie_detect(&mut self) -> RB_UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                RB_UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_transfer(&mut self) -> RB_UIE_TRANSFER_W<1> {
                RB_UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_suspend(&mut self) -> RB_UIE_SUSPEND_W<2> {
                RB_UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_hst_sof(&mut self) -> RB_UIE_HST_SOF_W<3> {
                RB_UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_fifo_ov(&mut self) -> RB_UIE_FIFO_OV_W<4> {
                RB_UIE_FIFO_OV_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_dev_nak(&mut self) -> RB_UIE_DEV_NAK_W<6> {
                RB_UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn rb_uie_dev_sof(&mut self) -> RB_UIE_DEV_SOF_W<7> {
                RB_UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_int_en](index.html) module
        pub struct R8_USB2_INT_EN_SPEC;
        impl crate::RegisterSpec for R8_USB2_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_int_en::R](R) reader structure
        impl crate::Readable for R8_USB2_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb2_int_en::W](W) writer structure
        impl crate::Writable for R8_USB2_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB2_INT_EN to value 0
        impl crate::Resettable for R8_USB2_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB2_DEV_AD (rw) register accessor: an alias for `Reg<R8_USB2_DEV_AD_SPEC>`
    pub type R8_USB2_DEV_AD = crate::Reg<r8_usb2_dev_ad::R8_USB2_DEV_AD_SPEC>;
    ///USB2 device address
    pub mod r8_usb2_dev_ad {
        ///Register `R8_USB2_DEV_AD` reader
        pub struct R(crate::R<R8_USB2_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB2_DEV_AD` writer
        pub struct W(crate::W<R8_USB2_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB2_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB2_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB2_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_USB2_DEV_AD_SPEC, u8, u8, 7, O>;
        ///Field `RB_UDA_GP_BIT` reader - general purpose bit
        pub type RB_UDA_GP_BIT_R = crate::BitReader<bool>;
        ///Field `RB_UDA_GP_BIT` writer - general purpose bit
        pub type RB_UDA_GP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_DEV_AD_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn rb_uda_gp_bit(&self) -> RB_UDA_GP_BIT_R {
                RB_UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn rb_uda_gp_bit(&mut self) -> RB_UDA_GP_BIT_W<7> {
                RB_UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_dev_ad](index.html) module
        pub struct R8_USB2_DEV_AD_SPEC;
        impl crate::RegisterSpec for R8_USB2_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_dev_ad::R](R) reader structure
        impl crate::Readable for R8_USB2_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb2_dev_ad::W](W) writer structure
        impl crate::Writable for R8_USB2_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB2_DEV_AD to value 0
        impl crate::Resettable for R8_USB2_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB2_MIS_ST (r) register accessor: an alias for `Reg<R8_USB2_MIS_ST_SPEC>`
    pub type R8_USB2_MIS_ST = crate::Reg<r8_usb2_mis_st::R8_USB2_MIS_ST_SPEC>;
    ///USB2 miscellaneous status
    pub mod r8_usb2_mis_st {
        ///Register `R8_USB2_MIS_ST` reader
        pub struct R(crate::R<R8_USB2_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RB_UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type RB_UMS_DEV_ATTACH_R = crate::BitReader<bool>;
        ///Field `RB_UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type RB_UMS_DM_LEVEL_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type RB_UMS_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type RB_UMS_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `RB_UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type RB_UMS_R_FIFO_RDY_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type RB_UMS_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type RB_UMS_SOF_ACT_R = crate::BitReader<bool>;
        ///Field `RB_UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type RB_UMS_SOF_PRES_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn rb_ums_dev_attach(&self) -> RB_UMS_DEV_ATTACH_R {
                RB_UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn rb_ums_dm_level(&self) -> RB_UMS_DM_LEVEL_R {
                RB_UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn rb_ums_suspend(&self) -> RB_UMS_SUSPEND_R {
                RB_UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn rb_ums_bus_reset(&self) -> RB_UMS_BUS_RESET_R {
                RB_UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn rb_ums_r_fifo_rdy(&self) -> RB_UMS_R_FIFO_RDY_R {
                RB_UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn rb_ums_sie_free(&self) -> RB_UMS_SIE_FREE_R {
                RB_UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn rb_ums_sof_act(&self) -> RB_UMS_SOF_ACT_R {
                RB_UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn rb_ums_sof_pres(&self) -> RB_UMS_SOF_PRES_R {
                RB_UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_mis_st](index.html) module
        pub struct R8_USB2_MIS_ST_SPEC;
        impl crate::RegisterSpec for R8_USB2_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_mis_st::R](R) reader structure
        impl crate::Readable for R8_USB2_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB2_MIS_ST to value 0
        impl crate::Resettable for R8_USB2_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB2_INT_FG (rw) register accessor: an alias for `Reg<R8_USB2_INT_FG_SPEC>`
    pub type R8_USB2_INT_FG = crate::Reg<r8_usb2_int_fg::R8_USB2_INT_FG_SPEC>;
    ///USB2 interrupt flag
    pub mod r8_usb2_int_fg {
        ///Register `R8_USB2_INT_FG` reader
        pub struct R(crate::R<R8_USB2_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_USB2_INT_FG` writer
        pub struct W(crate::W<R8_USB2_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_USB2_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_USB2_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_USB2_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type RB_UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader<bool>;
        ///Field `RB_UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type RB_UIF_BUS_RST__RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_TRANSFER_R = crate::BitReader<bool>;
        ///Field `RB_UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_SUSPEND_R = crate::BitReader<bool>;
        ///Field `RB_UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type RB_UIF_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type RB_UIF_HST_SOF_R = crate::BitReader<bool>;
        ///Field `RB_UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type RB_UIF_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_FG_SPEC, bool, O>;
        ///Field `RB_UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type RB_UIF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `RB_UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type RB_UIF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_USB2_INT_FG_SPEC, bool, O>;
        ///Field `RB_U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type RB_U_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `RB_U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type RB_U_TOG_OK_R = crate::BitReader<bool>;
        ///Field `RB_U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type RB_U_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_bus_rst__rb_uif_detect(&self) -> RB_UIF_BUS_RST__RB_UIF_DETECT_R {
                RB_UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_transfer(&self) -> RB_UIF_TRANSFER_R {
                RB_UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_suspend(&self) -> RB_UIF_SUSPEND_R {
                RB_UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_hst_sof(&self) -> RB_UIF_HST_SOF_R {
                RB_UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn rb_uif_fifo_ov(&self) -> RB_UIF_FIFO_OV_R {
                RB_UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn rb_u_sie_free(&self) -> RB_U_SIE_FREE_R {
                RB_U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn rb_u_tog_ok(&self) -> RB_U_TOG_OK_R {
                RB_U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn rb_u_is_nak(&self) -> RB_U_IS_NAK_R {
                RB_U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_bus_rst__rb_uif_detect(&mut self) -> RB_UIF_BUS_RST__RB_UIF_DETECT_W<0> {
                RB_UIF_BUS_RST__RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_transfer(&mut self) -> RB_UIF_TRANSFER_W<1> {
                RB_UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_suspend(&mut self) -> RB_UIF_SUSPEND_W<2> {
                RB_UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_hst_sof(&mut self) -> RB_UIF_HST_SOF_W<3> {
                RB_UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn rb_uif_fifo_ov(&mut self) -> RB_UIF_FIFO_OV_W<4> {
                RB_UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_int_fg](index.html) module
        pub struct R8_USB2_INT_FG_SPEC;
        impl crate::RegisterSpec for R8_USB2_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_int_fg::R](R) reader structure
        impl crate::Readable for R8_USB2_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_usb2_int_fg::W](W) writer structure
        impl crate::Writable for R8_USB2_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_USB2_INT_FG to value 0x20
        impl crate::Resettable for R8_USB2_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///R8_USB2_INT_ST (r) register accessor: an alias for `Reg<R8_USB2_INT_ST_SPEC>`
    pub type R8_USB2_INT_ST = crate::Reg<r8_usb2_int_st::R8_USB2_INT_ST_SPEC>;
    ///USB2 interrupt status
    pub mod r8_usb2_int_st {
        ///Register `R8_USB2_INT_ST` reader
        pub struct R(crate::R<R8_USB2_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `RB_UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type RB_UIS_TOG_OK_R = crate::BitReader<bool>;
        ///Field `RB_UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type RB_UIS_SETUP_ACT_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn rb_uis_tog_ok(&self) -> RB_UIS_TOG_OK_R {
                RB_UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn rb_uis_setup_act(&self) -> RB_UIS_SETUP_ACT_R {
                RB_UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_int_st](index.html) module
        pub struct R8_USB2_INT_ST_SPEC;
        impl crate::RegisterSpec for R8_USB2_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_int_st::R](R) reader structure
        impl crate::Readable for R8_USB2_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB2_INT_ST to value 0
        impl crate::Resettable for R8_USB2_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_USB2_RX_LEN (r) register accessor: an alias for `Reg<R8_USB2_RX_LEN_SPEC>`
    pub type R8_USB2_RX_LEN = crate::Reg<r8_usb2_rx_len::R8_USB2_RX_LEN_SPEC>;
    ///USB2 receiving length
    pub mod r8_usb2_rx_len {
        ///Register `R8_USB2_RX_LEN` reader
        pub struct R(crate::R<R8_USB2_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_USB2_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_USB2_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_USB2_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `R8_USB_RX_LEN` reader - RO,USB receiving length
        pub type R8_USB_RX_LEN_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn r8_usb_rx_len(&self) -> R8_USB_RX_LEN_R {
                R8_USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB2 receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_usb2_rx_len](index.html) module
        pub struct R8_USB2_RX_LEN_SPEC;
        impl crate::RegisterSpec for R8_USB2_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_usb2_rx_len::R](R) reader structure
        impl crate::Readable for R8_USB2_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R8_USB2_RX_LEN to value 0
        impl crate::Resettable for R8_USB2_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP4_1_MOD (rw) register accessor: an alias for `Reg<R8_U2EP4_1_MOD_SPEC>`
    pub type R8_U2EP4_1_MOD = crate::Reg<r8_u2ep4_1_mod::R8_U2EP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod r8_u2ep4_1_mod {
        ///Register `R8_U2EP4_1_MOD` reader
        pub struct R(crate::R<R8_U2EP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP4_1_MOD` writer
        pub struct W(crate::W<R8_U2EP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type RB_UEP4_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type RB_UEP4_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type RB_UEP4_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type RB_UEP4_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type RB_UEP1_BUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type RB_UEP1_BUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type RB_UEP1_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type RB_UEP1_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `RB_UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type RB_UEP1_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type RB_UEP1_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_1_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep4_tx_en(&self) -> RB_UEP4_TX_EN_R {
                RB_UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep4_rx_en(&self) -> RB_UEP4_RX_EN_R {
                RB_UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn rb_uep1_buf_mod(&self) -> RB_UEP1_BUF_MOD_R {
                RB_UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep1_tx_en(&self) -> RB_UEP1_TX_EN_R {
                RB_UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep1_rx_en(&self) -> RB_UEP1_RX_EN_R {
                RB_UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep4_tx_en(&mut self) -> RB_UEP4_TX_EN_W<2> {
                RB_UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep4_rx_en(&mut self) -> RB_UEP4_RX_EN_W<3> {
                RB_UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_buf_mod(&mut self) -> RB_UEP1_BUF_MOD_W<4> {
                RB_UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_tx_en(&mut self) -> RB_UEP1_TX_EN_W<6> {
                RB_UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep1_rx_en(&mut self) -> RB_UEP1_RX_EN_W<7> {
                RB_UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep4_1_mod](index.html) module
        pub struct R8_U2EP4_1_MOD_SPEC;
        impl crate::RegisterSpec for R8_U2EP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep4_1_mod::R](R) reader structure
        impl crate::Readable for R8_U2EP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep4_1_mod::W](W) writer structure
        impl crate::Writable for R8_U2EP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP4_1_MOD to value 0
        impl crate::Resettable for R8_U2EP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP2_3_MOD__R8_U2H_EP_MOD (rw) register accessor: an alias for `Reg<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>`
    pub type R8_U2EP2_3_MOD__R8_U2H_EP_MOD =
        crate::Reg<r8_u2ep2_3_mod__r8_u2h_ep_mod::R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod r8_u2ep2_3_mod__r8_u2h_ep_mod {
        ///Register `R8_U2EP2_3_MOD__R8_U2H_EP_MOD` reader
        pub struct R(crate::R<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP2_3_MOD__R8_U2H_EP_MOD` writer
        pub struct W(crate::W<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type RB_UEP2_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type RB_UEP2_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `RB_UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type RB_UEP3_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type RB_UEP3_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn rb_uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &self,
            ) -> RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep2_tx_en(&self) -> RB_UEP2_TX_EN_R {
                RB_UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn rb_uep2_rx_en__rb_uh_ep_rx_en(&self) -> RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                RB_UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn rb_uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &self,
            ) -> RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn rb_uep3_tx_en__rb_uh_ep_tx_en(&self) -> RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                RB_UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep3_rx_en(&self) -> RB_UEP3_RX_EN_R {
                RB_UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<0> {
                RB_UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_tx_en(&mut self) -> RB_UEP2_TX_EN_W<2> {
                RB_UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn rb_uep2_rx_en__rb_uh_ep_rx_en(&mut self) -> RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W<3> {
                RB_UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<4> {
                RB_UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_tx_en__rb_uh_ep_tx_en(&mut self) -> RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W<6> {
                RB_UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep3_rx_en(&mut self) -> RB_UEP3_RX_EN_W<7> {
                RB_UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep2_3_mod__r8_u2h_ep_mod](index.html) module
        pub struct R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC;
        impl crate::RegisterSpec for R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep2_3_mod__r8_u2h_ep_mod::R](R) reader structure
        impl crate::Readable for R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep2_3_mod__r8_u2h_ep_mod::W](W) writer structure
        impl crate::Writable for R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP2_3_MOD__R8_U2H_EP_MOD to value 0
        impl crate::Resettable for R8_U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP567_MOD (rw) register accessor: an alias for `Reg<R8_U2EP567_MOD_SPEC>`
    pub type R8_U2EP567_MOD = crate::Reg<r8_u2ep567_mod::R8_U2EP567_MOD_SPEC>;
    ///USB2 endpoint 5/6/7 mode
    pub mod r8_u2ep567_mod {
        ///Register `R8_U2EP567_MOD` reader
        pub struct R(crate::R<R8_U2EP567_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP567_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP567_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP567_MOD` writer
        pub struct W(crate::W<R8_U2EP567_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP567_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP567_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type RB_UEP5_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type RB_UEP5_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type RB_UEP5_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type RB_UEP5_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type RB_UEP6_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type RB_UEP6_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type RB_UEP6_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type RB_UEP6_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type RB_UEP7_TX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type RB_UEP7_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        ///Field `RB_UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type RB_UEP7_RX_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type RB_UEP7_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP567_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep5_tx_en(&self) -> RB_UEP5_TX_EN_R {
                RB_UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep5_rx_en(&self) -> RB_UEP5_RX_EN_R {
                RB_UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep6_tx_en(&self) -> RB_UEP6_TX_EN_R {
                RB_UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep6_rx_en(&self) -> RB_UEP6_RX_EN_R {
                RB_UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn rb_uep7_tx_en(&self) -> RB_UEP7_TX_EN_R {
                RB_UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn rb_uep7_rx_en(&self) -> RB_UEP7_RX_EN_R {
                RB_UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep5_tx_en(&mut self) -> RB_UEP5_TX_EN_W<0> {
                RB_UEP5_TX_EN_W::new(self)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep5_rx_en(&mut self) -> RB_UEP5_RX_EN_W<1> {
                RB_UEP5_RX_EN_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep6_tx_en(&mut self) -> RB_UEP6_TX_EN_W<2> {
                RB_UEP6_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep6_rx_en(&mut self) -> RB_UEP6_RX_EN_W<3> {
                RB_UEP6_RX_EN_W::new(self)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep7_tx_en(&mut self) -> RB_UEP7_TX_EN_W<4> {
                RB_UEP7_TX_EN_W::new(self)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn rb_uep7_rx_en(&mut self) -> RB_UEP7_RX_EN_W<5> {
                RB_UEP7_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5/6/7 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep567_mod](index.html) module
        pub struct R8_U2EP567_MOD_SPEC;
        impl crate::RegisterSpec for R8_U2EP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep567_mod::R](R) reader structure
        impl crate::Readable for R8_U2EP567_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep567_mod::W](W) writer structure
        impl crate::Writable for R8_U2EP567_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP567_MOD to value 0
        impl crate::Resettable for R8_U2EP567_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP0_DMA (rw) register accessor: an alias for `Reg<R16_U2EP0_DMA_SPEC>`
    pub type R16_U2EP0_DMA = crate::Reg<r16_u2ep0_dma::R16_U2EP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod r16_u2ep0_dma {
        ///Register `R16_U2EP0_DMA` reader
        pub struct R(crate::R<R16_U2EP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP0_DMA` writer
        pub struct W(crate::W<R16_U2EP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type R16_UEP0_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type R16_UEP0_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP0_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn r16_uep0_dma(&self) -> R16_UEP0_DMA_R {
                R16_UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep0_dma(&mut self) -> R16_UEP0_DMA_W<0> {
                R16_UEP0_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep0_dma](index.html) module
        pub struct R16_U2EP0_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep0_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep0_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP0_DMA to value 0
        impl crate::Resettable for R16_U2EP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP1_DMA (rw) register accessor: an alias for `Reg<R16_U2EP1_DMA_SPEC>`
    pub type R16_U2EP1_DMA = crate::Reg<r16_u2ep1_dma::R16_U2EP1_DMA_SPEC>;
    ///USB2 endpoint 1 DMA buffer address
    pub mod r16_u2ep1_dma {
        ///Register `R16_U2EP1_DMA` reader
        pub struct R(crate::R<R16_U2EP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP1_DMA` writer
        pub struct W(crate::W<R16_U2EP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type R16_UEP1_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type R16_UEP1_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP1_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn r16_uep1_dma(&self) -> R16_UEP1_DMA_R {
                R16_UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep1_dma(&mut self) -> R16_UEP1_DMA_W<0> {
                R16_UEP1_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep1_dma](index.html) module
        pub struct R16_U2EP1_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep1_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep1_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP1_DMA to value 0
        impl crate::Resettable for R16_U2EP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP2_DMA__R16_U2H_RX_DMA (rw) register accessor: an alias for `Reg<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>`
    pub type R16_U2EP2_DMA__R16_U2H_RX_DMA =
        crate::Reg<r16_u2ep2_dma__r16_u2h_rx_dma::R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
    ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod r16_u2ep2_dma__r16_u2h_rx_dma {
        ///Register `R16_U2EP2_DMA__R16_U2H_RX_DMA` reader
        pub struct R(crate::R<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP2_DMA__R16_U2H_RX_DMA` writer
        pub struct W(crate::W<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP2_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP2_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep2_dma(&self) -> R16_UEP2_DMA_R {
                R16_UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep2_dma(&mut self) -> R16_UEP2_DMA_W<0> {
                R16_UEP2_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep2_dma__r16_u2h_rx_dma](index.html) module
        pub struct R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep2_dma__r16_u2h_rx_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep2_dma__r16_u2h_rx_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP2_DMA__R16_U2H_RX_DMA to value 0
        impl crate::Resettable for R16_U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP3_DMA__R16_U2H_TX_DMA (rw) register accessor: an alias for `Reg<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>`
    pub type R16_U2EP3_DMA__R16_U2H_TX_DMA =
        crate::Reg<r16_u2ep3_dma__r16_u2h_tx_dma::R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
    ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod r16_u2ep3_dma__r16_u2h_tx_dma {
        ///Register `R16_U2EP3_DMA__R16_U2H_TX_DMA` reader
        pub struct R(crate::R<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP3_DMA__R16_U2H_TX_DMA` writer
        pub struct W(crate::W<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP3_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP3_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep3_dma(&self) -> R16_UEP3_DMA_R {
                R16_UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep3_dma(&mut self) -> R16_UEP3_DMA_W<0> {
                R16_UEP3_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep3_dma__r16_u2h_tx_dma](index.html) module
        pub struct R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep3_dma__r16_u2h_tx_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep3_dma__r16_u2h_tx_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP3_DMA__R16_U2H_TX_DMA to value 0
        impl crate::Resettable for R16_U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP5_DMA (rw) register accessor: an alias for `Reg<R16_U2EP5_DMA_SPEC>`
    pub type R16_U2EP5_DMA = crate::Reg<r16_u2ep5_dma::R16_U2EP5_DMA_SPEC>;
    ///USB2 endpoint 5 DMA buffer address
    pub mod r16_u2ep5_dma {
        ///Register `R16_U2EP5_DMA` reader
        pub struct R(crate::R<R16_U2EP5_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP5_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP5_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP5_DMA` writer
        pub struct W(crate::W<R16_U2EP5_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP5_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP5_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP5_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP5_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP5_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep5_dma(&self) -> R16_UEP5_DMA_R {
                R16_UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep5_dma(&mut self) -> R16_UEP5_DMA_W<0> {
                R16_UEP5_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep5_dma](index.html) module
        pub struct R16_U2EP5_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep5_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP5_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep5_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP5_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP5_DMA to value 0
        impl crate::Resettable for R16_U2EP5_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP6_DMA (rw) register accessor: an alias for `Reg<R16_U2EP6_DMA_SPEC>`
    pub type R16_U2EP6_DMA = crate::Reg<r16_u2ep6_dma::R16_U2EP6_DMA_SPEC>;
    ///USB2 endpoint 6 DMA buffer address
    pub mod r16_u2ep6_dma {
        ///Register `R16_U2EP6_DMA` reader
        pub struct R(crate::R<R16_U2EP6_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP6_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP6_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP6_DMA` writer
        pub struct W(crate::W<R16_U2EP6_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP6_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP6_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP6_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP6_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP6_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep6_dma(&self) -> R16_UEP6_DMA_R {
                R16_UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep6_dma(&mut self) -> R16_UEP6_DMA_W<0> {
                R16_UEP6_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep6_dma](index.html) module
        pub struct R16_U2EP6_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep6_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP6_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep6_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP6_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP6_DMA to value 0
        impl crate::Resettable for R16_U2EP6_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R16_U2EP7_DMA (rw) register accessor: an alias for `Reg<R16_U2EP7_DMA_SPEC>`
    pub type R16_U2EP7_DMA = crate::Reg<r16_u2ep7_dma::R16_U2EP7_DMA_SPEC>;
    ///USB2 endpoint 7 DMA buffer address
    pub mod r16_u2ep7_dma {
        ///Register `R16_U2EP7_DMA` reader
        pub struct R(crate::R<R16_U2EP7_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R16_U2EP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R16_U2EP7_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R16_U2EP7_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R16_U2EP7_DMA` writer
        pub struct W(crate::W<R16_U2EP7_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R16_U2EP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R16_U2EP7_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R16_U2EP7_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R16_UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP7_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `R16_UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type R16_UEP7_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, R16_U2EP7_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn r16_uep7_dma(&self) -> R16_UEP7_DMA_R {
                R16_UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn r16_uep7_dma(&mut self) -> R16_UEP7_DMA_W<0> {
                R16_UEP7_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r16_u2ep7_dma](index.html) module
        pub struct R16_U2EP7_DMA_SPEC;
        impl crate::RegisterSpec for R16_U2EP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [r16_u2ep7_dma::R](R) reader structure
        impl crate::Readable for R16_U2EP7_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r16_u2ep7_dma::W](W) writer structure
        impl crate::Writable for R16_U2EP7_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R16_U2EP7_DMA to value 0
        impl crate::Resettable for R16_U2EP7_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP0_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP0_T_LEN_SPEC>`
    pub type R8_U2EP0_T_LEN = crate::Reg<r8_u2ep0_t_len::R8_U2EP0_T_LEN_SPEC>;
    ///USB2 endpoint 0 transmittal length
    pub mod r8_u2ep0_t_len {
        ///Register `R8_U2EP0_T_LEN` reader
        pub struct R(crate::R<R8_U2EP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP0_T_LEN` writer
        pub struct W(crate::W<R8_U2EP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type R8_UEP0_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type R8_UEP0_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP0_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn r8_uep0_t_len(&self) -> R8_UEP0_T_LEN_R {
                R8_UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep0_t_len(&mut self) -> R8_UEP0_T_LEN_W<0> {
                R8_UEP0_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep0_t_len](index.html) module
        pub struct R8_U2EP0_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep0_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep0_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP0_T_LEN to value 0
        impl crate::Resettable for R8_U2EP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP0_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP0_CTRL_SPEC>`
    pub type R8_U2EP0_CTRL = crate::Reg<r8_u2ep0_ctrl::R8_U2EP0_CTRL_SPEC>;
    ///USB2 endpoint 0 control
    pub mod r8_u2ep0_ctrl {
        ///Register `R8_U2EP0_CTRL` reader
        pub struct R(crate::R<R8_U2EP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP0_CTRL` writer
        pub struct W(crate::W<R8_U2EP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP0_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP0_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP0_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep0_ctrl](index.html) module
        pub struct R8_U2EP0_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep0_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep0_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP0_CTRL to value 0
        impl crate::Resettable for R8_U2EP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP1_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP1_T_LEN_SPEC>`
    pub type R8_U2EP1_T_LEN = crate::Reg<r8_u2ep1_t_len::R8_U2EP1_T_LEN_SPEC>;
    ///USB2 endpoint 1 transmittal length
    pub mod r8_u2ep1_t_len {
        ///Register `R8_U2EP1_T_LEN` reader
        pub struct R(crate::R<R8_U2EP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP1_T_LEN` writer
        pub struct W(crate::W<R8_U2EP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type R8_UEP1_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type R8_UEP1_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP1_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn r8_uep1_t_len(&self) -> R8_UEP1_T_LEN_R {
                R8_UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep1_t_len(&mut self) -> R8_UEP1_T_LEN_W<0> {
                R8_UEP1_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep1_t_len](index.html) module
        pub struct R8_U2EP1_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep1_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep1_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP1_T_LEN to value 0
        impl crate::Resettable for R8_U2EP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP1_CTRL__R8_U2H_SETUP (rw) register accessor: an alias for `Reg<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>`
    pub type R8_U2EP1_CTRL__R8_U2H_SETUP =
        crate::Reg<r8_u2ep1_ctrl__r8_u2h_setup::R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
    ///USB2 endpoint 1 control;host aux setup
    pub mod r8_u2ep1_ctrl__r8_u2h_setup {
        ///Register `R8_U2EP1_CTRL__R8_U2H_SETUP` reader
        pub struct R(crate::R<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP1_CTRL__R8_U2H_SETUP` writer
        pub struct W(crate::W<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type RB_UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type RB_UEP_T_TOG__RB_UH_SOF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn rb_uep_t_tog__rb_uh_sof_en(&self) -> RB_UEP_T_TOG__RB_UH_SOF_EN_R {
                RB_UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn rb_uep_r_tog__rb_uh_pre_pid_en(&self) -> RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                RB_UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog__rb_uh_sof_en(&mut self) -> RB_UEP_T_TOG__RB_UH_SOF_EN_W<6> {
                RB_UEP_T_TOG__RB_UH_SOF_EN_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W<7> {
                RB_UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep1_ctrl__r8_u2h_setup](index.html) module
        pub struct R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC;
        impl crate::RegisterSpec for R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep1_ctrl__r8_u2h_setup::R](R) reader structure
        impl crate::Readable for R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep1_ctrl__r8_u2h_setup::W](W) writer structure
        impl crate::Writable for R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP1_CTRL__R8_U2H_SETUP to value 0
        impl crate::Resettable for R8_U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP2_T_LEN_R8_U2H_EP_PID (rw) register accessor: an alias for `Reg<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>`
    pub type R8_U2EP2_T_LEN_R8_U2H_EP_PID =
        crate::Reg<r8_u2ep2_t_len_r8_u2h_ep_pid::R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
    ///USB2 endpoint 2 transmittal length;host endpoint and PID
    pub mod r8_u2ep2_t_len_r8_u2h_ep_pid {
        ///Register `R8_U2EP2_T_LEN_R8_U2H_EP_PID` reader
        pub struct R(crate::R<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP2_T_LEN_R8_U2H_EP_PID` writer
        pub struct W(crate::W<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 4, O>;
        ///Field `R8_UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type R8_UEP2_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type R8_UEP2_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 8, O>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn r8_uep2_t_len(&self) -> R8_UEP2_T_LEN_R {
                R8_UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<0> {
                MASK_UH_ENDP_W::new(self)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn r8_uep2_t_len(&mut self) -> R8_UEP2_T_LEN_W<0> {
                R8_UEP2_T_LEN_W::new(self)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<4> {
                MASK_UH_TOKEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep2_t_len_r8_u2h_ep_pid](index.html) module
        pub struct R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC;
        impl crate::RegisterSpec for R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep2_t_len_r8_u2h_ep_pid::R](R) reader structure
        impl crate::Readable for R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep2_t_len_r8_u2h_ep_pid::W](W) writer structure
        impl crate::Writable for R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP2_T_LEN_R8_U2H_EP_PID to value 0
        impl crate::Resettable for R8_U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP2_CTRL_R8_U2H_RX_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>`
    pub type R8_U2EP2_CTRL_R8_U2H_RX_CTRL =
        crate::Reg<r8_u2ep2_ctrl_r8_u2h_rx_ctrl::R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
    ///USB2 endpoint 2 control;host receiver endpoint control
    pub mod r8_u2ep2_ctrl_r8_u2h_rx_ctrl {
        ///Register `R8_U2EP2_CTRL_R8_U2H_RX_CTRL` reader
        pub struct R(crate::R<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP2_CTRL_R8_U2H_RX_CTRL` writer
        pub struct W(crate::W<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader<bool>;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG__RB_UH_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog__rb_uh_r_auto_tog(&self) -> RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog__rb_uh_r_tog(&self) -> RB_UEP_R_TOG__RB_UH_R_TOG_R {
                RB_UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<2> {
                MASK_UH_R_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog__rb_uh_r_tog(&mut self) -> RB_UEP_R_TOG__RB_UH_R_TOG_W<7> {
                RB_UEP_R_TOG__RB_UH_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep2_ctrl_r8_u2h_rx_ctrl](index.html) module
        pub struct R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep2_ctrl_r8_u2h_rx_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep2_ctrl_r8_u2h_rx_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP2_CTRL_R8_U2H_RX_CTRL to value 0
        impl crate::Resettable for R8_U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP3_T_LEN__R8_U2H_TX_LEN (rw) register accessor: an alias for `Reg<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>`
    pub type R8_U2EP3_T_LEN__R8_U2H_TX_LEN =
        crate::Reg<r8_u2ep3_t_len__r8_u2h_tx_len::R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
    ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod r8_u2ep3_t_len__r8_u2h_tx_len {
        ///Register `R8_U2EP3_T_LEN__R8_U2H_TX_LEN` reader
        pub struct R(crate::R<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP3_T_LEN__R8_U2H_TX_LEN` writer
        pub struct W(crate::W<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type R8_UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type R8_UEP3_T_LEN__R8_UH_TX_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn r8_uep3_t_len__r8_uh_tx_len(&self) -> R8_UEP3_T_LEN__R8_UH_TX_LEN_R {
                R8_UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep3_t_len__r8_uh_tx_len(&mut self) -> R8_UEP3_T_LEN__R8_UH_TX_LEN_W<0> {
                R8_UEP3_T_LEN__R8_UH_TX_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep3_t_len__r8_u2h_tx_len](index.html) module
        pub struct R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep3_t_len__r8_u2h_tx_len::R](R) reader structure
        impl crate::Readable for R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep3_t_len__r8_u2h_tx_len::W](W) writer structure
        impl crate::Writable for R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP3_T_LEN__R8_U2H_TX_LEN to value 0
        impl crate::Resettable for R8_U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP3_CTRL__R8_U2H_TX_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>`
    pub type R8_U2EP3_CTRL__R8_U2H_TX_CTRL =
        crate::Reg<r8_u2ep3_ctrl__r8_u2h_tx_ctrl::R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
    ///USB2 endpoint 3 control;host transmittal endpoint control
    pub mod r8_u2ep3_ctrl__r8_u2h_tx_ctrl {
        ///Register `R8_U2EP3_CTRL__R8_U2H_TX_CTRL` reader
        pub struct R(crate::R<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP3_CTRL__R8_U2H_TX_CTRL` writer
        pub struct W(crate::W<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RB_UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type RB_UH_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `RB_UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type RB_UH_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_RB_UH_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn rb_uh_t_res(&self) -> RB_UH_T_RES_R {
                RB_UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog_rb_uh_t_auto_tog(&self) -> RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog_rb_uh_t_tog(&self) -> RB_UEP_T_TOG_RB_UH_T_TOG_R {
                RB_UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn rb_uh_t_res(&mut self) -> RB_UH_T_RES_W<0> {
                RB_UH_T_RES_W::new(self)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog_rb_uh_t_auto_tog(
                &mut self,
            ) -> RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog_rb_uh_t_tog(&mut self) -> RB_UEP_T_TOG_RB_UH_T_TOG_W<6> {
                RB_UEP_T_TOG_RB_UH_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep3_ctrl__r8_u2h_tx_ctrl](index.html) module
        pub struct R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep3_ctrl__r8_u2h_tx_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep3_ctrl__r8_u2h_tx_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP3_CTRL__R8_U2H_TX_CTRL to value 0
        impl crate::Resettable for R8_U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP4_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP4_T_LEN_SPEC>`
    pub type R8_U2EP4_T_LEN = crate::Reg<r8_u2ep4_t_len::R8_U2EP4_T_LEN_SPEC>;
    ///USB2 endpoint 4 transmittal length
    pub mod r8_u2ep4_t_len {
        ///Register `R8_U2EP4_T_LEN` reader
        pub struct R(crate::R<R8_U2EP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP4_T_LEN` writer
        pub struct W(crate::W<R8_U2EP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type R8_UEP4_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type R8_UEP4_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP4_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn r8_uep4_t_len(&self) -> R8_UEP4_T_LEN_R {
                R8_UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep4_t_len(&mut self) -> R8_UEP4_T_LEN_W<0> {
                R8_UEP4_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep4_t_len](index.html) module
        pub struct R8_U2EP4_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep4_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep4_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP4_T_LEN to value 0
        impl crate::Resettable for R8_U2EP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP4_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP4_CTRL_SPEC>`
    pub type R8_U2EP4_CTRL = crate::Reg<r8_u2ep4_ctrl::R8_U2EP4_CTRL_SPEC>;
    ///USB2 endpoint 4 control
    pub mod r8_u2ep4_ctrl {
        ///Register `R8_U2EP4_CTRL` reader
        pub struct R(crate::R<R8_U2EP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP4_CTRL` writer
        pub struct W(crate::W<R8_U2EP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP4_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep4_ctrl](index.html) module
        pub struct R8_U2EP4_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep4_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep4_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP4_CTRL to value 0
        impl crate::Resettable for R8_U2EP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP5_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP5_T_LEN_SPEC>`
    pub type R8_U2EP5_T_LEN = crate::Reg<r8_u2ep5_t_len::R8_U2EP5_T_LEN_SPEC>;
    ///USB2 endpoint 5 transmittal length
    pub mod r8_u2ep5_t_len {
        ///Register `R8_U2EP5_T_LEN` reader
        pub struct R(crate::R<R8_U2EP5_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP5_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP5_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP5_T_LEN` writer
        pub struct W(crate::W<R8_U2EP5_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP5_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP5_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type R8_UEP5_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type R8_UEP5_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP5_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn r8_uep5_t_len(&self) -> R8_UEP5_T_LEN_R {
                R8_UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep5_t_len(&mut self) -> R8_UEP5_T_LEN_W<0> {
                R8_UEP5_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep5_t_len](index.html) module
        pub struct R8_U2EP5_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep5_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP5_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep5_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP5_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP5_T_LEN to value 0
        impl crate::Resettable for R8_U2EP5_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP5_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP5_CTRL_SPEC>`
    pub type R8_U2EP5_CTRL = crate::Reg<r8_u2ep5_ctrl::R8_U2EP5_CTRL_SPEC>;
    ///USB2 endpoint 5 control
    pub mod r8_u2ep5_ctrl {
        ///Register `R8_U2EP5_CTRL` reader
        pub struct R(crate::R<R8_U2EP5_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP5_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP5_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP5_CTRL` writer
        pub struct W(crate::W<R8_U2EP5_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP5_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP5_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP5_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP5_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP5_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep5_ctrl](index.html) module
        pub struct R8_U2EP5_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep5_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP5_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep5_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP5_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP5_CTRL to value 0
        impl crate::Resettable for R8_U2EP5_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP6_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP6_T_LEN_SPEC>`
    pub type R8_U2EP6_T_LEN = crate::Reg<r8_u2ep6_t_len::R8_U2EP6_T_LEN_SPEC>;
    ///USB2 endpoint 6 transmittal length
    pub mod r8_u2ep6_t_len {
        ///Register `R8_U2EP6_T_LEN` reader
        pub struct R(crate::R<R8_U2EP6_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP6_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP6_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP6_T_LEN` writer
        pub struct W(crate::W<R8_U2EP6_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP6_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP6_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type R8_UEP6_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type R8_UEP6_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP6_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn r8_uep6_t_len(&self) -> R8_UEP6_T_LEN_R {
                R8_UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep6_t_len(&mut self) -> R8_UEP6_T_LEN_W<0> {
                R8_UEP6_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep6_t_len](index.html) module
        pub struct R8_U2EP6_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep6_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP6_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep6_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP6_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP6_T_LEN to value 0
        impl crate::Resettable for R8_U2EP6_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP6_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP6_CTRL_SPEC>`
    pub type R8_U2EP6_CTRL = crate::Reg<r8_u2ep6_ctrl::R8_U2EP6_CTRL_SPEC>;
    ///USB2 endpoint 6 control
    pub mod r8_u2ep6_ctrl {
        ///Register `R8_U2EP6_CTRL` reader
        pub struct R(crate::R<R8_U2EP6_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP6_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP6_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP6_CTRL` writer
        pub struct W(crate::W<R8_U2EP6_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP6_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP6_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP6_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP6_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP6_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep6_ctrl](index.html) module
        pub struct R8_U2EP6_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep6_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP6_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep6_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP6_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP6_CTRL to value 0
        impl crate::Resettable for R8_U2EP6_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP7_T_LEN (rw) register accessor: an alias for `Reg<R8_U2EP7_T_LEN_SPEC>`
    pub type R8_U2EP7_T_LEN = crate::Reg<r8_u2ep7_t_len::R8_U2EP7_T_LEN_SPEC>;
    ///USB2 endpoint 7 transmittal length
    pub mod r8_u2ep7_t_len {
        ///Register `R8_U2EP7_T_LEN` reader
        pub struct R(crate::R<R8_U2EP7_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP7_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP7_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP7_T_LEN` writer
        pub struct W(crate::W<R8_U2EP7_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP7_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP7_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `R8_UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type R8_UEP7_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `R8_UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type R8_UEP7_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP7_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn r8_uep7_t_len(&self) -> R8_UEP7_T_LEN_R {
                R8_UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn r8_uep7_t_len(&mut self) -> R8_UEP7_T_LEN_W<0> {
                R8_UEP7_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep7_t_len](index.html) module
        pub struct R8_U2EP7_T_LEN_SPEC;
        impl crate::RegisterSpec for R8_U2EP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep7_t_len::R](R) reader structure
        impl crate::Readable for R8_U2EP7_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep7_t_len::W](W) writer structure
        impl crate::Writable for R8_U2EP7_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP7_T_LEN to value 0
        impl crate::Resettable for R8_U2EP7_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R8_U2EP7_CTRL (rw) register accessor: an alias for `Reg<R8_U2EP7_CTRL_SPEC>`
    pub type R8_U2EP7_CTRL = crate::Reg<r8_u2ep7_ctrl::R8_U2EP7_CTRL_SPEC>;
    ///USB2 endpoint 7 control
    pub mod r8_u2ep7_ctrl {
        ///Register `R8_U2EP7_CTRL` reader
        pub struct R(crate::R<R8_U2EP7_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R8_U2EP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R8_U2EP7_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R8_U2EP7_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R8_U2EP7_CTRL` writer
        pub struct W(crate::W<R8_U2EP7_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R8_U2EP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R8_U2EP7_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R8_U2EP7_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, R8_U2EP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `RB_UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type RB_UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP7_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type RB_UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP7_CTRL_SPEC, bool, O>;
        ///Field `RB_UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `RB_UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type RB_UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, R8_U2EP7_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn rb_uep_auto_tog(&self) -> RB_UEP_AUTO_TOG_R {
                RB_UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_t_tog(&self) -> RB_UEP_T_TOG_R {
                RB_UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn rb_uep_r_tog(&self) -> RB_UEP_R_TOG_R {
                RB_UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_auto_tog(&mut self) -> RB_UEP_AUTO_TOG_W<4> {
                RB_UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_t_tog(&mut self) -> RB_UEP_T_TOG_W<6> {
                RB_UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn rb_uep_r_tog(&mut self) -> RB_UEP_R_TOG_W<7> {
                RB_UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r8_u2ep7_ctrl](index.html) module
        pub struct R8_U2EP7_CTRL_SPEC;
        impl crate::RegisterSpec for R8_U2EP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [r8_u2ep7_ctrl::R](R) reader structure
        impl crate::Readable for R8_U2EP7_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r8_u2ep7_ctrl::W](W) writer structure
        impl crate::Writable for R8_U2EP7_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R8_U2EP7_CTRL to value 0
        impl crate::Resettable for R8_U2EP7_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RO,Interrupt Status Register 1
        pub r32_pfic_isr1: R32_PFIC_ISR1,
        ///0x04 - RO,Interrupt Status Register 2
        pub r32_pfic_isr2: R32_PFIC_ISR2,
        _reserved2: [u8; 0x18],
        ///0x20 - RO,Interrupt Pending Register 1
        pub r32_pfic_ipr1: R32_PFIC_IPR1,
        ///0x24 - RO,Interrupt Pending Register 2
        pub r32_pfic_ipr2: R32_PFIC_IPR2,
        _reserved4: [u8; 0x18],
        ///0x40 - RW,Interrupt Priority Register
        pub r32_pfic_ithresdr: R32_PFIC_ITHRESDR,
        _reserved5: [u8; 0x04],
        ///0x48 - Interrupt Config Register
        pub r32_pfic_cfgr: R32_PFIC_CFGR,
        ///0x4c - Interrupt Global Register
        pub r32_pfic_gisr: R32_PFIC_GISR,
        ///0x50 - RW,Interrupt Fast ID Config Register
        pub r32_pfic_idcfgr: R32_PFIC_IDCFGR,
        _reserved8: [u8; 0x0c],
        ///0x60 - Interrupt 0 address Register
        pub r32_pfic_fiaddrr0: R32_PFIC_FIADDRR0,
        ///0x64 - Interrupt 1 address Register
        pub r32_pfic_fiaddrr1: R32_PFIC_FIADDRR1,
        ///0x68 - Interrupt 2 address Register
        pub r32_pfic_fiaddrr2: R32_PFIC_FIADDRR2,
        ///0x6c - Interrupt 3 address Register
        pub r32_pfic_fiaddrr3: R32_PFIC_FIADDRR3,
        _reserved12: [u8; 0x90],
        ///0x100 - Interrupt Setting Register
        pub r32_pfic_ienr1: R32_PFIC_IENR1,
        ///0x104 - Interrupt Setting Register
        pub r32_pfic_ienr2: R32_PFIC_IENR2,
        _reserved14: [u8; 0x78],
        ///0x180 - Interrupt Clear Register
        pub r32_pfic_irer1: R32_PFIC_IRER1,
        ///0x184 - Interrupt Clear Register
        pub r32_pfic_irer2: R32_PFIC_IRER2,
        _reserved16: [u8; 0x78],
        ///0x200 - Interrupt Pending Register
        pub r32_pfic_ipsr1: R32_PFIC_IPSR1,
        ///0x204 - Interrupt Pending Register
        pub r32_pfic_ipsr2: R32_PFIC_IPSR2,
        _reserved18: [u8; 0x78],
        ///0x280 - Interrupt Pending Clear Register
        pub r32_pfic_iprr1: R32_PFIC_IPRR1,
        ///0x284 - Interrupt Pending Clear Register
        pub r32_pfic_iprr2: R32_PFIC_IPRR2,
        _reserved20: [u8; 0x78],
        ///0x300 - Interrupt ACTIVE Register
        pub r32_pfic_iactr1: R32_PFIC_IACTR1,
        ///0x304 - Interrupt ACTIVE Register
        pub r32_pfic_iactr2: R32_PFIC_IACTR2,
        _reserved22: [u8; 0xf8],
        ///0x400 - Interrupt Priority configuration Register 0
        pub r32_pfic_iprior0: R32_PFIC_IPRIOR0,
        _reserved23: [u8; 0x1c],
        ///0x420 - Interrupt Priority configuration Register 1
        pub r32_pfic_iprior1: R32_PFIC_IPRIOR1,
        _reserved24: [u8; 0x1c],
        ///0x440 - Interrupt Priority configuration Register 2
        pub r32_pfic_iprior2: R32_PFIC_IPRIOR2,
        _reserved25: [u8; 0x1c],
        ///0x460 - Interrupt Priority configuration Register 3
        pub r32_pfic_iprior3: R32_PFIC_IPRIOR3,
        _reserved26: [u8; 0x1c],
        ///0x480 - Interrupt Priority configuration Register 4
        pub r32_pfic_iprior4: R32_PFIC_IPRIOR4,
        _reserved27: [u8; 0x1c],
        ///0x4a0 - Interrupt Priority configuration Register 5
        pub r32_pfic_iprior5: R32_PFIC_IPRIOR5,
        _reserved28: [u8; 0x1c],
        ///0x4c0 - Interrupt Priority configuration Register 6
        pub r32_pfic_iprior6: R32_PFIC_IPRIOR6,
        _reserved29: [u8; 0x1c],
        ///0x4e0 - Interrupt Priority configuration Register 7
        pub r32_pfic_iprior7: R32_PFIC_IPRIOR7,
        _reserved30: [u8; 0x1c],
        ///0x500 - Interrupt Priority configuration Register 8
        pub r32_pfic_iprior8: R32_PFIC_IPRIOR8,
        _reserved31: [u8; 0x1c],
        ///0x520 - Interrupt Priority configuration Register 9
        pub r32_pfic_iprior9: R32_PFIC_IPRIOR9,
        _reserved32: [u8; 0x1c],
        ///0x540 - Interrupt Priority configuration Register 10
        pub r32_pfic_iprior10: R32_PFIC_IPRIOR10,
        _reserved33: [u8; 0x1c],
        ///0x560 - Interrupt Priority configuration Register 11
        pub r32_pfic_iprior11: R32_PFIC_IPRIOR11,
        _reserved34: [u8; 0x1c],
        ///0x580 - Interrupt Priority configuration Register 12
        pub r32_pfic_iprior12: R32_PFIC_IPRIOR12,
        _reserved35: [u8; 0x1c],
        ///0x5a0 - Interrupt Priority configuration Register 13
        pub r32_pfic_iprior13: R32_PFIC_IPRIOR13,
        _reserved36: [u8; 0x1c],
        ///0x5c0 - Interrupt Priority configuration Register 14
        pub r32_pfic_iprior14: R32_PFIC_IPRIOR14,
        _reserved37: [u8; 0x1c],
        ///0x5e0 - Interrupt Priority configuration Register 15
        pub r32_pfic_iprior15: R32_PFIC_IPRIOR15,
        _reserved38: [u8; 0x1c],
        ///0x600 - Interrupt Priority configuration Register 16
        pub r32_pfic_iprior16: R32_PFIC_IPRIOR16,
        _reserved39: [u8; 0x1c],
        ///0x620 - Interrupt Priority configuration Register 17
        pub r32_pfic_iprior17: R32_PFIC_IPRIOR17,
        _reserved40: [u8; 0x1c],
        ///0x640 - Interrupt Priority configuration Register 18
        pub r32_pfic_iprior18: R32_PFIC_IPRIOR18,
        _reserved41: [u8; 0x1c],
        ///0x660 - Interrupt Priority configuration Register 19
        pub r32_pfic_iprior19: R32_PFIC_IPRIOR19,
        _reserved42: [u8; 0x1c],
        ///0x680 - Interrupt Priority configuration Register 20
        pub r32_pfic_iprior20: R32_PFIC_IPRIOR20,
        _reserved43: [u8; 0x1c],
        ///0x6a0 - Interrupt Priority configuration Register 21
        pub r32_pfic_iprior21: R32_PFIC_IPRIOR21,
        _reserved44: [u8; 0x1c],
        ///0x6c0 - Interrupt Priority configuration Register 22
        pub r32_pfic_iprior22: R32_PFIC_IPRIOR22,
        _reserved45: [u8; 0x1c],
        ///0x6e0 - Interrupt Priority configuration Register 23
        pub r32_pfic_iprior23: R32_PFIC_IPRIOR23,
        _reserved46: [u8; 0x1c],
        ///0x700 - Interrupt Priority configuration Register 24
        pub r32_pfic_iprior24: R32_PFIC_IPRIOR24,
        _reserved47: [u8; 0x1c],
        ///0x720 - Interrupt Priority configuration Register 25
        pub r32_pfic_iprior25: R32_PFIC_IPRIOR25,
        _reserved48: [u8; 0x1c],
        ///0x740 - Interrupt Priority configuration Register 26
        pub r32_pfic_iprior26: R32_PFIC_IPRIOR26,
        _reserved49: [u8; 0x1c],
        ///0x760 - Interrupt Priority configuration Register 27
        pub r32_pfic_iprior27: R32_PFIC_IPRIOR27,
        _reserved50: [u8; 0x1c],
        ///0x780 - Interrupt Priority configuration Register 28
        pub r32_pfic_iprior28: R32_PFIC_IPRIOR28,
        _reserved51: [u8; 0x1c],
        ///0x7a0 - Interrupt Priority configuration Register 29
        pub r32_pfic_iprior29: R32_PFIC_IPRIOR29,
        _reserved52: [u8; 0x1c],
        ///0x7c0 - Interrupt Priority configuration Register 30
        pub r32_pfic_iprior30: R32_PFIC_IPRIOR30,
        _reserved53: [u8; 0x1c],
        ///0x7e0 - Interrupt Priority configuration Register 31
        pub r32_pfic_iprior31: R32_PFIC_IPRIOR31,
        _reserved54: [u8; 0x1c],
        ///0x800 - Interrupt Priority configuration Register 32
        pub r32_pfic_iprior32: R32_PFIC_IPRIOR32,
        _reserved55: [u8; 0x1c],
        ///0x820 - Interrupt Priority configuration Register 33
        pub r32_pfic_iprior33: R32_PFIC_IPRIOR33,
        _reserved56: [u8; 0x1c],
        ///0x840 - Interrupt Priority configuration Register 34
        pub r32_pfic_iprior34: R32_PFIC_IPRIOR34,
        _reserved57: [u8; 0x1c],
        ///0x860 - Interrupt Priority configuration Register 35
        pub r32_pfic_iprior35: R32_PFIC_IPRIOR35,
        _reserved58: [u8; 0x1c],
        ///0x880 - Interrupt Priority configuration Register 36
        pub r32_pfic_iprior36: R32_PFIC_IPRIOR36,
        _reserved59: [u8; 0x1c],
        ///0x8a0 - Interrupt Priority configuration Register 37
        pub r32_pfic_iprior37: R32_PFIC_IPRIOR37,
        _reserved60: [u8; 0x1c],
        ///0x8c0 - Interrupt Priority configuration Register 38
        pub r32_pfic_iprior38: R32_PFIC_IPRIOR38,
        _reserved61: [u8; 0x1c],
        ///0x8e0 - Interrupt Priority configuration Register 39
        pub r32_pfic_iprior39: R32_PFIC_IPRIOR39,
        _reserved62: [u8; 0x1c],
        ///0x900 - Interrupt Priority configuration Register 40
        pub r32_pfic_iprior40: R32_PFIC_IPRIOR40,
        _reserved63: [u8; 0x1c],
        ///0x920 - Interrupt Priority configuration Register 41
        pub r32_pfic_iprior41: R32_PFIC_IPRIOR41,
        _reserved64: [u8; 0x1c],
        ///0x940 - Interrupt Priority configuration Register 42
        pub r32_pfic_iprior42: R32_PFIC_IPRIOR42,
        _reserved65: [u8; 0x1c],
        ///0x960 - Interrupt Priority configuration Register 43
        pub r32_pfic_iprior43: R32_PFIC_IPRIOR43,
        _reserved66: [u8; 0x1c],
        ///0x980 - Interrupt Priority configuration Register 44
        pub r32_pfic_iprior44: R32_PFIC_IPRIOR44,
        _reserved67: [u8; 0x1c],
        ///0x9a0 - Interrupt Priority configuration Register 45
        pub r32_pfic_iprior45: R32_PFIC_IPRIOR45,
        _reserved68: [u8; 0x1c],
        ///0x9c0 - Interrupt Priority configuration Register 46
        pub r32_pfic_iprior46: R32_PFIC_IPRIOR46,
        _reserved69: [u8; 0x1c],
        ///0x9e0 - Interrupt Priority configuration Register 47
        pub r32_pfic_iprior47: R32_PFIC_IPRIOR47,
        _reserved70: [u8; 0x1c],
        ///0xa00 - Interrupt Priority configuration Register 48
        pub r32_pfic_iprior48: R32_PFIC_IPRIOR48,
        _reserved71: [u8; 0x1c],
        ///0xa20 - Interrupt Priority configuration Register 49
        pub r32_pfic_iprior49: R32_PFIC_IPRIOR49,
        _reserved72: [u8; 0x1c],
        ///0xa40 - Interrupt Priority configuration Register 50
        pub r32_pfic_iprior50: R32_PFIC_IPRIOR50,
        _reserved73: [u8; 0x1c],
        ///0xa60 - Interrupt Priority configuration Register 51
        pub r32_pfic_iprior51: R32_PFIC_IPRIOR51,
        _reserved74: [u8; 0x1c],
        ///0xa80 - Interrupt Priority configuration Register 52
        pub r32_pfic_iprior52: R32_PFIC_IPRIOR52,
        _reserved75: [u8; 0x1c],
        ///0xaa0 - Interrupt Priority configuration Register 53
        pub r32_pfic_iprior53: R32_PFIC_IPRIOR53,
        _reserved76: [u8; 0x2c],
        ///0xad0 - Interrupt Priority configuration Register 54
        pub r32_pfic_iprior54: R32_PFIC_IPRIOR54,
        _reserved77: [u8; 0x0c],
        ///0xae0 - Interrupt Priority configuration Register 55
        pub r32_pfic_iprior55: R32_PFIC_IPRIOR55,
        _reserved78: [u8; 0x1c],
        ///0xb00 - Interrupt Priority configuration Register 56
        pub r32_pfic_iprior56: R32_PFIC_IPRIOR56,
        _reserved79: [u8; 0x1c],
        ///0xb20 - Interrupt Priority configuration Register 57
        pub r32_pfic_iprior57: R32_PFIC_IPRIOR57,
        _reserved80: [u8; 0x1c],
        ///0xb40 - Interrupt Priority configuration Register 58
        pub r32_pfic_iprior58: R32_PFIC_IPRIOR58,
        _reserved81: [u8; 0x1c],
        ///0xb60 - Interrupt Priority configuration Register 59
        pub r32_pfic_iprior59: R32_PFIC_IPRIOR59,
        _reserved82: [u8; 0x1c],
        ///0xb80 - Interrupt Priority configuration Register 60
        pub r32_pfic_iprior60: R32_PFIC_IPRIOR60,
        _reserved83: [u8; 0x1c],
        ///0xba0 - Interrupt Priority configuration Register 61
        pub r32_pfic_iprior61: R32_PFIC_IPRIOR61,
        _reserved84: [u8; 0x3c],
        ///0xbe0 - Interrupt Priority configuration Register 62
        pub r32_pfic_iprior62: R32_PFIC_IPRIOR62,
        _reserved85: [u8; 0x1c],
        ///0xc00 - Interrupt Priority configuration Register 63
        pub r32_pfic_iprior63: R32_PFIC_IPRIOR63,
        _reserved86: [u8; 0x010c],
        ///0xd10 - System Control Register
        pub r32_pfic_sctlr: R32_PFIC_SCTLR,
    }
    ///R32_PFIC_ISR1 (r) register accessor: an alias for `Reg<R32_PFIC_ISR1_SPEC>`
    pub type R32_PFIC_ISR1 = crate::Reg<r32_pfic_isr1::R32_PFIC_ISR1_SPEC>;
    ///RO,Interrupt Status Register 1
    pub mod r32_pfic_isr1 {
        ///Register `R32_PFIC_ISR1` reader
        pub struct R(crate::R<R32_PFIC_ISR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_ISR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_ISR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_ISR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Status Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_isr1](index.html) module
        pub struct R32_PFIC_ISR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_isr1::R](R) reader structure
        impl crate::Readable for R32_PFIC_ISR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PFIC_ISR1 to value 0
        impl crate::Resettable for R32_PFIC_ISR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_ISR2 (r) register accessor: an alias for `Reg<R32_PFIC_ISR2_SPEC>`
    pub type R32_PFIC_ISR2 = crate::Reg<r32_pfic_isr2::R32_PFIC_ISR2_SPEC>;
    ///RO,Interrupt Status Register 2
    pub mod r32_pfic_isr2 {
        ///Register `R32_PFIC_ISR2` reader
        pub struct R(crate::R<R32_PFIC_ISR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_ISR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_ISR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_ISR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Status Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_isr2](index.html) module
        pub struct R32_PFIC_ISR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_isr2::R](R) reader structure
        impl crate::Readable for R32_PFIC_ISR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PFIC_ISR2 to value 0
        impl crate::Resettable for R32_PFIC_ISR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPR1 (r) register accessor: an alias for `Reg<R32_PFIC_IPR1_SPEC>`
    pub type R32_PFIC_IPR1 = crate::Reg<r32_pfic_ipr1::R32_PFIC_IPR1_SPEC>;
    ///RO,Interrupt Pending Register 1
    pub mod r32_pfic_ipr1 {
        ///Register `R32_PFIC_IPR1` reader
        pub struct R(crate::R<R32_PFIC_IPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Pending Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ipr1](index.html) module
        pub struct R32_PFIC_IPR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_ipr1::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PFIC_IPR1 to value 0
        impl crate::Resettable for R32_PFIC_IPR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPR2 (r) register accessor: an alias for `Reg<R32_PFIC_IPR2_SPEC>`
    pub type R32_PFIC_IPR2 = crate::Reg<r32_pfic_ipr2::R32_PFIC_IPR2_SPEC>;
    ///RO,Interrupt Pending Register 2
    pub mod r32_pfic_ipr2 {
        ///Register `R32_PFIC_IPR2` reader
        pub struct R(crate::R<R32_PFIC_IPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Pending Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ipr2](index.html) module
        pub struct R32_PFIC_IPR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_ipr2::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PFIC_IPR2 to value 0
        impl crate::Resettable for R32_PFIC_IPR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_ITHRESDR (rw) register accessor: an alias for `Reg<R32_PFIC_ITHRESDR_SPEC>`
    pub type R32_PFIC_ITHRESDR = crate::Reg<r32_pfic_ithresdr::R32_PFIC_ITHRESDR_SPEC>;
    ///RW,Interrupt Priority Register
    pub mod r32_pfic_ithresdr {
        ///Register `R32_PFIC_ITHRESDR` reader
        pub struct R(crate::R<R32_PFIC_ITHRESDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_ITHRESDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_ITHRESDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_ITHRESDR` writer
        pub struct W(crate::W<R32_PFIC_ITHRESDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_ITHRESDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_ITHRESDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THRESHOLD` reader - RW,THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader<u8, u8>;
        ///Field `THRESHOLD` writer - RW,THRESHOLD
        pub type THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_ITHRESDR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<0> {
                THRESHOLD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ithresdr](index.html) module
        pub struct R32_PFIC_ITHRESDR_SPEC;
        impl crate::RegisterSpec for R32_PFIC_ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_ithresdr::R](R) reader structure
        impl crate::Readable for R32_PFIC_ITHRESDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_ithresdr::W](W) writer structure
        impl crate::Writable for R32_PFIC_ITHRESDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_ITHRESDR to value 0
        impl crate::Resettable for R32_PFIC_ITHRESDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_CFGR (w) register accessor: an alias for `Reg<R32_PFIC_CFGR_SPEC>`
    pub type R32_PFIC_CFGR = crate::Reg<r32_pfic_cfgr::R32_PFIC_CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod r32_pfic_cfgr {
        ///Register `R32_PFIC_CFGR` writer
        pub struct W(crate::W<R32_PFIC_CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RESETSYS` writer - WO,RESETSYS
        pub type RESETSYS_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_CFGR_SPEC, bool, O>;
        ///Field `KEYCODE` writer - WO,KEYCODE
        pub type KEYCODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_CFGR_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bit 7 - WO,RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn resetsys(&mut self) -> RESETSYS_W<7> {
                RESETSYS_W::new(self)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<16> {
                KEYCODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_cfgr](index.html) module
        pub struct R32_PFIC_CFGR_SPEC;
        impl crate::RegisterSpec for R32_PFIC_CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_cfgr::W](W) writer structure
        impl crate::Writable for R32_PFIC_CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_CFGR to value 0
        impl crate::Resettable for R32_PFIC_CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_GISR (r) register accessor: an alias for `Reg<R32_PFIC_GISR_SPEC>`
    pub type R32_PFIC_GISR = crate::Reg<r32_pfic_gisr::R32_PFIC_GISR_SPEC>;
    ///Interrupt Global Register
    pub mod r32_pfic_gisr {
        ///Register `R32_PFIC_GISR` reader
        pub struct R(crate::R<R32_PFIC_GISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_GISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_GISR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_GISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NESTSTA` reader - RO,NESTSTA
        pub type NESTSTA_R = crate::FieldReader<u8, u8>;
        ///Field `GACTSTA` reader - RO,GACTSTA
        pub type GACTSTA_R = crate::BitReader<bool>;
        ///Field `GPENDSTA` reader - RO,GPENDSTA
        pub type GPENDSTA_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:7 - RO,NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - RO,GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RO,GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_gisr](index.html) module
        pub struct R32_PFIC_GISR_SPEC;
        impl crate::RegisterSpec for R32_PFIC_GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_gisr::R](R) reader structure
        impl crate::Readable for R32_PFIC_GISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets R32_PFIC_GISR to value 0
        impl crate::Resettable for R32_PFIC_GISR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IDCFGR (rw) register accessor: an alias for `Reg<R32_PFIC_IDCFGR_SPEC>`
    pub type R32_PFIC_IDCFGR = crate::Reg<r32_pfic_idcfgr::R32_PFIC_IDCFGR_SPEC>;
    ///RW,Interrupt Fast ID Config Register
    pub mod r32_pfic_idcfgr {
        ///Register `R32_PFIC_IDCFGR` reader
        pub struct R(crate::R<R32_PFIC_IDCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IDCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IDCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IDCFGR` writer
        pub struct W(crate::W<R32_PFIC_IDCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IDCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IDCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FIID0` reader - RW,FIID0
        pub type FIID0_R = crate::FieldReader<u8, u8>;
        ///Field `FIID0` writer - RW,FIID0
        pub type FIID0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID1` reader - RW,FIID1
        pub type FIID1_R = crate::FieldReader<u8, u8>;
        ///Field `FIID1` writer - RW,FIID1
        pub type FIID1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID2` reader - RW,FIID2
        pub type FIID2_R = crate::FieldReader<u8, u8>;
        ///Field `FIID2` writer - RW,FIID2
        pub type FIID2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID3` reader - RW,FIID3
        pub type FIID3_R = crate::FieldReader<u8, u8>;
        ///Field `FIID3` writer - RW,FIID3
        pub type FIID3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            pub fn fiid0(&self) -> FIID0_R {
                FIID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            pub fn fiid1(&self) -> FIID1_R {
                FIID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            pub fn fiid2(&self) -> FIID2_R {
                FIID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            pub fn fiid3(&self) -> FIID3_R {
                FIID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            #[must_use]
            pub fn fiid0(&mut self) -> FIID0_W<0> {
                FIID0_W::new(self)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            #[must_use]
            pub fn fiid1(&mut self) -> FIID1_W<8> {
                FIID1_W::new(self)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            #[must_use]
            pub fn fiid2(&mut self) -> FIID2_W<16> {
                FIID2_W::new(self)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            #[must_use]
            pub fn fiid3(&mut self) -> FIID3_W<24> {
                FIID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Fast ID Config Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_idcfgr](index.html) module
        pub struct R32_PFIC_IDCFGR_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IDCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_idcfgr::R](R) reader structure
        impl crate::Readable for R32_PFIC_IDCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_idcfgr::W](W) writer structure
        impl crate::Writable for R32_PFIC_IDCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IDCFGR to value 0
        impl crate::Resettable for R32_PFIC_IDCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_FIADDRR0 (rw) register accessor: an alias for `Reg<R32_PFIC_FIADDRR0_SPEC>`
    pub type R32_PFIC_FIADDRR0 = crate::Reg<r32_pfic_fiaddrr0::R32_PFIC_FIADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod r32_pfic_fiaddrr0 {
        ///Register `R32_PFIC_FIADDRR0` reader
        pub struct R(crate::R<R32_PFIC_FIADDRR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_FIADDRR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_FIADDRR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_FIADDRR0` writer
        pub struct W(crate::W<R32_PFIC_FIADDRR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_FIADDRR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_FIADDRR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI0EN` reader - RW,FI0EN
        pub type FI0EN_R = crate::BitReader<bool>;
        ///Field `FI0EN` writer - RW,FI0EN
        pub type FI0EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_FIADDRR0_SPEC, bool, O>;
        ///Field `ADDR0` reader - RW,ADDR0
        pub type ADDR0_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR0` writer - RW,ADDR0
        pub type ADDR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_FIADDRR0_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            pub fn fi0en(&self) -> FI0EN_R {
                FI0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            #[must_use]
            pub fn fi0en(&mut self) -> FI0EN_W<0> {
                FI0EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<1> {
                ADDR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_fiaddrr0](index.html) module
        pub struct R32_PFIC_FIADDRR0_SPEC;
        impl crate::RegisterSpec for R32_PFIC_FIADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_fiaddrr0::R](R) reader structure
        impl crate::Readable for R32_PFIC_FIADDRR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_fiaddrr0::W](W) writer structure
        impl crate::Writable for R32_PFIC_FIADDRR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_FIADDRR0 to value 0
        impl crate::Resettable for R32_PFIC_FIADDRR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_FIADDRR1 (rw) register accessor: an alias for `Reg<R32_PFIC_FIADDRR1_SPEC>`
    pub type R32_PFIC_FIADDRR1 = crate::Reg<r32_pfic_fiaddrr1::R32_PFIC_FIADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod r32_pfic_fiaddrr1 {
        ///Register `R32_PFIC_FIADDRR1` reader
        pub struct R(crate::R<R32_PFIC_FIADDRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_FIADDRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_FIADDRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_FIADDRR1` writer
        pub struct W(crate::W<R32_PFIC_FIADDRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_FIADDRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_FIADDRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI1EN` reader - RW,FI1EN
        pub type FI1EN_R = crate::BitReader<bool>;
        ///Field `FI1EN` writer - RW,FI1EN
        pub type FI1EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_FIADDRR1_SPEC, bool, O>;
        ///Field `ADDR1` reader - RW,ADDR1
        pub type ADDR1_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR1` writer - RW,ADDR1
        pub type ADDR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_FIADDRR1_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            pub fn fi1en(&self) -> FI1EN_R {
                FI1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            #[must_use]
            pub fn fi1en(&mut self) -> FI1EN_W<0> {
                FI1EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<1> {
                ADDR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_fiaddrr1](index.html) module
        pub struct R32_PFIC_FIADDRR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_FIADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_fiaddrr1::R](R) reader structure
        impl crate::Readable for R32_PFIC_FIADDRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_fiaddrr1::W](W) writer structure
        impl crate::Writable for R32_PFIC_FIADDRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_FIADDRR1 to value 0
        impl crate::Resettable for R32_PFIC_FIADDRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_FIADDRR2 (rw) register accessor: an alias for `Reg<R32_PFIC_FIADDRR2_SPEC>`
    pub type R32_PFIC_FIADDRR2 = crate::Reg<r32_pfic_fiaddrr2::R32_PFIC_FIADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod r32_pfic_fiaddrr2 {
        ///Register `R32_PFIC_FIADDRR2` reader
        pub struct R(crate::R<R32_PFIC_FIADDRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_FIADDRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_FIADDRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_FIADDRR2` writer
        pub struct W(crate::W<R32_PFIC_FIADDRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_FIADDRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_FIADDRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI2EN` reader - RW,FI2EN
        pub type FI2EN_R = crate::BitReader<bool>;
        ///Field `FI2EN` writer - RW,FI2EN
        pub type FI2EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_FIADDRR2_SPEC, bool, O>;
        ///Field `ADDR2` reader - RW,ADDR2
        pub type ADDR2_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR2` writer - RW,ADDR2
        pub type ADDR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_FIADDRR2_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            pub fn fi2en(&self) -> FI2EN_R {
                FI2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            #[must_use]
            pub fn fi2en(&mut self) -> FI2EN_W<0> {
                FI2EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<1> {
                ADDR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_fiaddrr2](index.html) module
        pub struct R32_PFIC_FIADDRR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_FIADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_fiaddrr2::R](R) reader structure
        impl crate::Readable for R32_PFIC_FIADDRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_fiaddrr2::W](W) writer structure
        impl crate::Writable for R32_PFIC_FIADDRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_FIADDRR2 to value 0
        impl crate::Resettable for R32_PFIC_FIADDRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_FIADDRR3 (rw) register accessor: an alias for `Reg<R32_PFIC_FIADDRR3_SPEC>`
    pub type R32_PFIC_FIADDRR3 = crate::Reg<r32_pfic_fiaddrr3::R32_PFIC_FIADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod r32_pfic_fiaddrr3 {
        ///Register `R32_PFIC_FIADDRR3` reader
        pub struct R(crate::R<R32_PFIC_FIADDRR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_FIADDRR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_FIADDRR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_FIADDRR3` writer
        pub struct W(crate::W<R32_PFIC_FIADDRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_FIADDRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_FIADDRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI3EN` reader - RW,FI3EN
        pub type FI3EN_R = crate::BitReader<bool>;
        ///Field `FI3EN` writer - RW,FI3EN
        pub type FI3EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_FIADDRR3_SPEC, bool, O>;
        ///Field `ADDR3` reader - RW,ADDR3
        pub type ADDR3_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR3` writer - RW,ADDR3
        pub type ADDR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_FIADDRR3_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            pub fn fi3en(&self) -> FI3EN_R {
                FI3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            #[must_use]
            pub fn fi3en(&mut self) -> FI3EN_W<0> {
                FI3EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<1> {
                ADDR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_fiaddrr3](index.html) module
        pub struct R32_PFIC_FIADDRR3_SPEC;
        impl crate::RegisterSpec for R32_PFIC_FIADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_fiaddrr3::R](R) reader structure
        impl crate::Readable for R32_PFIC_FIADDRR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_fiaddrr3::W](W) writer structure
        impl crate::Writable for R32_PFIC_FIADDRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_FIADDRR3 to value 0
        impl crate::Resettable for R32_PFIC_FIADDRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IENR1 (w) register accessor: an alias for `Reg<R32_PFIC_IENR1_SPEC>`
    pub type R32_PFIC_IENR1 = crate::Reg<r32_pfic_ienr1::R32_PFIC_IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod r32_pfic_ienr1 {
        ///Register `R32_PFIC_IENR1` writer
        pub struct W(crate::W<R32_PFIC_IENR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IENR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IENR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IENR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<12> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ienr1](index.html) module
        pub struct R32_PFIC_IENR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_ienr1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IENR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IENR1 to value 0
        impl crate::Resettable for R32_PFIC_IENR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IENR2 (w) register accessor: an alias for `Reg<R32_PFIC_IENR2_SPEC>`
    pub type R32_PFIC_IENR2 = crate::Reg<r32_pfic_ienr2::R32_PFIC_IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod r32_pfic_ienr2 {
        ///Register `R32_PFIC_IENR2` writer
        pub struct W(crate::W<R32_PFIC_IENR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IENR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IENR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IENR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ienr2](index.html) module
        pub struct R32_PFIC_IENR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_ienr2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IENR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IENR2 to value 0
        impl crate::Resettable for R32_PFIC_IENR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IRER1 (w) register accessor: an alias for `Reg<R32_PFIC_IRER1_SPEC>`
    pub type R32_PFIC_IRER1 = crate::Reg<r32_pfic_irer1::R32_PFIC_IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod r32_pfic_irer1 {
        ///Register `R32_PFIC_IRER1` writer
        pub struct W(crate::W<R32_PFIC_IRER1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IRER1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IRER1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IRER1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<12> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_irer1](index.html) module
        pub struct R32_PFIC_IRER1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_irer1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IRER1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IRER1 to value 0
        impl crate::Resettable for R32_PFIC_IRER1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IRER2 (w) register accessor: an alias for `Reg<R32_PFIC_IRER2_SPEC>`
    pub type R32_PFIC_IRER2 = crate::Reg<r32_pfic_irer2::R32_PFIC_IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod r32_pfic_irer2 {
        ///Register `R32_PFIC_IRER2` writer
        pub struct W(crate::W<R32_PFIC_IRER2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IRER2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IRER2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IRER2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<0> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_irer2](index.html) module
        pub struct R32_PFIC_IRER2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_irer2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IRER2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IRER2 to value 0
        impl crate::Resettable for R32_PFIC_IRER2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPSR1 (w) register accessor: an alias for `Reg<R32_PFIC_IPSR1_SPEC>`
    pub type R32_PFIC_IPSR1 = crate::Reg<r32_pfic_ipsr1::R32_PFIC_IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod r32_pfic_ipsr1 {
        ///Register `R32_PFIC_IPSR1` writer
        pub struct W(crate::W<R32_PFIC_IPSR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPSR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPSR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPSR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<12> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ipsr1](index.html) module
        pub struct R32_PFIC_IPSR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_ipsr1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPSR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPSR1 to value 0
        impl crate::Resettable for R32_PFIC_IPSR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPSR2 (w) register accessor: an alias for `Reg<R32_PFIC_IPSR2_SPEC>`
    pub type R32_PFIC_IPSR2 = crate::Reg<r32_pfic_ipsr2::R32_PFIC_IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod r32_pfic_ipsr2 {
        ///Register `R32_PFIC_IPSR2` writer
        pub struct W(crate::W<R32_PFIC_IPSR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPSR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPSR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPSR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_ipsr2](index.html) module
        pub struct R32_PFIC_IPSR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_ipsr2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPSR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPSR2 to value 0
        impl crate::Resettable for R32_PFIC_IPSR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRR1 (w) register accessor: an alias for `Reg<R32_PFIC_IPRR1_SPEC>`
    pub type R32_PFIC_IPRR1 = crate::Reg<r32_pfic_iprr1::R32_PFIC_IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod r32_pfic_iprr1 {
        ///Register `R32_PFIC_IPRR1` writer
        pub struct W(crate::W<R32_PFIC_IPRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<12> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprr1](index.html) module
        pub struct R32_PFIC_IPRR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprr1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRR1 to value 0
        impl crate::Resettable for R32_PFIC_IPRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRR2 (w) register accessor: an alias for `Reg<R32_PFIC_IPRR2_SPEC>`
    pub type R32_PFIC_IPRR2 = crate::Reg<r32_pfic_iprr2::R32_PFIC_IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod r32_pfic_iprr2 {
        ///Register `R32_PFIC_IPRR2` writer
        pub struct W(crate::W<R32_PFIC_IPRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprr2](index.html) module
        pub struct R32_PFIC_IPRR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprr2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRR2 to value 0
        impl crate::Resettable for R32_PFIC_IPRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IACTR1 (rw) register accessor: an alias for `Reg<R32_PFIC_IACTR1_SPEC>`
    pub type R32_PFIC_IACTR1 = crate::Reg<r32_pfic_iactr1::R32_PFIC_IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod r32_pfic_iactr1 {
        ///Register `R32_PFIC_IACTR1` reader
        pub struct R(crate::R<R32_PFIC_IACTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IACTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IACTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IACTR1` writer
        pub struct W(crate::W<R32_PFIC_IACTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IACTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IACTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u32, u32>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IACTR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<12> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iactr1](index.html) module
        pub struct R32_PFIC_IACTR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iactr1::R](R) reader structure
        impl crate::Readable for R32_PFIC_IACTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iactr1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IACTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IACTR1 to value 0
        impl crate::Resettable for R32_PFIC_IACTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IACTR2 (rw) register accessor: an alias for `Reg<R32_PFIC_IACTR2_SPEC>`
    pub type R32_PFIC_IACTR2 = crate::Reg<r32_pfic_iactr2::R32_PFIC_IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod r32_pfic_iactr2 {
        ///Register `R32_PFIC_IACTR2` reader
        pub struct R(crate::R<R32_PFIC_IACTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IACTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IACTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IACTR2` writer
        pub struct W(crate::W<R32_PFIC_IACTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IACTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IACTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u8, u8>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IACTR2_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iactr2](index.html) module
        pub struct R32_PFIC_IACTR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iactr2::R](R) reader structure
        impl crate::Readable for R32_PFIC_IACTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iactr2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IACTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IACTR2 to value 0
        impl crate::Resettable for R32_PFIC_IACTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR0 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR0_SPEC>`
    pub type R32_PFIC_IPRIOR0 = crate::Reg<r32_pfic_iprior0::R32_PFIC_IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register 0
    pub mod r32_pfic_iprior0 {
        ///Register `R32_PFIC_IPRIOR0` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR0` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR0_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<0> {
                IPRIOR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 0
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior0](index.html) module
        pub struct R32_PFIC_IPRIOR0_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior0::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior0::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR0 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR1 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR1_SPEC>`
    pub type R32_PFIC_IPRIOR1 = crate::Reg<r32_pfic_iprior1::R32_PFIC_IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register 1
    pub mod r32_pfic_iprior1 {
        ///Register `R32_PFIC_IPRIOR1` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR1` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<0> {
                IPRIOR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior1](index.html) module
        pub struct R32_PFIC_IPRIOR1_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior1::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior1::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR1 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR2 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR2_SPEC>`
    pub type R32_PFIC_IPRIOR2 = crate::Reg<r32_pfic_iprior2::R32_PFIC_IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register 2
    pub mod r32_pfic_iprior2 {
        ///Register `R32_PFIC_IPRIOR2` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR2` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<0> {
                IPRIOR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior2](index.html) module
        pub struct R32_PFIC_IPRIOR2_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior2::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior2::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR2 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR3 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR3_SPEC>`
    pub type R32_PFIC_IPRIOR3 = crate::Reg<r32_pfic_iprior3::R32_PFIC_IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register 3
    pub mod r32_pfic_iprior3 {
        ///Register `R32_PFIC_IPRIOR3` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR3` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<0> {
                IPRIOR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior3](index.html) module
        pub struct R32_PFIC_IPRIOR3_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior3::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior3::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR3 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR4 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR4_SPEC>`
    pub type R32_PFIC_IPRIOR4 = crate::Reg<r32_pfic_iprior4::R32_PFIC_IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register 4
    pub mod r32_pfic_iprior4 {
        ///Register `R32_PFIC_IPRIOR4` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR4` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<0> {
                IPRIOR4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior4](index.html) module
        pub struct R32_PFIC_IPRIOR4_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior4::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior4::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR4 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR5 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR5_SPEC>`
    pub type R32_PFIC_IPRIOR5 = crate::Reg<r32_pfic_iprior5::R32_PFIC_IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register 5
    pub mod r32_pfic_iprior5 {
        ///Register `R32_PFIC_IPRIOR5` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR5` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<0> {
                IPRIOR5_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 5
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior5](index.html) module
        pub struct R32_PFIC_IPRIOR5_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior5::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior5::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR5 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR6 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR6_SPEC>`
    pub type R32_PFIC_IPRIOR6 = crate::Reg<r32_pfic_iprior6::R32_PFIC_IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register 6
    pub mod r32_pfic_iprior6 {
        ///Register `R32_PFIC_IPRIOR6` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR6` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<0> {
                IPRIOR6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 6
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior6](index.html) module
        pub struct R32_PFIC_IPRIOR6_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior6::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior6::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR6 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR7 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR7_SPEC>`
    pub type R32_PFIC_IPRIOR7 = crate::Reg<r32_pfic_iprior7::R32_PFIC_IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register 7
    pub mod r32_pfic_iprior7 {
        ///Register `R32_PFIC_IPRIOR7` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR7` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<0> {
                IPRIOR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 7
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior7](index.html) module
        pub struct R32_PFIC_IPRIOR7_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior7::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior7::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR7 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR8 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR8_SPEC>`
    pub type R32_PFIC_IPRIOR8 = crate::Reg<r32_pfic_iprior8::R32_PFIC_IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register 8
    pub mod r32_pfic_iprior8 {
        ///Register `R32_PFIC_IPRIOR8` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR8` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR8_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR8` reader - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR8` writer - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR8_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<0> {
                IPRIOR8_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 8
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior8](index.html) module
        pub struct R32_PFIC_IPRIOR8_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior8::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior8::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR8 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR9 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR9_SPEC>`
    pub type R32_PFIC_IPRIOR9 = crate::Reg<r32_pfic_iprior9::R32_PFIC_IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register 9
    pub mod r32_pfic_iprior9 {
        ///Register `R32_PFIC_IPRIOR9` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR9_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR9_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR9_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR9` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR9_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR9_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR9_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR9_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<0> {
                IPRIOR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 9
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior9](index.html) module
        pub struct R32_PFIC_IPRIOR9_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior9::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR9_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior9::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR9_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR9 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR9_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR10 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR10_SPEC>`
    pub type R32_PFIC_IPRIOR10 = crate::Reg<r32_pfic_iprior10::R32_PFIC_IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register 10
    pub mod r32_pfic_iprior10 {
        ///Register `R32_PFIC_IPRIOR10` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR10_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR10_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR10_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR10` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR10_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR10_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR10_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR10_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<0> {
                IPRIOR10_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 10
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior10](index.html) module
        pub struct R32_PFIC_IPRIOR10_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior10::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR10_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior10::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR10_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR10 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR10_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR11 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR11_SPEC>`
    pub type R32_PFIC_IPRIOR11 = crate::Reg<r32_pfic_iprior11::R32_PFIC_IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register 11
    pub mod r32_pfic_iprior11 {
        ///Register `R32_PFIC_IPRIOR11` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR11_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR11_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR11_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR11` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR11_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR11_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR11_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR11_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<0> {
                IPRIOR11_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 11
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior11](index.html) module
        pub struct R32_PFIC_IPRIOR11_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior11::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR11_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior11::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR11_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR11 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR11_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR12 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR12_SPEC>`
    pub type R32_PFIC_IPRIOR12 = crate::Reg<r32_pfic_iprior12::R32_PFIC_IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register 12
    pub mod r32_pfic_iprior12 {
        ///Register `R32_PFIC_IPRIOR12` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR12_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR12_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR12_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR12` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR12_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR12_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR12_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR12_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<0> {
                IPRIOR12_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 12
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior12](index.html) module
        pub struct R32_PFIC_IPRIOR12_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior12::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR12_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior12::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR12_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR12 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR12_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR13 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR13_SPEC>`
    pub type R32_PFIC_IPRIOR13 = crate::Reg<r32_pfic_iprior13::R32_PFIC_IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register 13
    pub mod r32_pfic_iprior13 {
        ///Register `R32_PFIC_IPRIOR13` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR13_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR13_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR13_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR13` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR13_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR13_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR13_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR13_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<0> {
                IPRIOR13_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 13
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior13](index.html) module
        pub struct R32_PFIC_IPRIOR13_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior13::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR13_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior13::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR13_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR13 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR13_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR14 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR14_SPEC>`
    pub type R32_PFIC_IPRIOR14 = crate::Reg<r32_pfic_iprior14::R32_PFIC_IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register 14
    pub mod r32_pfic_iprior14 {
        ///Register `R32_PFIC_IPRIOR14` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR14_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR14_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR14_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR14` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR14_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR14_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR14_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR14_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<0> {
                IPRIOR14_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 14
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior14](index.html) module
        pub struct R32_PFIC_IPRIOR14_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior14::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR14_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior14::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR14_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR14 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR14_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR15 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR15_SPEC>`
    pub type R32_PFIC_IPRIOR15 = crate::Reg<r32_pfic_iprior15::R32_PFIC_IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register 15
    pub mod r32_pfic_iprior15 {
        ///Register `R32_PFIC_IPRIOR15` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR15_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR15_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR15_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR15` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR15_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR15_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR15_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR15_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<0> {
                IPRIOR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 15
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior15](index.html) module
        pub struct R32_PFIC_IPRIOR15_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior15::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR15_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior15::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR15_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR15 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR15_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR16 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR16_SPEC>`
    pub type R32_PFIC_IPRIOR16 = crate::Reg<r32_pfic_iprior16::R32_PFIC_IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register 16
    pub mod r32_pfic_iprior16 {
        ///Register `R32_PFIC_IPRIOR16` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR16_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR16_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR16_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR16` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR16_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR16_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR16_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR16_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<0> {
                IPRIOR16_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 16
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior16](index.html) module
        pub struct R32_PFIC_IPRIOR16_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior16::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR16_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior16::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR16_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR16 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR16_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR17 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR17_SPEC>`
    pub type R32_PFIC_IPRIOR17 = crate::Reg<r32_pfic_iprior17::R32_PFIC_IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register 17
    pub mod r32_pfic_iprior17 {
        ///Register `R32_PFIC_IPRIOR17` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR17_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR17_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR17_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR17` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR17_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR17_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR17_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR17_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<0> {
                IPRIOR17_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 17
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior17](index.html) module
        pub struct R32_PFIC_IPRIOR17_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior17::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR17_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior17::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR17_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR17 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR17_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR18 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR18_SPEC>`
    pub type R32_PFIC_IPRIOR18 = crate::Reg<r32_pfic_iprior18::R32_PFIC_IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register 18
    pub mod r32_pfic_iprior18 {
        ///Register `R32_PFIC_IPRIOR18` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR18_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR18_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR18_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR18` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR18_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR18_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR18_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR18_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<0> {
                IPRIOR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 18
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior18](index.html) module
        pub struct R32_PFIC_IPRIOR18_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior18::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR18_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior18::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR18_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR18 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR18_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR19 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR19_SPEC>`
    pub type R32_PFIC_IPRIOR19 = crate::Reg<r32_pfic_iprior19::R32_PFIC_IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register 19
    pub mod r32_pfic_iprior19 {
        ///Register `R32_PFIC_IPRIOR19` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR19_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR19_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR19_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR19` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR19_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR19_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR19_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR19_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<0> {
                IPRIOR19_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 19
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior19](index.html) module
        pub struct R32_PFIC_IPRIOR19_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior19::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR19_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior19::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR19_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR19 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR19_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR20 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR20_SPEC>`
    pub type R32_PFIC_IPRIOR20 = crate::Reg<r32_pfic_iprior20::R32_PFIC_IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register 20
    pub mod r32_pfic_iprior20 {
        ///Register `R32_PFIC_IPRIOR20` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR20_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR20_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR20_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR20` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR20_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR20_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR20_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR20_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<0> {
                IPRIOR20_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 20
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior20](index.html) module
        pub struct R32_PFIC_IPRIOR20_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior20::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR20_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior20::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR20_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR20 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR20_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR21 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR21_SPEC>`
    pub type R32_PFIC_IPRIOR21 = crate::Reg<r32_pfic_iprior21::R32_PFIC_IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register 21
    pub mod r32_pfic_iprior21 {
        ///Register `R32_PFIC_IPRIOR21` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR21_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR21_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR21_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR21` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR21_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR21_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR21_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR21_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<0> {
                IPRIOR21_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 21
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior21](index.html) module
        pub struct R32_PFIC_IPRIOR21_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior21::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR21_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior21::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR21_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR21 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR21_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR22 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR22_SPEC>`
    pub type R32_PFIC_IPRIOR22 = crate::Reg<r32_pfic_iprior22::R32_PFIC_IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register 22
    pub mod r32_pfic_iprior22 {
        ///Register `R32_PFIC_IPRIOR22` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR22_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR22_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR22_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR22` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR22_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR22_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR22_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR22_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<0> {
                IPRIOR22_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 22
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior22](index.html) module
        pub struct R32_PFIC_IPRIOR22_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior22::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR22_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior22::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR22_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR22 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR22_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR23 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR23_SPEC>`
    pub type R32_PFIC_IPRIOR23 = crate::Reg<r32_pfic_iprior23::R32_PFIC_IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register 23
    pub mod r32_pfic_iprior23 {
        ///Register `R32_PFIC_IPRIOR23` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR23_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR23_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR23_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR23` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR23_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR23_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR23_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR23_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<0> {
                IPRIOR23_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 23
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior23](index.html) module
        pub struct R32_PFIC_IPRIOR23_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior23::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR23_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior23::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR23_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR23 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR23_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR24 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR24_SPEC>`
    pub type R32_PFIC_IPRIOR24 = crate::Reg<r32_pfic_iprior24::R32_PFIC_IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register 24
    pub mod r32_pfic_iprior24 {
        ///Register `R32_PFIC_IPRIOR24` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR24_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR24_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR24_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR24` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR24_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR24_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR24_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR24_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<0> {
                IPRIOR24_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 24
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior24](index.html) module
        pub struct R32_PFIC_IPRIOR24_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior24::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR24_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior24::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR24_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR24 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR24_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR25 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR25_SPEC>`
    pub type R32_PFIC_IPRIOR25 = crate::Reg<r32_pfic_iprior25::R32_PFIC_IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register 25
    pub mod r32_pfic_iprior25 {
        ///Register `R32_PFIC_IPRIOR25` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR25_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR25_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR25_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR25` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR25_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR25_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR25_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR25_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<0> {
                IPRIOR25_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 25
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior25](index.html) module
        pub struct R32_PFIC_IPRIOR25_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior25::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR25_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior25::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR25_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR25 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR25_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR26 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR26_SPEC>`
    pub type R32_PFIC_IPRIOR26 = crate::Reg<r32_pfic_iprior26::R32_PFIC_IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register 26
    pub mod r32_pfic_iprior26 {
        ///Register `R32_PFIC_IPRIOR26` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR26_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR26_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR26_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR26` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR26_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR26_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR26_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR26_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<0> {
                IPRIOR26_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 26
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior26](index.html) module
        pub struct R32_PFIC_IPRIOR26_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior26::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR26_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior26::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR26_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR26 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR26_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR27 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR27_SPEC>`
    pub type R32_PFIC_IPRIOR27 = crate::Reg<r32_pfic_iprior27::R32_PFIC_IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register 27
    pub mod r32_pfic_iprior27 {
        ///Register `R32_PFIC_IPRIOR27` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR27_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR27_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR27_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR27` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR27_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR27_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR27_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR27_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<0> {
                IPRIOR27_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 27
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior27](index.html) module
        pub struct R32_PFIC_IPRIOR27_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior27::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR27_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior27::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR27_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR27 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR27_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR28 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR28_SPEC>`
    pub type R32_PFIC_IPRIOR28 = crate::Reg<r32_pfic_iprior28::R32_PFIC_IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register 28
    pub mod r32_pfic_iprior28 {
        ///Register `R32_PFIC_IPRIOR28` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR28_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR28_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR28_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR28` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR28_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR28_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR28_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR28_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<0> {
                IPRIOR28_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 28
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior28](index.html) module
        pub struct R32_PFIC_IPRIOR28_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior28::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR28_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior28::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR28_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR28 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR28_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR29 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR29_SPEC>`
    pub type R32_PFIC_IPRIOR29 = crate::Reg<r32_pfic_iprior29::R32_PFIC_IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register 29
    pub mod r32_pfic_iprior29 {
        ///Register `R32_PFIC_IPRIOR29` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR29_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR29_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR29_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR29` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR29_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR29_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR29_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR29_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<0> {
                IPRIOR29_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 29
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior29](index.html) module
        pub struct R32_PFIC_IPRIOR29_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior29::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR29_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior29::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR29_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR29 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR29_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR30 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR30_SPEC>`
    pub type R32_PFIC_IPRIOR30 = crate::Reg<r32_pfic_iprior30::R32_PFIC_IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register 30
    pub mod r32_pfic_iprior30 {
        ///Register `R32_PFIC_IPRIOR30` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR30_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR30_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR30_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR30` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR30_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR30_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR30_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR30_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<0> {
                IPRIOR30_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 30
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior30](index.html) module
        pub struct R32_PFIC_IPRIOR30_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior30::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR30_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior30::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR30_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR30 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR30_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR31 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR31_SPEC>`
    pub type R32_PFIC_IPRIOR31 = crate::Reg<r32_pfic_iprior31::R32_PFIC_IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register 31
    pub mod r32_pfic_iprior31 {
        ///Register `R32_PFIC_IPRIOR31` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR31_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR31_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR31_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR31` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR31_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR31_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR31_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR31_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<0> {
                IPRIOR31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 31
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior31](index.html) module
        pub struct R32_PFIC_IPRIOR31_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior31::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR31_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior31::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR31_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR31 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR31_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR32 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR32_SPEC>`
    pub type R32_PFIC_IPRIOR32 = crate::Reg<r32_pfic_iprior32::R32_PFIC_IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register 32
    pub mod r32_pfic_iprior32 {
        ///Register `R32_PFIC_IPRIOR32` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR32_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR32_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR32_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR32` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR32_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR32_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR32_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR32_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<0> {
                IPRIOR32_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 32
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior32](index.html) module
        pub struct R32_PFIC_IPRIOR32_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior32::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR32_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior32::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR32_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR32 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR32_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR33 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR33_SPEC>`
    pub type R32_PFIC_IPRIOR33 = crate::Reg<r32_pfic_iprior33::R32_PFIC_IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register 33
    pub mod r32_pfic_iprior33 {
        ///Register `R32_PFIC_IPRIOR33` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR33_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR33_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR33_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR33` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR33_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR33_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR33_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR33_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<0> {
                IPRIOR33_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 33
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior33](index.html) module
        pub struct R32_PFIC_IPRIOR33_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior33::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR33_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior33::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR33_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR33 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR33_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR34 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR34_SPEC>`
    pub type R32_PFIC_IPRIOR34 = crate::Reg<r32_pfic_iprior34::R32_PFIC_IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register 34
    pub mod r32_pfic_iprior34 {
        ///Register `R32_PFIC_IPRIOR34` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR34_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR34_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR34_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR34` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR34_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR34_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR34_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR34_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<0> {
                IPRIOR34_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 34
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior34](index.html) module
        pub struct R32_PFIC_IPRIOR34_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior34::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR34_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior34::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR34_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR34 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR34_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR35 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR35_SPEC>`
    pub type R32_PFIC_IPRIOR35 = crate::Reg<r32_pfic_iprior35::R32_PFIC_IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register 35
    pub mod r32_pfic_iprior35 {
        ///Register `R32_PFIC_IPRIOR35` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR35_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR35_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR35_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR35` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR35_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR35_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR35_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR35_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<0> {
                IPRIOR35_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 35
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior35](index.html) module
        pub struct R32_PFIC_IPRIOR35_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior35::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR35_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior35::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR35_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR35 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR35_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR36 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR36_SPEC>`
    pub type R32_PFIC_IPRIOR36 = crate::Reg<r32_pfic_iprior36::R32_PFIC_IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register 36
    pub mod r32_pfic_iprior36 {
        ///Register `R32_PFIC_IPRIOR36` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR36_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR36_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR36_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR36` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR36_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR36_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR36_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR36_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<0> {
                IPRIOR36_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 36
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior36](index.html) module
        pub struct R32_PFIC_IPRIOR36_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior36::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR36_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior36::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR36_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR36 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR36_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR37 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR37_SPEC>`
    pub type R32_PFIC_IPRIOR37 = crate::Reg<r32_pfic_iprior37::R32_PFIC_IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register 37
    pub mod r32_pfic_iprior37 {
        ///Register `R32_PFIC_IPRIOR37` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR37_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR37_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR37_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR37` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR37_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR37_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR37_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR37_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<0> {
                IPRIOR37_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 37
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior37](index.html) module
        pub struct R32_PFIC_IPRIOR37_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior37::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR37_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior37::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR37_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR37 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR37_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR38 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR38_SPEC>`
    pub type R32_PFIC_IPRIOR38 = crate::Reg<r32_pfic_iprior38::R32_PFIC_IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register 38
    pub mod r32_pfic_iprior38 {
        ///Register `R32_PFIC_IPRIOR38` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR38_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR38_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR38_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR38` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR38_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR38_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR38_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR38_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<0> {
                IPRIOR38_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 38
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior38](index.html) module
        pub struct R32_PFIC_IPRIOR38_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior38::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR38_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior38::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR38_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR38 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR38_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR39 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR39_SPEC>`
    pub type R32_PFIC_IPRIOR39 = crate::Reg<r32_pfic_iprior39::R32_PFIC_IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register 39
    pub mod r32_pfic_iprior39 {
        ///Register `R32_PFIC_IPRIOR39` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR39_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR39_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR39_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR39` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR39_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR39_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR39_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR39_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<0> {
                IPRIOR39_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 39
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior39](index.html) module
        pub struct R32_PFIC_IPRIOR39_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior39::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR39_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior39::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR39_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR39 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR39_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR40 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR40_SPEC>`
    pub type R32_PFIC_IPRIOR40 = crate::Reg<r32_pfic_iprior40::R32_PFIC_IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register 40
    pub mod r32_pfic_iprior40 {
        ///Register `R32_PFIC_IPRIOR40` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR40_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR40_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR40_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR40` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR40_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR40_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR40_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR40_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<0> {
                IPRIOR40_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 40
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior40](index.html) module
        pub struct R32_PFIC_IPRIOR40_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior40::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR40_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior40::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR40_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR40 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR40_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR41 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR41_SPEC>`
    pub type R32_PFIC_IPRIOR41 = crate::Reg<r32_pfic_iprior41::R32_PFIC_IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register 41
    pub mod r32_pfic_iprior41 {
        ///Register `R32_PFIC_IPRIOR41` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR41_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR41_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR41_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR41` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR41_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR41_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR41_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR41_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<0> {
                IPRIOR41_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 41
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior41](index.html) module
        pub struct R32_PFIC_IPRIOR41_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior41::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR41_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior41::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR41_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR41 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR41_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR42 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR42_SPEC>`
    pub type R32_PFIC_IPRIOR42 = crate::Reg<r32_pfic_iprior42::R32_PFIC_IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register 42
    pub mod r32_pfic_iprior42 {
        ///Register `R32_PFIC_IPRIOR42` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR42_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR42_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR42_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR42` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR42_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR42_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR42_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR42_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<0> {
                IPRIOR42_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 42
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior42](index.html) module
        pub struct R32_PFIC_IPRIOR42_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior42::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR42_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior42::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR42_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR42 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR42_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR43 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR43_SPEC>`
    pub type R32_PFIC_IPRIOR43 = crate::Reg<r32_pfic_iprior43::R32_PFIC_IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register 43
    pub mod r32_pfic_iprior43 {
        ///Register `R32_PFIC_IPRIOR43` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR43_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR43_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR43_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR43` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR43_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR43_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR43_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR43_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<0> {
                IPRIOR43_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 43
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior43](index.html) module
        pub struct R32_PFIC_IPRIOR43_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior43::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR43_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior43::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR43_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR43 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR43_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR44 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR44_SPEC>`
    pub type R32_PFIC_IPRIOR44 = crate::Reg<r32_pfic_iprior44::R32_PFIC_IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register 44
    pub mod r32_pfic_iprior44 {
        ///Register `R32_PFIC_IPRIOR44` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR44_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR44_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR44_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR44` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR44_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR44_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR44_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR44_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<0> {
                IPRIOR44_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 44
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior44](index.html) module
        pub struct R32_PFIC_IPRIOR44_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior44::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR44_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior44::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR44_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR44 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR44_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR45 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR45_SPEC>`
    pub type R32_PFIC_IPRIOR45 = crate::Reg<r32_pfic_iprior45::R32_PFIC_IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register 45
    pub mod r32_pfic_iprior45 {
        ///Register `R32_PFIC_IPRIOR45` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR45_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR45_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR45_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR45` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR45_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR45_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR45_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR45_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<0> {
                IPRIOR45_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 45
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior45](index.html) module
        pub struct R32_PFIC_IPRIOR45_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior45::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR45_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior45::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR45_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR45 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR45_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR46 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR46_SPEC>`
    pub type R32_PFIC_IPRIOR46 = crate::Reg<r32_pfic_iprior46::R32_PFIC_IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register 46
    pub mod r32_pfic_iprior46 {
        ///Register `R32_PFIC_IPRIOR46` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR46_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR46_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR46_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR46` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR46_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR46_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR46_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR46_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<0> {
                IPRIOR46_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 46
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior46](index.html) module
        pub struct R32_PFIC_IPRIOR46_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior46::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR46_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior46::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR46_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR46 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR46_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR47 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR47_SPEC>`
    pub type R32_PFIC_IPRIOR47 = crate::Reg<r32_pfic_iprior47::R32_PFIC_IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register 47
    pub mod r32_pfic_iprior47 {
        ///Register `R32_PFIC_IPRIOR47` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR47_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR47_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR47_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR47` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR47_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR47_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR47_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR47_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<0> {
                IPRIOR47_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 47
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior47](index.html) module
        pub struct R32_PFIC_IPRIOR47_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior47::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR47_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior47::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR47_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR47 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR47_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR48 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR48_SPEC>`
    pub type R32_PFIC_IPRIOR48 = crate::Reg<r32_pfic_iprior48::R32_PFIC_IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register 48
    pub mod r32_pfic_iprior48 {
        ///Register `R32_PFIC_IPRIOR48` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR48_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR48_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR48_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR48` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR48_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR48_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR48_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR48_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<0> {
                IPRIOR48_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 48
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior48](index.html) module
        pub struct R32_PFIC_IPRIOR48_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior48::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR48_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior48::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR48_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR48 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR48_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR49 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR49_SPEC>`
    pub type R32_PFIC_IPRIOR49 = crate::Reg<r32_pfic_iprior49::R32_PFIC_IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register 49
    pub mod r32_pfic_iprior49 {
        ///Register `R32_PFIC_IPRIOR49` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR49_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR49_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR49_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR49` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR49_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR49_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR49_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR49_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<0> {
                IPRIOR49_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 49
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior49](index.html) module
        pub struct R32_PFIC_IPRIOR49_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior49::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR49_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior49::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR49_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR49 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR49_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR50 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR50_SPEC>`
    pub type R32_PFIC_IPRIOR50 = crate::Reg<r32_pfic_iprior50::R32_PFIC_IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register 50
    pub mod r32_pfic_iprior50 {
        ///Register `R32_PFIC_IPRIOR50` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR50_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR50_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR50_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR50` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR50_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR50_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR50_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR50_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<0> {
                IPRIOR50_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 50
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior50](index.html) module
        pub struct R32_PFIC_IPRIOR50_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior50::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR50_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior50::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR50_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR50 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR50_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR51 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR51_SPEC>`
    pub type R32_PFIC_IPRIOR51 = crate::Reg<r32_pfic_iprior51::R32_PFIC_IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register 51
    pub mod r32_pfic_iprior51 {
        ///Register `R32_PFIC_IPRIOR51` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR51_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR51_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR51_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR51` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR51_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR51_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR51_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR51_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<0> {
                IPRIOR51_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 51
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior51](index.html) module
        pub struct R32_PFIC_IPRIOR51_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior51::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR51_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior51::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR51_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR51 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR51_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR52 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR52_SPEC>`
    pub type R32_PFIC_IPRIOR52 = crate::Reg<r32_pfic_iprior52::R32_PFIC_IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register 52
    pub mod r32_pfic_iprior52 {
        ///Register `R32_PFIC_IPRIOR52` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR52_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR52_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR52_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR52` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR52_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR52_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR52_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR52_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<0> {
                IPRIOR52_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 52
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior52](index.html) module
        pub struct R32_PFIC_IPRIOR52_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior52::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR52_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior52::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR52_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR52 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR52_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR53 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR53_SPEC>`
    pub type R32_PFIC_IPRIOR53 = crate::Reg<r32_pfic_iprior53::R32_PFIC_IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register 53
    pub mod r32_pfic_iprior53 {
        ///Register `R32_PFIC_IPRIOR53` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR53_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR53_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR53_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR53` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR53_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR53_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR53_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR53_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<0> {
                IPRIOR53_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 53
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior53](index.html) module
        pub struct R32_PFIC_IPRIOR53_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior53::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR53_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior53::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR53_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR53 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR53_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR54 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR54_SPEC>`
    pub type R32_PFIC_IPRIOR54 = crate::Reg<r32_pfic_iprior54::R32_PFIC_IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register 54
    pub mod r32_pfic_iprior54 {
        ///Register `R32_PFIC_IPRIOR54` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR54_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR54_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR54_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR54` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR54_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR54_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR54_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR54_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<0> {
                IPRIOR54_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 54
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior54](index.html) module
        pub struct R32_PFIC_IPRIOR54_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior54::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR54_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior54::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR54_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR54 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR54_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR55 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR55_SPEC>`
    pub type R32_PFIC_IPRIOR55 = crate::Reg<r32_pfic_iprior55::R32_PFIC_IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register 55
    pub mod r32_pfic_iprior55 {
        ///Register `R32_PFIC_IPRIOR55` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR55_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR55_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR55_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR55` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR55_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR55_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR55_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR55_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<0> {
                IPRIOR55_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 55
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior55](index.html) module
        pub struct R32_PFIC_IPRIOR55_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior55::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR55_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior55::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR55_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR55 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR55_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR56 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR56_SPEC>`
    pub type R32_PFIC_IPRIOR56 = crate::Reg<r32_pfic_iprior56::R32_PFIC_IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register 56
    pub mod r32_pfic_iprior56 {
        ///Register `R32_PFIC_IPRIOR56` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR56_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR56_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR56_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR56` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR56_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR56_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR56_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR56_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<0> {
                IPRIOR56_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 56
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior56](index.html) module
        pub struct R32_PFIC_IPRIOR56_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior56::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR56_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior56::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR56_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR56 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR56_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR57 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR57_SPEC>`
    pub type R32_PFIC_IPRIOR57 = crate::Reg<r32_pfic_iprior57::R32_PFIC_IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register 57
    pub mod r32_pfic_iprior57 {
        ///Register `R32_PFIC_IPRIOR57` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR57_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR57_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR57_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR57` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR57_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR57_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR57_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR57_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<0> {
                IPRIOR57_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 57
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior57](index.html) module
        pub struct R32_PFIC_IPRIOR57_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior57::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR57_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior57::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR57_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR57 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR57_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR58 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR58_SPEC>`
    pub type R32_PFIC_IPRIOR58 = crate::Reg<r32_pfic_iprior58::R32_PFIC_IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register 58
    pub mod r32_pfic_iprior58 {
        ///Register `R32_PFIC_IPRIOR58` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR58_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR58_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR58_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR58` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR58_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR58_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR58_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR58_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<0> {
                IPRIOR58_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 58
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior58](index.html) module
        pub struct R32_PFIC_IPRIOR58_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior58::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR58_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior58::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR58_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR58 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR58_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR59 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR59_SPEC>`
    pub type R32_PFIC_IPRIOR59 = crate::Reg<r32_pfic_iprior59::R32_PFIC_IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register 59
    pub mod r32_pfic_iprior59 {
        ///Register `R32_PFIC_IPRIOR59` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR59_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR59_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR59_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR59` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR59_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR59_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR59_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR59_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<0> {
                IPRIOR59_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 59
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior59](index.html) module
        pub struct R32_PFIC_IPRIOR59_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior59::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR59_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior59::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR59_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR59 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR59_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR60 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR60_SPEC>`
    pub type R32_PFIC_IPRIOR60 = crate::Reg<r32_pfic_iprior60::R32_PFIC_IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register 60
    pub mod r32_pfic_iprior60 {
        ///Register `R32_PFIC_IPRIOR60` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR60_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR60_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR60_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR60` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR60_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR60_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR60_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR60_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<0> {
                IPRIOR60_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 60
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior60](index.html) module
        pub struct R32_PFIC_IPRIOR60_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior60::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR60_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior60::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR60_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR60 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR60_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR61 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR61_SPEC>`
    pub type R32_PFIC_IPRIOR61 = crate::Reg<r32_pfic_iprior61::R32_PFIC_IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register 61
    pub mod r32_pfic_iprior61 {
        ///Register `R32_PFIC_IPRIOR61` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR61_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR61_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR61_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR61` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR61_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR61_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR61_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR61_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<0> {
                IPRIOR61_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 61
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior61](index.html) module
        pub struct R32_PFIC_IPRIOR61_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior61::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR61_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior61::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR61_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR61 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR61_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR62 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR62_SPEC>`
    pub type R32_PFIC_IPRIOR62 = crate::Reg<r32_pfic_iprior62::R32_PFIC_IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register 62
    pub mod r32_pfic_iprior62 {
        ///Register `R32_PFIC_IPRIOR62` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR62_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR62_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR62_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR62` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR62_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR62_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR62_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR62_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<0> {
                IPRIOR62_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 62
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior62](index.html) module
        pub struct R32_PFIC_IPRIOR62_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior62::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR62_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior62::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR62_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR62 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR62_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_IPRIOR63 (rw) register accessor: an alias for `Reg<R32_PFIC_IPRIOR63_SPEC>`
    pub type R32_PFIC_IPRIOR63 = crate::Reg<r32_pfic_iprior63::R32_PFIC_IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register 63
    pub mod r32_pfic_iprior63 {
        ///Register `R32_PFIC_IPRIOR63` reader
        pub struct R(crate::R<R32_PFIC_IPRIOR63_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_IPRIOR63_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_IPRIOR63_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_IPRIOR63` writer
        pub struct W(crate::W<R32_PFIC_IPRIOR63_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_IPRIOR63_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_IPRIOR63_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_PFIC_IPRIOR63_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<0> {
                IPRIOR63_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 63
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_iprior63](index.html) module
        pub struct R32_PFIC_IPRIOR63_SPEC;
        impl crate::RegisterSpec for R32_PFIC_IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_iprior63::R](R) reader structure
        impl crate::Readable for R32_PFIC_IPRIOR63_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_iprior63::W](W) writer structure
        impl crate::Writable for R32_PFIC_IPRIOR63_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_IPRIOR63 to value 0
        impl crate::Resettable for R32_PFIC_IPRIOR63_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_PFIC_SCTLR (rw) register accessor: an alias for `Reg<R32_PFIC_SCTLR_SPEC>`
    pub type R32_PFIC_SCTLR = crate::Reg<r32_pfic_sctlr::R32_PFIC_SCTLR_SPEC>;
    ///System Control Register
    pub mod r32_pfic_sctlr {
        ///Register `R32_PFIC_SCTLR` reader
        pub struct R(crate::R<R32_PFIC_SCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_PFIC_SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_PFIC_SCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_PFIC_SCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_PFIC_SCTLR` writer
        pub struct W(crate::W<R32_PFIC_SCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_PFIC_SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_PFIC_SCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_PFIC_SCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader<bool>;
        ///Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SLEEPDEEP` reader - RW,SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader<bool>;
        ///Field `SLEEPDEEP` writer - RW,SLEEPDEEP
        pub type SLEEPDEEP_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_SCTLR_SPEC, bool, O>;
        ///Field `WFITOWFE` reader - RW,WFITOWFE
        pub type WFITOWFE_R = crate::BitReader<bool>;
        ///Field `WFITOWFE` writer - RW,WFITOWFE
        pub type WFITOWFE_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SEVONPEND` reader - RW,SEVONPEND
        pub type SEVONPEND_R = crate::BitReader<bool>;
        ///Field `SEVONPEND` writer - RW,SEVONPEND
        pub type SEVONPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SETEVENT` reader - WO,SETEVENT
        pub type SETEVENT_R = crate::BitReader<bool>;
        ///Field `SETEVENT` writer - WO,SETEVENT
        pub type SETEVENT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, R32_PFIC_SCTLR_SPEC, bool, O>;
        impl R {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<1> {
                SLEEPONEXIT_W::new(self)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<2> {
                SLEEPDEEP_W::new(self)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<3> {
                WFITOWFE_W::new(self)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<4> {
                SEVONPEND_W::new(self)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<5> {
                SETEVENT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System Control Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_pfic_sctlr](index.html) module
        pub struct R32_PFIC_SCTLR_SPEC;
        impl crate::RegisterSpec for R32_PFIC_SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_pfic_sctlr::R](R) reader structure
        impl crate::Readable for R32_PFIC_SCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_pfic_sctlr::W](W) writer structure
        impl crate::Writable for R32_PFIC_SCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_PFIC_SCTLR to value 0
        impl crate::Resettable for R32_PFIC_SCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Systick register
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick register
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Systick counter control register
        pub r32_stk_ctlr: R32_STK_CTLR,
        ///0x04 - Systick count status register
        pub r32_stk_sr: R32_STK_SR,
        ///0x08 - Systick counter low register
        pub r32_stk_cntl: R32_STK_CNTL,
        ///0x0c - Systick counter high register
        pub r32_stk_cnth: R32_STK_CNTH,
        ///0x10 - Systick compare low register
        pub r32_stk_cmplr: R32_STK_CMPLR,
        ///0x14 - Systick compare high register
        pub r32_stk_cmphr: R32_STK_CMPHR,
    }
    ///R32_STK_CTLR (rw) register accessor: an alias for `Reg<R32_STK_CTLR_SPEC>`
    pub type R32_STK_CTLR = crate::Reg<r32_stk_ctlr::R32_STK_CTLR_SPEC>;
    ///Systick counter control register
    pub mod r32_stk_ctlr {
        ///Register `R32_STK_CTLR` reader
        pub struct R(crate::R<R32_STK_CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_CTLR` writer
        pub struct W(crate::W<R32_STK_CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `STE` reader - Systick counter enable
        pub type STE_R = crate::BitReader<bool>;
        ///Field `STE` writer - Systick counter enable
        pub type STE_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `STIE` reader - Systick counter interrupt enable
        pub type STIE_R = crate::BitReader<bool>;
        ///Field `STIE` writer - Systick counter interrupt enable
        pub type STIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `STCLK` reader - System counter clock Source selection
        pub type STCLK_R = crate::BitReader<bool>;
        ///Field `STCLK` writer - System counter clock Source selection
        pub type STCLK_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `STRE` reader - System counter reload control
        pub type STRE_R = crate::BitReader<bool>;
        ///Field `STRE` writer - System counter reload control
        pub type STRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `MODE` reader - counter mode
        pub type MODE_R = crate::BitReader<bool>;
        ///Field `MODE` writer - counter mode
        pub type MODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `INIT` reader - Initial counter value updated
        pub type INIT_R = crate::BitReader<bool>;
        ///Field `INIT` writer - Initial counter value updated
        pub type INIT_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        ///Field `SWIE` reader - RW0,System soft interrupt enable
        pub type SWIE_R = crate::BitReader<bool>;
        ///Field `SWIE` writer - RW0,System soft interrupt enable
        pub type SWIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_CTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - System counter reload control
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - counter mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Initial counter value updated
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - RW0,System soft interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<0> {
                STE_W::new(self)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<1> {
                STIE_W::new(self)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<2> {
                STCLK_W::new(self)
            }
            ///Bit 3 - System counter reload control
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<3> {
                STRE_W::new(self)
            }
            ///Bit 4 - counter mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<4> {
                MODE_W::new(self)
            }
            ///Bit 5 - Initial counter value updated
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<5> {
                INIT_W::new(self)
            }
            ///Bit 31 - RW0,System soft interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<31> {
                SWIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_ctlr](index.html) module
        pub struct R32_STK_CTLR_SPEC;
        impl crate::RegisterSpec for R32_STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_ctlr::R](R) reader structure
        impl crate::Readable for R32_STK_CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_ctlr::W](W) writer structure
        impl crate::Writable for R32_STK_CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_CTLR to value 0
        impl crate::Resettable for R32_STK_CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_STK_SR (rw) register accessor: an alias for `Reg<R32_STK_SR_SPEC>`
    pub type R32_STK_SR = crate::Reg<r32_stk_sr::R32_STK_SR_SPEC>;
    ///Systick count status register
    pub mod r32_stk_sr {
        ///Register `R32_STK_SR` reader
        pub struct R(crate::R<R32_STK_SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_SR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_SR` writer
        pub struct W(crate::W<R32_STK_SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_SR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTIF` reader - RW,CNTIF
        pub type CNTIF_R = crate::BitReader<bool>;
        ///Field `CNTIF` writer - RW,CNTIF
        pub type CNTIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, R32_STK_SR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW,CNTIF
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,CNTIF
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<0> {
                CNTIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick count status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_sr](index.html) module
        pub struct R32_STK_SR_SPEC;
        impl crate::RegisterSpec for R32_STK_SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_sr::R](R) reader structure
        impl crate::Readable for R32_STK_SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_sr::W](W) writer structure
        impl crate::Writable for R32_STK_SR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_SR to value 0
        impl crate::Resettable for R32_STK_SR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_STK_CNTL (rw) register accessor: an alias for `Reg<R32_STK_CNTL_SPEC>`
    pub type R32_STK_CNTL = crate::Reg<r32_stk_cntl::R32_STK_CNTL_SPEC>;
    ///Systick counter low register
    pub mod r32_stk_cntl {
        ///Register `R32_STK_CNTL` reader
        pub struct R(crate::R<R32_STK_CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_CNTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_CNTL` writer
        pub struct W(crate::W<R32_STK_CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_CNTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - RW,CNTL
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - RW,CNTL
        pub type CNTL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_STK_CNTL_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_cntl](index.html) module
        pub struct R32_STK_CNTL_SPEC;
        impl crate::RegisterSpec for R32_STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_cntl::R](R) reader structure
        impl crate::Readable for R32_STK_CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_cntl::W](W) writer structure
        impl crate::Writable for R32_STK_CNTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_CNTL to value 0
        impl crate::Resettable for R32_STK_CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_STK_CNTH (rw) register accessor: an alias for `Reg<R32_STK_CNTH_SPEC>`
    pub type R32_STK_CNTH = crate::Reg<r32_stk_cnth::R32_STK_CNTH_SPEC>;
    ///Systick counter high register
    pub mod r32_stk_cnth {
        ///Register `R32_STK_CNTH` reader
        pub struct R(crate::R<R32_STK_CNTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_CNTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_CNTH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_CNTH` writer
        pub struct W(crate::W<R32_STK_CNTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_CNTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_CNTH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTH` reader - RW,CNTH
        pub type CNTH_R = crate::FieldReader<u32, u32>;
        ///Field `CNTH` writer - RW,CNTH
        pub type CNTH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_STK_CNTH_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<0> {
                CNTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter high register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_cnth](index.html) module
        pub struct R32_STK_CNTH_SPEC;
        impl crate::RegisterSpec for R32_STK_CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_cnth::R](R) reader structure
        impl crate::Readable for R32_STK_CNTH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_cnth::W](W) writer structure
        impl crate::Writable for R32_STK_CNTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_CNTH to value 0
        impl crate::Resettable for R32_STK_CNTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_STK_CMPLR (rw) register accessor: an alias for `Reg<R32_STK_CMPLR_SPEC>`
    pub type R32_STK_CMPLR = crate::Reg<r32_stk_cmplr::R32_STK_CMPLR_SPEC>;
    ///Systick compare low register
    pub mod r32_stk_cmplr {
        ///Register `R32_STK_CMPLR` reader
        pub struct R(crate::R<R32_STK_CMPLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_CMPLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_CMPLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_CMPLR` writer
        pub struct W(crate::W<R32_STK_CMPLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_CMPLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_CMPLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CMPL` reader - RW,CMPL
        pub type CMPL_R = crate::FieldReader<u32, u32>;
        ///Field `CMPL` writer - RW,CMPL
        pub type CMPL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_STK_CMPLR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<0> {
                CMPL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick compare low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_cmplr](index.html) module
        pub struct R32_STK_CMPLR_SPEC;
        impl crate::RegisterSpec for R32_STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_cmplr::R](R) reader structure
        impl crate::Readable for R32_STK_CMPLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_cmplr::W](W) writer structure
        impl crate::Writable for R32_STK_CMPLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_CMPLR to value 0
        impl crate::Resettable for R32_STK_CMPLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R32_STK_CMPHR (rw) register accessor: an alias for `Reg<R32_STK_CMPHR_SPEC>`
    pub type R32_STK_CMPHR = crate::Reg<r32_stk_cmphr::R32_STK_CMPHR_SPEC>;
    ///Systick compare high register
    pub mod r32_stk_cmphr {
        ///Register `R32_STK_CMPHR` reader
        pub struct R(crate::R<R32_STK_CMPHR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R32_STK_CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R32_STK_CMPHR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R32_STK_CMPHR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R32_STK_CMPHR` writer
        pub struct W(crate::W<R32_STK_CMPHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R32_STK_CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R32_STK_CMPHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R32_STK_CMPHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CMPH` reader - RW,CMPH
        pub type CMPH_R = crate::FieldReader<u32, u32>;
        ///Field `CMPH` writer - RW,CMPH
        pub type CMPH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R32_STK_CMPHR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            pub fn cmph(&self) -> CMPH_R {
                CMPH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            #[must_use]
            pub fn cmph(&mut self) -> CMPH_W<0> {
                CMPH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick compare high register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r32_stk_cmphr](index.html) module
        pub struct R32_STK_CMPHR_SPEC;
        impl crate::RegisterSpec for R32_STK_CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r32_stk_cmphr::R](R) reader structure
        impl crate::Readable for R32_STK_CMPHR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r32_stk_cmphr::W](W) writer structure
        impl crate::Writable for R32_STK_CMPHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R32_STK_CMPHR to value 0
        impl crate::Resettable for R32_STK_CMPHR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///TMR3
    pub TMR3: TMR3,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///SPI1
    pub SPI1: SPI1,
    ///I2C
    pub I2C: I2C,
    ///PWMX
    pub PWMX: PWMX,
    ///USB
    pub USB: USB,
    ///USB2
    pub USB2: USB2,
    ///PFIC
    pub PFIC: PFIC,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            I2C: I2C {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            USB2: USB2 {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
